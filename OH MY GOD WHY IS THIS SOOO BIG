--[=[
 d888b  db    db d888888b      .d888b.      db      db    db  .d8b.  
88' Y8b 88    88   `88'        VP  `8D      88      88    88 d8' `8b 
88      88    88    88            odD'      88      88    88 88ooo88 
88  ooo 88    88    88          .88'        88      88    88 88~~~88 
88. ~8~ 88b  d88   .88.        j88.         88booo. 88b  d88 88   88    @uniquadev
 Y888P  ~Y8888P' Y888888P      888888D      Y88888P ~Y8888P' YP   YP  CONVERTER 
]=]

-- Instances: 1302 | Scripts: 185 | Modules: 22 | Tags: 0
local G2L = {};

-- StarterGui.ScreenGui
G2L["1"] = Instance.new("ScreenGui", game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"));
G2L["1"]["ZIndexBehavior"] = Enum.ZIndexBehavior.Sibling;


-- StarterGui.ScreenGui.cool
G2L["2"] = Instance.new("ImageLabel", G2L["1"]);
G2L["2"]["BorderSizePixel"] = 0;
G2L["2"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2"]["Image"] = [[rbxassetid://9422866248]];
G2L["2"]["Size"] = UDim2.new(0, 118, 0, 100);
G2L["2"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2"]["Name"] = [[cool]];
G2L["2"]["Position"] = UDim2.new(-0.27778, 0, -0.28238, 0);


-- StarterGui.ScreenGui.cool.trollinggui
G2L["3"] = Instance.new("Frame", G2L["2"]);
G2L["3"]["Visible"] = false;
G2L["3"]["BorderSizePixel"] = 8;
G2L["3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3"]["Size"] = UDim2.new(0, 296, 0, 321);
G2L["3"]["Position"] = UDim2.new(5.353, 0, 3.521, 0);
G2L["3"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3"]["Name"] = [[trollinggui]];


-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame
G2L["4"] = Instance.new("ScrollingFrame", G2L["3"]);
G2L["4"]["Active"] = true;
G2L["4"]["BorderSizePixel"] = 3;
G2L["4"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4"]["Size"] = UDim2.new(0, 263, 0, 173);
G2L["4"]["ScrollBarImageColor3"] = Color3.fromRGB(0, 86, 0);
G2L["4"]["Position"] = UDim2.new(0.053, 0, 0.42054, 0);
G2L["4"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);


-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.UIListLayout
G2L["5"] = Instance.new("UIListLayout", G2L["4"]);
G2L["5"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.LIP Tg
G2L["6"] = Instance.new("TextButton", G2L["4"]);
G2L["6"]["TextWrapped"] = true;
G2L["6"]["BorderSizePixel"] = 3;
G2L["6"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["6"]["TextSize"] = 14;
G2L["6"]["TextScaled"] = true;
G2L["6"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["6"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["6"]["Size"] = UDim2.new(0, 248, 0, 37);
G2L["6"]["Name"] = [[LIP Tg]];
G2L["6"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["6"]["Text"] = [[LIP Trolling gui]];
G2L["6"]["Position"] = UDim2.new(0, 0, -0.05202, 0);


-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.Kill all
G2L["7"] = Instance.new("TextButton", G2L["4"]);
G2L["7"]["TextWrapped"] = true;
G2L["7"]["BorderSizePixel"] = 3;
G2L["7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["7"]["TextSize"] = 14;
G2L["7"]["TextScaled"] = true;
G2L["7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["7"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["7"]["Size"] = UDim2.new(0, 248, 0, 37);
G2L["7"]["Name"] = [[Kill all]];
G2L["7"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["7"]["Text"] = [[kill all]];


-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.Kill all.LocalScript
G2L["8"] = Instance.new("LocalScript", G2L["7"]);



-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.Kill all.RemoteEvent
G2L["9"] = Instance.new("RemoteEvent", G2L["7"]);



-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.Kill all.Script
G2L["a"] = Instance.new("Script", G2L["7"]);



-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.Shutdown
G2L["b"] = Instance.new("TextButton", G2L["4"]);
G2L["b"]["TextWrapped"] = true;
G2L["b"]["BorderSizePixel"] = 3;
G2L["b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b"]["TextSize"] = 14;
G2L["b"]["TextScaled"] = true;
G2L["b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["b"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["b"]["Size"] = UDim2.new(0, 248, 0, 37);
G2L["b"]["Name"] = [[Shutdown]];
G2L["b"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["b"]["Text"] = [[Shutdown server]];


-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.Shutdown.LocalScript
G2L["c"] = Instance.new("LocalScript", G2L["b"]);



-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.Shutdown.Script
G2L["d"] = Instance.new("Script", G2L["b"]);



-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.Shutdown.ShutDown
G2L["e"] = Instance.new("RemoteEvent", G2L["b"]);
G2L["e"]["Name"] = [[ShutDown]];


-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.Tg reborn
G2L["f"] = Instance.new("TextButton", G2L["4"]);
G2L["f"]["TextWrapped"] = true;
G2L["f"]["BorderSizePixel"] = 3;
G2L["f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["f"]["TextSize"] = 14;
G2L["f"]["TextScaled"] = true;
G2L["f"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["f"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["f"]["Size"] = UDim2.new(0, 248, 0, 37);
G2L["f"]["Name"] = [[Tg reborn]];
G2L["f"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["f"]["Text"] = [[trolling gui reborn]];
G2L["f"]["Position"] = UDim2.new(0.02662, 0, 0.52023, 0);


-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.Tg reborn.Script
G2L["10"] = Instance.new("Script", G2L["f"]);



-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.Tg reborn.LocalScript
G2L["11"] = Instance.new("LocalScript", G2L["f"]);



-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.Tg reborn.RemoteEvent
G2L["12"] = Instance.new("RemoteEvent", G2L["f"]);



-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.UICorner
G2L["13"] = Instance.new("UICorner", G2L["4"]);



-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.UIGradient
G2L["14"] = Instance.new("UIGradient", G2L["4"]);



-- StarterGui.ScreenGui.cool.trollinggui.TextLabel
G2L["15"] = Instance.new("TextLabel", G2L["3"]);
G2L["15"]["TextWrapped"] = true;
G2L["15"]["BorderSizePixel"] = 3;
G2L["15"]["TextSize"] = 25;
G2L["15"]["TextScaled"] = true;
G2L["15"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["15"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["15"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["15"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["15"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["15"]["Text"] = [[k00pgui (OP) trolling gui(page 4)]];
G2L["15"]["Position"] = UDim2.new(0.16216, 0, 0.04673, 0);


-- StarterGui.ScreenGui.cool.trollinggui.Smooth GUI Dragging
G2L["16"] = Instance.new("LocalScript", G2L["3"]);
G2L["16"]["Name"] = [[Smooth GUI Dragging]];


-- StarterGui.ScreenGui.cool.trollinggui.TextButton
G2L["17"] = Instance.new("TextButton", G2L["3"]);
G2L["17"]["TextWrapped"] = true;
G2L["17"]["BorderSizePixel"] = 3;
G2L["17"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["17"]["TextSize"] = 14;
G2L["17"]["TextScaled"] = true;
G2L["17"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["17"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["17"]["Size"] = UDim2.new(0, 110, 0, 50);
G2L["17"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["17"]["Text"] = [[Page 1]];
G2L["17"]["Position"] = UDim2.new(-0.02027, 0, -0.18069, 0);


-- StarterGui.ScreenGui.cool.trollinggui.TextButton.LocalScript
G2L["18"] = Instance.new("LocalScript", G2L["17"]);



-- StarterGui.ScreenGui.cool.trollinggui.TextButton
G2L["19"] = Instance.new("TextButton", G2L["3"]);
G2L["19"]["TextWrapped"] = true;
G2L["19"]["BorderSizePixel"] = 3;
G2L["19"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["19"]["TextSize"] = 14;
G2L["19"]["TextScaled"] = true;
G2L["19"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["19"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["19"]["Size"] = UDim2.new(0, 110, 0, 50);
G2L["19"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["19"]["Text"] = [[Page 2]];
G2L["19"]["Position"] = UDim2.new(0.38176, 0, -0.18069, 0);


-- StarterGui.ScreenGui.cool.trollinggui.TextButton.LocalScript
G2L["1a"] = Instance.new("LocalScript", G2L["19"]);



-- StarterGui.ScreenGui.cool.trollinggui.TextButton
G2L["1b"] = Instance.new("TextButton", G2L["3"]);
G2L["1b"]["TextWrapped"] = true;
G2L["1b"]["BorderSizePixel"] = 3;
G2L["1b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1b"]["TextSize"] = 14;
G2L["1b"]["TextScaled"] = true;
G2L["1b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1b"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1b"]["Size"] = UDim2.new(0, 110, 0, 50);
G2L["1b"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1b"]["Text"] = [[Page 3]];
G2L["1b"]["Position"] = UDim2.new(0.78716, 0, -0.18069, 0);


-- StarterGui.ScreenGui.cool.trollinggui.TextButton.LocalScript
G2L["1c"] = Instance.new("LocalScript", G2L["1b"]);



-- StarterGui.ScreenGui.cool.trollinggui.UICorner
G2L["1d"] = Instance.new("UICorner", G2L["3"]);



-- StarterGui.ScreenGui.cool.trollinggui.UIGradient
G2L["1e"] = Instance.new("UIGradient", G2L["3"]);



-- StarterGui.ScreenGui.cool.trollinggui.TextButton
G2L["1f"] = Instance.new("TextButton", G2L["3"]);
G2L["1f"]["TextWrapped"] = true;
G2L["1f"]["BorderSizePixel"] = 3;
G2L["1f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1f"]["TextSize"] = 14;
G2L["1f"]["TextScaled"] = true;
G2L["1f"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1f"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1f"]["Size"] = UDim2.new(0, 110, 0, 50);
G2L["1f"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1f"]["Text"] = [[Page 5]];
G2L["1f"]["Position"] = UDim2.new(-0.02027, 0, -0.3676, 0);


-- StarterGui.ScreenGui.cool.trollinggui.TextButton.LocalScript
G2L["20"] = Instance.new("LocalScript", G2L["1f"]);



-- StarterGui.ScreenGui.cool.trollinggui.TextButton
G2L["21"] = Instance.new("TextButton", G2L["3"]);
G2L["21"]["TextWrapped"] = true;
G2L["21"]["BorderSizePixel"] = 3;
G2L["21"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["21"]["TextSize"] = 14;
G2L["21"]["TextScaled"] = true;
G2L["21"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["21"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["21"]["Size"] = UDim2.new(0, 110, 0, 50);
G2L["21"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["21"]["Text"] = [[Page 6]];
G2L["21"]["Position"] = UDim2.new(0.38514, 0, -0.3676, 0);


-- StarterGui.ScreenGui.cool.trollinggui.TextButton.LocalScript
G2L["22"] = Instance.new("LocalScript", G2L["21"]);



-- StarterGui.ScreenGui.cool.trollinggui.TextButton
G2L["23"] = Instance.new("TextButton", G2L["3"]);
G2L["23"]["TextWrapped"] = true;
G2L["23"]["BorderSizePixel"] = 3;
G2L["23"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["23"]["TextSize"] = 14;
G2L["23"]["TextScaled"] = true;
G2L["23"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["23"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["23"]["Size"] = UDim2.new(0, 110, 0, 50);
G2L["23"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["23"]["Text"] = [[Page 7]];
G2L["23"]["Position"] = UDim2.new(0.78716, 0, -0.3676, 0);


-- StarterGui.ScreenGui.cool.trollinggui.TextButton.LocalScript
G2L["24"] = Instance.new("LocalScript", G2L["23"]);



-- StarterGui.ScreenGui.cool.trollinggui.TextButton
G2L["25"] = Instance.new("TextButton", G2L["3"]);
G2L["25"]["TextWrapped"] = true;
G2L["25"]["BorderSizePixel"] = 3;
G2L["25"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["25"]["TextSize"] = 14;
G2L["25"]["TextScaled"] = true;
G2L["25"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["25"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["25"]["Size"] = UDim2.new(0, 110, 0, 50);
G2L["25"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["25"]["Text"] = [[Page 8]];
G2L["25"]["Position"] = UDim2.new(-0.02027, 0, -0.52336, 0);


-- StarterGui.ScreenGui.cool.trollinggui.TextButton.LocalScript
G2L["26"] = Instance.new("LocalScript", G2L["25"]);



-- StarterGui.ScreenGui.cool.page5
G2L["27"] = Instance.new("Frame", G2L["2"]);
G2L["27"]["Visible"] = false;
G2L["27"]["BorderSizePixel"] = 0;
G2L["27"]["BackgroundColor3"] = Color3.fromRGB(0, 86, 0);
G2L["27"]["Size"] = UDim2.new(0, 422, 0, 320);
G2L["27"]["Position"] = UDim2.new(6.12055, 0, 3.98311, 0);
G2L["27"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["27"]["Name"] = [[page5]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame
G2L["28"] = Instance.new("ScrollingFrame", G2L["27"]);
G2L["28"]["Active"] = true;
G2L["28"]["BorderSizePixel"] = 0;
G2L["28"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["28"]["Size"] = UDim2.new(0, 410, 0, 304);
G2L["28"]["ScrollBarImageColor3"] = Color3.fromRGB(219, 219, 219);
G2L["28"]["Position"] = UDim2.new(0.01404, 0, 0.02187, 0);
G2L["28"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel
G2L["29"] = Instance.new("TextLabel", G2L["28"]);
G2L["29"]["TextWrapped"] = true;
G2L["29"]["BorderSizePixel"] = 3;
G2L["29"]["TextSize"] = 14;
G2L["29"]["TextScaled"] = true;
G2L["29"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["29"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["29"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["29"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["29"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["29"]["Text"] = [[k00pgui v4(OP) page 5]];
G2L["29"]["Position"] = UDim2.new(0.2561, 0, 0, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton
G2L["2a"] = Instance.new("TextButton", G2L["29"]);
G2L["2a"]["TextWrapped"] = true;
G2L["2a"]["BorderSizePixel"] = 3;
G2L["2a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2a"]["TextSize"] = 14;
G2L["2a"]["TextScaled"] = true;
G2L["2a"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2a"]["Size"] = UDim2.new(0, 165, 0, 44);
G2L["2a"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2a"]["Text"] = [[k00pgui v18]];
G2L["2a"]["Position"] = UDim2.new(-0.485, 0, 1.32, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script
G2L["2b"] = Instance.new("Script", G2L["2a"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["2c"] = Instance.new("LocalScript", G2L["2a"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["2d"] = Instance.new("RemoteEvent", G2L["2a"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton
G2L["2e"] = Instance.new("TextButton", G2L["29"]);
G2L["2e"]["TextWrapped"] = true;
G2L["2e"]["BorderSizePixel"] = 3;
G2L["2e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2e"]["TextSize"] = 14;
G2L["2e"]["TextScaled"] = true;
G2L["2e"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2e"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2e"]["Size"] = UDim2.new(0, 165, 0, 44);
G2L["2e"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2e"]["Text"] = [[Smoke All]];
G2L["2e"]["Position"] = UDim2.new(0.445, 0, 1.32, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script
G2L["2f"] = Instance.new("Script", G2L["2e"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["30"] = Instance.new("LocalScript", G2L["2e"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["31"] = Instance.new("RemoteEvent", G2L["2e"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton
G2L["32"] = Instance.new("TextButton", G2L["29"]);
G2L["32"]["TextWrapped"] = true;
G2L["32"]["BorderSizePixel"] = 3;
G2L["32"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["32"]["TextSize"] = 14;
G2L["32"]["TextScaled"] = true;
G2L["32"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["32"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["32"]["Size"] = UDim2.new(0, 165, 0, 44);
G2L["32"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["32"]["Text"] = [[afternoon time]];
G2L["32"]["Position"] = UDim2.new(-0.485, 0, 2.4, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script
G2L["33"] = Instance.new("Script", G2L["32"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["34"] = Instance.new("LocalScript", G2L["32"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["35"] = Instance.new("RemoteEvent", G2L["32"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton
G2L["36"] = Instance.new("TextButton", G2L["29"]);
G2L["36"]["TextWrapped"] = true;
G2L["36"]["BorderSizePixel"] = 3;
G2L["36"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["36"]["TextSize"] = 14;
G2L["36"]["TextScaled"] = true;
G2L["36"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["36"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["36"]["Size"] = UDim2.new(0, 165, 0, 44);
G2L["36"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["36"]["Text"] = [[freeze all]];
G2L["36"]["Position"] = UDim2.new(0.445, 0, 2.4, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script
G2L["37"] = Instance.new("Script", G2L["36"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["38"] = Instance.new("LocalScript", G2L["36"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["39"] = Instance.new("RemoteEvent", G2L["36"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton
G2L["3a"] = Instance.new("TextButton", G2L["29"]);
G2L["3a"]["TextWrapped"] = true;
G2L["3a"]["BorderSizePixel"] = 3;
G2L["3a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3a"]["TextSize"] = 14;
G2L["3a"]["TextScaled"] = true;
G2L["3a"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3a"]["Size"] = UDim2.new(0, 165, 0, 44);
G2L["3a"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3a"]["Text"] = [[kill others]];
G2L["3a"]["Position"] = UDim2.new(-0.485, 0, 3.5, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script
G2L["3b"] = Instance.new("Script", G2L["3a"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["3c"] = Instance.new("LocalScript", G2L["3a"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["3d"] = Instance.new("RemoteEvent", G2L["3a"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton
G2L["3e"] = Instance.new("TextButton", G2L["29"]);
G2L["3e"]["TextWrapped"] = true;
G2L["3e"]["BorderSizePixel"] = 3;
G2L["3e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3e"]["TextSize"] = 14;
G2L["3e"]["TextScaled"] = true;
G2L["3e"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3e"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3e"]["Size"] = UDim2.new(0, 165, 0, 44);
G2L["3e"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3e"]["Text"] = [[unfreeze all]];
G2L["3e"]["Position"] = UDim2.new(0.445, 0, 3.5, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script
G2L["3f"] = Instance.new("Script", G2L["3e"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["40"] = Instance.new("LocalScript", G2L["3e"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["41"] = Instance.new("RemoteEvent", G2L["3e"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton
G2L["42"] = Instance.new("TextButton", G2L["29"]);
G2L["42"]["TextWrapped"] = true;
G2L["42"]["BorderSizePixel"] = 3;
G2L["42"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["42"]["TextSize"] = 14;
G2L["42"]["TextScaled"] = true;
G2L["42"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["42"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["42"]["Size"] = UDim2.new(0, 165, 0, 44);
G2L["42"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["42"]["Text"] = [[l*ckgui v3]];
G2L["42"]["Position"] = UDim2.new(-0.485, 0, 4.74, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script
G2L["43"] = Instance.new("Script", G2L["42"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["44"] = Instance.new("LocalScript", G2L["42"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["45"] = Instance.new("RemoteEvent", G2L["42"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton
G2L["46"] = Instance.new("TextButton", G2L["29"]);
G2L["46"]["TextWrapped"] = true;
G2L["46"]["BorderSizePixel"] = 3;
G2L["46"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["46"]["TextSize"] = 14;
G2L["46"]["TextScaled"] = true;
G2L["46"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["46"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["46"]["Size"] = UDim2.new(0, 165, 0, 44);
G2L["46"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["46"]["Text"] = [[fake t****s 93 gui]];
G2L["46"]["Position"] = UDim2.new(0.445, 0, 4.74, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script
G2L["47"] = Instance.new("Script", G2L["46"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["48"] = Instance.new("LocalScript", G2L["46"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["49"] = Instance.new("RemoteEvent", G2L["46"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton
G2L["4a"] = Instance.new("TextButton", G2L["29"]);
G2L["4a"]["TextWrapped"] = true;
G2L["4a"]["BorderSizePixel"] = 3;
G2L["4a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4a"]["TextSize"] = 14;
G2L["4a"]["TextScaled"] = true;
G2L["4a"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4a"]["Size"] = UDim2.new(0, 165, 0, 44);
G2L["4a"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["4a"]["Text"] = [[HD Admin]];
G2L["4a"]["Position"] = UDim2.new(-0.485, 0, 5.98, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script
G2L["4b"] = Instance.new("Script", G2L["4a"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin
G2L["4c"] = Instance.new("Folder", G2L["4b"]);
G2L["4c"]["Name"] = [[HD Admin]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.Settings
G2L["4d"] = Instance.new("ModuleScript", G2L["4c"]);
G2L["4d"]["Name"] = [[Settings]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures
G2L["4e"] = Instance.new("Configuration", G2L["4c"]);
G2L["4e"]["Name"] = [[CustomFeatures]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Server
G2L["4f"] = Instance.new("Folder", G2L["4e"]);
G2L["4f"]["Name"] = [[Server]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Server.Assets
G2L["50"] = Instance.new("Folder", G2L["4f"]);
G2L["50"]["Name"] = [[Assets]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Server.Modules
G2L["51"] = Instance.new("Folder", G2L["4f"]);
G2L["51"]["Name"] = [[Modules]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Server.Modules.Commands
G2L["52"] = Instance.new("ModuleScript", G2L["51"]);
G2L["52"]["Name"] = [[Commands]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Server.Morphs
G2L["53"] = Instance.new("Folder", G2L["4f"]);
G2L["53"]["Name"] = [[Morphs]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Server.Tools
G2L["54"] = Instance.new("Folder", G2L["4f"]);
G2L["54"]["Name"] = [[Tools]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Client
G2L["55"] = Instance.new("Folder", G2L["4e"]);
G2L["55"]["Name"] = [[Client]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Client.StarterKit
G2L["56"] = Instance.new("Folder", G2L["55"]);
G2L["56"]["Name"] = [[StarterKit]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Client.Assets
G2L["57"] = Instance.new("Folder", G2L["55"]);
G2L["57"]["Name"] = [[Assets]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Client.Audio
G2L["58"] = Instance.new("Folder", G2L["55"]);
G2L["58"]["Name"] = [[Audio]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Client.Modules
G2L["59"] = Instance.new("Folder", G2L["55"]);
G2L["59"]["Name"] = [[Modules]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Client.Modules.ClientCommands
G2L["5a"] = Instance.new("ModuleScript", G2L["59"]);
G2L["5a"]["Name"] = [[ClientCommands]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Client.SharedModules
G2L["5b"] = Instance.new("Folder", G2L["55"]);
G2L["5b"]["Name"] = [[SharedModules]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Client.SharedModules.Events
G2L["5c"] = Instance.new("ModuleScript", G2L["5b"]);
G2L["5c"]["Name"] = [[Events]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Client.Signals
G2L["5d"] = Instance.new("Folder", G2L["55"]);
G2L["5d"]["Name"] = [[Signals]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Client.Signals.ExampleRemoteEvent
G2L["5e"] = Instance.new("RemoteEvent", G2L["5d"]);
G2L["5e"]["Name"] = [[ExampleRemoteEvent]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Client.Signals.ExampleBindableEvent
G2L["5f"] = Instance.new("BindableEvent", G2L["5d"]);
G2L["5f"]["Name"] = [[ExampleBindableEvent]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Client.Signals.ExampleRemoteFunction
G2L["60"] = Instance.new("RemoteFunction", G2L["5d"]);
G2L["60"]["Name"] = [[ExampleRemoteFunction]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script.HD Admin.CustomFeatures.Client.Signals.ExampleBindableFunction
G2L["61"] = Instance.new("BindableFunction", G2L["5d"]);
G2L["61"]["Name"] = [[ExampleBindableFunction]];


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton
G2L["62"] = Instance.new("TextButton", G2L["29"]);
G2L["62"]["TextWrapped"] = true;
G2L["62"]["BorderSizePixel"] = 3;
G2L["62"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["62"]["TextSize"] = 14;
G2L["62"]["TextScaled"] = true;
G2L["62"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["62"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["62"]["Size"] = UDim2.new(0, 165, 0, 44);
G2L["62"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["62"]["Text"] = [[Anti La**l hub destroyer]];
G2L["62"]["Position"] = UDim2.new(0.445, 0, 5.98, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script
G2L["63"] = Instance.new("Script", G2L["62"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton
G2L["64"] = Instance.new("TextButton", G2L["29"]);
G2L["64"]["TextWrapped"] = true;
G2L["64"]["BorderSizePixel"] = 3;
G2L["64"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["64"]["TextSize"] = 14;
G2L["64"]["TextScaled"] = true;
G2L["64"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["64"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["64"]["Size"] = UDim2.new(0, 165, 0, 44);
G2L["64"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["64"]["Text"] = [[Rat Sky]];
G2L["64"]["Position"] = UDim2.new(-0.485, 0, 7.2, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script
G2L["65"] = Instance.new("Script", G2L["64"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.
G2L["66"] = Instance.new("TextButton", G2L["29"]);
G2L["66"]["TextWrapped"] = true;
G2L["66"]["BorderSizePixel"] = 3;
G2L["66"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["66"]["TextSize"] = 14;
G2L["66"]["TextScaled"] = true;
G2L["66"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["66"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["66"]["Size"] = UDim2.new(0, 165, 0, 44);
G2L["66"]["Name"] = [[]];
G2L["66"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["66"]["Text"] = [[epok gui!1!]];
G2L["66"]["Position"] = UDim2.new(0.445, 0, 7.2, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel..Script
G2L["67"] = Instance.new("Script", G2L["66"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel..LocalScript
G2L["68"] = Instance.new("LocalScript", G2L["66"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel..RemoteEvent
G2L["69"] = Instance.new("RemoteEvent", G2L["66"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton
G2L["6a"] = Instance.new("TextButton", G2L["29"]);
G2L["6a"]["TextWrapped"] = true;
G2L["6a"]["BorderSizePixel"] = 3;
G2L["6a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["6a"]["TextSize"] = 14;
G2L["6a"]["TextScaled"] = true;
G2L["6a"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["6a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["6a"]["Size"] = UDim2.new(0, 165, 0, 44);
G2L["6a"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["6a"]["Text"] = [[Peebo audio]];
G2L["6a"]["Position"] = UDim2.new(-0.485, 0, 8.38, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script
G2L["6b"] = Instance.new("Script", G2L["6a"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script
G2L["6c"] = Instance.new("Script", G2L["6a"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton
G2L["6d"] = Instance.new("TextButton", G2L["29"]);
G2L["6d"]["TextWrapped"] = true;
G2L["6d"]["BorderSizePixel"] = 3;
G2L["6d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["6d"]["TextSize"] = 14;
G2L["6d"]["TextScaled"] = true;
G2L["6d"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["6d"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["6d"]["Size"] = UDim2.new(0, 165, 0, 44);
G2L["6d"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["6d"]["Text"] = [[c**lgui reborn]];
G2L["6d"]["Position"] = UDim2.new(0.445, 0, 8.38, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script
G2L["6e"] = Instance.new("Script", G2L["6d"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["6f"] = Instance.new("LocalScript", G2L["6d"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["70"] = Instance.new("RemoteEvent", G2L["6d"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton
G2L["71"] = Instance.new("TextButton", G2L["29"]);
G2L["71"]["TextWrapped"] = true;
G2L["71"]["BorderSizePixel"] = 3;
G2L["71"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["71"]["TextSize"] = 14;
G2L["71"]["TextScaled"] = true;
G2L["71"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["71"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["71"]["Size"] = UDim2.new(0, 165, 0, 44);
G2L["71"]["BorderColor3"] = Color3.fromRGB(171, 0, 0);
G2L["71"]["Text"] = [[stop all sound]];
G2L["71"]["Position"] = UDim2.new(0, 0, 9.64, 0);


-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.Script
G2L["72"] = Instance.new("Script", G2L["71"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["73"] = Instance.new("LocalScript", G2L["71"]);



-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["74"] = Instance.new("RemoteEvent", G2L["71"]);



-- StarterGui.ScreenGui.cool.page5.Smooth GUI Dragging
G2L["75"] = Instance.new("LocalScript", G2L["27"]);
G2L["75"]["Name"] = [[Smooth GUI Dragging]];


-- StarterGui.ScreenGui.cool.page5.TextButton
G2L["76"] = Instance.new("TextButton", G2L["27"]);
G2L["76"]["TextWrapped"] = true;
G2L["76"]["BorderSizePixel"] = 3;
G2L["76"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["76"]["TextSize"] = 14;
G2L["76"]["TextScaled"] = true;
G2L["76"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["76"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["76"]["Size"] = UDim2.new(0, 139, 0, 37);
G2L["76"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["76"]["Text"] = [[Page 1]];
G2L["76"]["Position"] = UDim2.new(0.00235, 0, -0.1163, 0);


-- StarterGui.ScreenGui.cool.page5.TextButton.LocalScript
G2L["77"] = Instance.new("LocalScript", G2L["76"]);



-- StarterGui.ScreenGui.cool.page5.TextButton
G2L["78"] = Instance.new("TextButton", G2L["27"]);
G2L["78"]["TextWrapped"] = true;
G2L["78"]["BorderSizePixel"] = 3;
G2L["78"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["78"]["TextSize"] = 14;
G2L["78"]["TextScaled"] = true;
G2L["78"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["78"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["78"]["Size"] = UDim2.new(0, 139, 0, 37);
G2L["78"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["78"]["Text"] = [[Page 2]];
G2L["78"]["Position"] = UDim2.new(0.34977, 0, -0.12568, 0);


-- StarterGui.ScreenGui.cool.page5.TextButton.LocalScript
G2L["79"] = Instance.new("LocalScript", G2L["78"]);



-- StarterGui.ScreenGui.cool.page5.TextButton
G2L["7a"] = Instance.new("TextButton", G2L["27"]);
G2L["7a"]["TextWrapped"] = true;
G2L["7a"]["BorderSizePixel"] = 3;
G2L["7a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["7a"]["TextSize"] = 14;
G2L["7a"]["TextScaled"] = true;
G2L["7a"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["7a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["7a"]["Size"] = UDim2.new(0, 139, 0, 37);
G2L["7a"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["7a"]["Text"] = [[Page 3]];
G2L["7a"]["Position"] = UDim2.new(0.69718, 0, -0.12568, 0);


-- StarterGui.ScreenGui.cool.page5.TextButton.LocalScript
G2L["7b"] = Instance.new("LocalScript", G2L["7a"]);



-- StarterGui.ScreenGui.cool.page5.TextButton
G2L["7c"] = Instance.new("TextButton", G2L["27"]);
G2L["7c"]["TextWrapped"] = true;
G2L["7c"]["BorderSizePixel"] = 3;
G2L["7c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["7c"]["TextSize"] = 14;
G2L["7c"]["TextScaled"] = true;
G2L["7c"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["7c"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["7c"]["Size"] = UDim2.new(0, 139, 0, 37);
G2L["7c"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["7c"]["Text"] = [[Page 4]];
G2L["7c"]["Position"] = UDim2.new(0.00235, 0, -0.28193, 0);


-- StarterGui.ScreenGui.cool.page5.TextButton.LocalScript
G2L["7d"] = Instance.new("LocalScript", G2L["7c"]);



-- StarterGui.ScreenGui.cool.page5.TextButton
G2L["7e"] = Instance.new("TextButton", G2L["27"]);
G2L["7e"]["TextWrapped"] = true;
G2L["7e"]["BorderSizePixel"] = 3;
G2L["7e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["7e"]["TextSize"] = 14;
G2L["7e"]["TextScaled"] = true;
G2L["7e"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["7e"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["7e"]["Size"] = UDim2.new(0, 139, 0, 37);
G2L["7e"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["7e"]["Text"] = [[Page 6]];
G2L["7e"]["Position"] = UDim2.new(0.34886, 0, -0.28193, 0);


-- StarterGui.ScreenGui.cool.page5.TextButton.LocalScript
G2L["7f"] = Instance.new("LocalScript", G2L["7e"]);



-- StarterGui.ScreenGui.cool.page5.TextButton
G2L["80"] = Instance.new("TextButton", G2L["27"]);
G2L["80"]["TextWrapped"] = true;
G2L["80"]["BorderSizePixel"] = 3;
G2L["80"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["80"]["TextSize"] = 14;
G2L["80"]["TextScaled"] = true;
G2L["80"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["80"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["80"]["Size"] = UDim2.new(0, 139, 0, 37);
G2L["80"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["80"]["Text"] = [[Page 7]];
G2L["80"]["Position"] = UDim2.new(0.71142, 0, -0.28193, 0);


-- StarterGui.ScreenGui.cool.page5.TextButton.LocalScript
G2L["81"] = Instance.new("LocalScript", G2L["80"]);



-- StarterGui.ScreenGui.cool.page5.TextButton
G2L["82"] = Instance.new("TextButton", G2L["27"]);
G2L["82"]["TextWrapped"] = true;
G2L["82"]["BorderSizePixel"] = 3;
G2L["82"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["82"]["TextSize"] = 14;
G2L["82"]["TextScaled"] = true;
G2L["82"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["82"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["82"]["Size"] = UDim2.new(0, 139, 0, 37);
G2L["82"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["82"]["Text"] = [[Page 8]];
G2L["82"]["Position"] = UDim2.new(0.00235, 0, -0.41943, 0);


-- StarterGui.ScreenGui.cool.page5.TextButton.LocalScript
G2L["83"] = Instance.new("LocalScript", G2L["82"]);



-- StarterGui.ScreenGui.cool.Page8
G2L["84"] = Instance.new("Frame", G2L["2"]);
G2L["84"]["Visible"] = false;
G2L["84"]["BorderSizePixel"] = 5;
G2L["84"]["BackgroundColor3"] = Color3.fromRGB(2, 54, 11);
G2L["84"]["Size"] = UDim2.new(0, 393, 0, 264);
G2L["84"]["Position"] = UDim2.new(3.66365, 0, 4.92082, 0);
G2L["84"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["84"]["Name"] = [[Page8]];


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame
G2L["85"] = Instance.new("ScrollingFrame", G2L["84"]);
G2L["85"]["Active"] = true;
G2L["85"]["BorderSizePixel"] = 0;
G2L["85"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["85"]["Size"] = UDim2.new(0, 377, 0, 250);
G2L["85"]["ScrollBarImageColor3"] = Color3.fromRGB(155, 155, 155);
G2L["85"]["Position"] = UDim2.new(0.02545, 0, 0.0303, 0);
G2L["85"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel
G2L["86"] = Instance.new("TextLabel", G2L["85"]);
G2L["86"]["TextWrapped"] = true;
G2L["86"]["BorderSizePixel"] = 3;
G2L["86"]["TextSize"] = 14;
G2L["86"]["TextScaled"] = true;
G2L["86"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["86"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["86"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["86"]["BackgroundTransparency"] = 100;
G2L["86"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["86"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["86"]["Text"] = [[K00pgui v4(OP) page 8 (jumpscare gui)]];
G2L["86"]["Position"] = UDim2.new(0.22812, 0, 0, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["87"] = Instance.new("TextButton", G2L["86"]);
G2L["87"]["TextWrapped"] = true;
G2L["87"]["BorderSizePixel"] = 3;
G2L["87"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["87"]["TextSize"] = 14;
G2L["87"]["TextScaled"] = true;
G2L["87"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["87"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["87"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["87"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["87"]["Text"] = [[k00pkidd]];
G2L["87"]["Position"] = UDim2.new(-0.335, 0, 1.26, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["88"] = Instance.new("Script", G2L["87"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["89"] = Instance.new("TextButton", G2L["86"]);
G2L["89"]["TextWrapped"] = true;
G2L["89"]["BorderSizePixel"] = 3;
G2L["89"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["89"]["TextSize"] = 14;
G2L["89"]["TextScaled"] = true;
G2L["89"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["89"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["89"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["89"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["89"]["Text"] = [[mr bean]];
G2L["89"]["Position"] = UDim2.new(0.25, 0, 1.26, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["8a"] = Instance.new("Script", G2L["89"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["8b"] = Instance.new("TextButton", G2L["86"]);
G2L["8b"]["TextWrapped"] = true;
G2L["8b"]["BorderSizePixel"] = 3;
G2L["8b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["8b"]["TextSize"] = 14;
G2L["8b"]["TextScaled"] = true;
G2L["8b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["8b"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["8b"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["8b"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["8b"]["Text"] = [[mario]];
G2L["8b"]["Position"] = UDim2.new(0.835, 0, 1.26, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["8c"] = Instance.new("Script", G2L["8b"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["8d"] = Instance.new("TextButton", G2L["86"]);
G2L["8d"]["TextWrapped"] = true;
G2L["8d"]["BorderSizePixel"] = 3;
G2L["8d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["8d"]["TextSize"] = 14;
G2L["8d"]["TextScaled"] = true;
G2L["8d"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["8d"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["8d"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["8d"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["8d"]["Text"] = [[thomas]];
G2L["8d"]["Position"] = UDim2.new(-0.335, 0, 2.5, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["8e"] = Instance.new("Script", G2L["8d"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["8f"] = Instance.new("TextButton", G2L["86"]);
G2L["8f"]["TextWrapped"] = true;
G2L["8f"]["BorderSizePixel"] = 3;
G2L["8f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["8f"]["TextSize"] = 14;
G2L["8f"]["TextScaled"] = true;
G2L["8f"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["8f"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["8f"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["8f"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["8f"]["Text"] = [[crykidd world tour]];
G2L["8f"]["Position"] = UDim2.new(0.25, 0, 2.5, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["90"] = Instance.new("Script", G2L["8f"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["91"] = Instance.new("TextButton", G2L["86"]);
G2L["91"]["TextWrapped"] = true;
G2L["91"]["BorderSizePixel"] = 3;
G2L["91"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["91"]["TextSize"] = 14;
G2L["91"]["TextScaled"] = true;
G2L["91"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["91"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["91"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["91"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["91"]["Text"] = [[crykidd drunk]];
G2L["91"]["Position"] = UDim2.new(0.835, 0, 2.5, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["92"] = Instance.new("Script", G2L["91"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["93"] = Instance.new("TextButton", G2L["86"]);
G2L["93"]["TextWrapped"] = true;
G2L["93"]["BorderSizePixel"] = 3;
G2L["93"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["93"]["TextSize"] = 14;
G2L["93"]["TextScaled"] = true;
G2L["93"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["93"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["93"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["93"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["93"]["Text"] = [[you are an idiot jumpscare]];
G2L["93"]["Position"] = UDim2.new(-0.335, 0, 3.7, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["94"] = Instance.new("Script", G2L["93"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["95"] = Instance.new("TextButton", G2L["86"]);
G2L["95"]["TextWrapped"] = true;
G2L["95"]["BorderSizePixel"] = 3;
G2L["95"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["95"]["TextSize"] = 14;
G2L["95"]["TextScaled"] = true;
G2L["95"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["95"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["95"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["95"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["95"]["Text"] = [[buff chihuahua]];
G2L["95"]["Position"] = UDim2.new(0.25, 0, 3.7, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["96"] = Instance.new("Script", G2L["95"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["97"] = Instance.new("TextButton", G2L["86"]);
G2L["97"]["TextWrapped"] = true;
G2L["97"]["BorderSizePixel"] = 3;
G2L["97"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["97"]["TextSize"] = 14;
G2L["97"]["TextScaled"] = true;
G2L["97"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["97"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["97"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["97"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["97"]["Text"] = [[k00pkidd op jumpscare 1]];
G2L["97"]["Position"] = UDim2.new(0.835, 0, 3.7, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["98"] = Instance.new("Script", G2L["97"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script.Images/Asian Head Funny  :3
G2L["99"] = Instance.new("Decal", G2L["98"]);
G2L["99"]["Name"] = [[Images/Asian Head Funny  :3]];
G2L["99"]["Texture"] = [[http://www.roblox.com/asset/?id=275216996]];


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script.funny TF2 scout
G2L["9a"] = Instance.new("Decal", G2L["98"]);
G2L["9a"]["Name"] = [[funny TF2 scout]];
G2L["9a"]["Texture"] = [[http://www.roblox.com/asset/?id=8683686271]];


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["9b"] = Instance.new("TextButton", G2L["86"]);
G2L["9b"]["TextWrapped"] = true;
G2L["9b"]["BorderSizePixel"] = 3;
G2L["9b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["9b"]["TextSize"] = 14;
G2L["9b"]["TextScaled"] = true;
G2L["9b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["9b"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["9b"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["9b"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["9b"]["Text"] = [[br4kidd jumpscare]];
G2L["9b"]["Position"] = UDim2.new(-0.335, 0, 4.88, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["9c"] = Instance.new("Script", G2L["9b"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["9d"] = Instance.new("TextButton", G2L["86"]);
G2L["9d"]["TextWrapped"] = true;
G2L["9d"]["BorderSizePixel"] = 3;
G2L["9d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["9d"]["TextSize"] = 14;
G2L["9d"]["TextScaled"] = true;
G2L["9d"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["9d"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["9d"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["9d"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["9d"]["Text"] = [[1s1s jumpscare]];
G2L["9d"]["Position"] = UDim2.new(0.25, 0, 4.88, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["9e"] = Instance.new("Script", G2L["9d"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["9f"] = Instance.new("TextButton", G2L["86"]);
G2L["9f"]["TextWrapped"] = true;
G2L["9f"]["BorderSizePixel"] = 3;
G2L["9f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["9f"]["TextSize"] = 14;
G2L["9f"]["TextScaled"] = true;
G2L["9f"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["9f"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["9f"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["9f"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["9f"]["Text"] = [[boykissa jumpscare]];
G2L["9f"]["Position"] = UDim2.new(0.835, 0, 4.88, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["a0"] = Instance.new("Script", G2L["9f"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["a1"] = Instance.new("TextButton", G2L["86"]);
G2L["a1"]["TextWrapped"] = true;
G2L["a1"]["BorderSizePixel"] = 3;
G2L["a1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["a1"]["TextSize"] = 14;
G2L["a1"]["TextScaled"] = true;
G2L["a1"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["a1"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["a1"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["a1"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["a1"]["Text"] = [[JO1TAR0 jumpscare]];
G2L["a1"]["Position"] = UDim2.new(-0.335, 0, 6.04, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["a2"] = Instance.new("Script", G2L["a1"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script.photo_2023-07-11_19-45-57
G2L["a3"] = Instance.new("Decal", G2L["a2"]);
G2L["a3"]["Name"] = [[photo_2023-07-11_19-45-57]];
G2L["a3"]["Texture"] = [[http://www.roblox.com/asset/?id=14031197258]];


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["a4"] = Instance.new("TextButton", G2L["86"]);
G2L["a4"]["TextWrapped"] = true;
G2L["a4"]["BorderSizePixel"] = 3;
G2L["a4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["a4"]["TextSize"] = 14;
G2L["a4"]["TextScaled"] = true;
G2L["a4"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["a4"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["a4"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["a4"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["a4"]["Text"] = [[k00pz jumpscare but with other audio]];
G2L["a4"]["Position"] = UDim2.new(0.25, 0, 6.04, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["a5"] = Instance.new("Script", G2L["a4"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script.photo_2023-07-11_19-45-57
G2L["a6"] = Instance.new("Decal", G2L["a5"]);
G2L["a6"]["Name"] = [[photo_2023-07-11_19-45-57]];
G2L["a6"]["Texture"] = [[http://www.roblox.com/asset/?id=14031197258]];


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["a7"] = Instance.new("TextButton", G2L["86"]);
G2L["a7"]["TextWrapped"] = true;
G2L["a7"]["BorderSizePixel"] = 3;
G2L["a7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["a7"]["TextSize"] = 14;
G2L["a7"]["TextScaled"] = true;
G2L["a7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["a7"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["a7"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["a7"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["a7"]["Text"] = [[John Cena]];
G2L["a7"]["Position"] = UDim2.new(0.835, 0, 6.04, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["a8"] = Instance.new("Script", G2L["a7"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script.photo_2023-07-11_19-45-57
G2L["a9"] = Instance.new("Decal", G2L["a8"]);
G2L["a9"]["Name"] = [[photo_2023-07-11_19-45-57]];
G2L["a9"]["Texture"] = [[http://www.roblox.com/asset/?id=14031197258]];


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["aa"] = Instance.new("TextButton", G2L["86"]);
G2L["aa"]["TextWrapped"] = true;
G2L["aa"]["BorderSizePixel"] = 3;
G2L["aa"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["aa"]["TextSize"] = 14;
G2L["aa"]["TextScaled"] = true;
G2L["aa"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["aa"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["aa"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["aa"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["aa"]["Text"] = [[kreekcraft feet]];
G2L["aa"]["Position"] = UDim2.new(-0.335, 0, 7.24, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["ab"] = Instance.new("Script", G2L["aa"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script.photo_2023-07-11_19-45-57
G2L["ac"] = Instance.new("Decal", G2L["ab"]);
G2L["ac"]["Name"] = [[photo_2023-07-11_19-45-57]];
G2L["ac"]["Texture"] = [[http://www.roblox.com/asset/?id=14031197258]];


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["ad"] = Instance.new("TextButton", G2L["86"]);
G2L["ad"]["TextWrapped"] = true;
G2L["ad"]["BorderSizePixel"] = 3;
G2L["ad"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["ad"]["TextSize"] = 14;
G2L["ad"]["TextScaled"] = true;
G2L["ad"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["ad"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["ad"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["ad"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["ad"]["Text"] = [[flamingo jump]];
G2L["ad"]["Position"] = UDim2.new(0.25, 0, 7.24, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["ae"] = Instance.new("Script", G2L["ad"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script.photo_2023-07-11_19-45-57
G2L["af"] = Instance.new("Decal", G2L["ae"]);
G2L["af"]["Name"] = [[photo_2023-07-11_19-45-57]];
G2L["af"]["Texture"] = [[http://www.roblox.com/asset/?id=14031197258]];


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["b0"] = Instance.new("TextButton", G2L["86"]);
G2L["b0"]["TextWrapped"] = true;
G2L["b0"]["BorderSizePixel"] = 3;
G2L["b0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b0"]["TextSize"] = 14;
G2L["b0"]["TextScaled"] = true;
G2L["b0"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["b0"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["b0"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["b0"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["b0"]["Text"] = [[Ronaldo Jumpscare]];
G2L["b0"]["Position"] = UDim2.new(0.835, 0, 7.24, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["b1"] = Instance.new("Script", G2L["b0"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script.photo_2023-07-11_19-45-57
G2L["b2"] = Instance.new("Decal", G2L["b1"]);
G2L["b2"]["Name"] = [[photo_2023-07-11_19-45-57]];
G2L["b2"]["Texture"] = [[http://www.roblox.com/asset/?id=14031197258]];


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script.Cristiano Ronaldo
G2L["b3"] = Instance.new("Decal", G2L["b1"]);
G2L["b3"]["Name"] = [[Cristiano Ronaldo]];
G2L["b3"]["Texture"] = [[http://www.roblox.com/asset/?id=192065193]];


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script.Cristiano Ronaldo.Audio/siuu
G2L["b4"] = Instance.new("Sound", G2L["b3"]);
G2L["b4"]["Name"] = [[Audio/siuu]];
G2L["b4"]["SoundId"] = [[rbxassetid://9124687139]];


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton
G2L["b5"] = Instance.new("TextButton", G2L["86"]);
G2L["b5"]["TextWrapped"] = true;
G2L["b5"]["BorderSizePixel"] = 3;
G2L["b5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b5"]["TextSize"] = 14;
G2L["b5"]["TextScaled"] = true;
G2L["b5"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["b5"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["b5"]["Size"] = UDim2.new(0, 105, 0, 44);
G2L["b5"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["b5"]["Text"] = [[Farm Jumpscare]];
G2L["b5"]["Position"] = UDim2.new(-0.335, 0, 8.44, 0);


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script
G2L["b6"] = Instance.new("Script", G2L["b5"]);



-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.TextLabel.TextButton.Script.photo_2023-07-11_19-45-57
G2L["b7"] = Instance.new("Decal", G2L["b6"]);
G2L["b7"]["Name"] = [[photo_2023-07-11_19-45-57]];
G2L["b7"]["Texture"] = [[http://www.roblox.com/asset/?id=14031197258]];


-- StarterGui.ScreenGui.cool.Page8.ScrollingFrame.ImageLabel
G2L["b8"] = Instance.new("ImageLabel", G2L["85"]);
G2L["b8"]["BorderSizePixel"] = 0;
G2L["b8"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b8"]["Image"] = [[rbxassetid://9018233362]];
G2L["b8"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["b8"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["b8"]["Position"] = UDim2.new(0.40584, 0, 0.81622, 0);


-- StarterGui.ScreenGui.cool.Page8.Smooth GUI Dragging
G2L["b9"] = Instance.new("LocalScript", G2L["84"]);
G2L["b9"]["Name"] = [[Smooth GUI Dragging]];


-- StarterGui.ScreenGui.cool.Page8.TextButton
G2L["ba"] = Instance.new("TextButton", G2L["84"]);
G2L["ba"]["TextWrapped"] = true;
G2L["ba"]["BorderSizePixel"] = 3;
G2L["ba"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["ba"]["TextSize"] = 14;
G2L["ba"]["TextScaled"] = true;
G2L["ba"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["ba"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["ba"]["Size"] = UDim2.new(0, 104, 0, 36);
G2L["ba"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["ba"]["Text"] = [[Page 1]];
G2L["ba"]["Position"] = UDim2.new(0, 0, -0.15904, 0);


-- StarterGui.ScreenGui.cool.Page8.TextButton.LocalScript
G2L["bb"] = Instance.new("LocalScript", G2L["ba"]);



-- StarterGui.ScreenGui.cool.Page8.TextButton
G2L["bc"] = Instance.new("TextButton", G2L["84"]);
G2L["bc"]["TextWrapped"] = true;
G2L["bc"]["BorderSizePixel"] = 3;
G2L["bc"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["bc"]["TextSize"] = 14;
G2L["bc"]["TextScaled"] = true;
G2L["bc"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["bc"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["bc"]["Size"] = UDim2.new(0, 104, 0, 36);
G2L["bc"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["bc"]["Text"] = [[Page 2]];
G2L["bc"]["Position"] = UDim2.new(0.31298, 0, -0.15904, 0);


-- StarterGui.ScreenGui.cool.Page8.TextButton.LocalScript
G2L["bd"] = Instance.new("LocalScript", G2L["bc"]);



-- StarterGui.ScreenGui.cool.Page8.TextButton
G2L["be"] = Instance.new("TextButton", G2L["84"]);
G2L["be"]["TextWrapped"] = true;
G2L["be"]["BorderSizePixel"] = 3;
G2L["be"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["be"]["TextSize"] = 14;
G2L["be"]["TextScaled"] = true;
G2L["be"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["be"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["be"]["Size"] = UDim2.new(0, 104, 0, 36);
G2L["be"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["be"]["Text"] = [[Page 3]];
G2L["be"]["Position"] = UDim2.new(0.61323, 0, -0.15904, 0);


-- StarterGui.ScreenGui.cool.Page8.TextButton.LocalScript
G2L["bf"] = Instance.new("LocalScript", G2L["be"]);



-- StarterGui.ScreenGui.cool.Page8.TextButton
G2L["c0"] = Instance.new("TextButton", G2L["84"]);
G2L["c0"]["TextWrapped"] = true;
G2L["c0"]["BorderSizePixel"] = 3;
G2L["c0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c0"]["TextSize"] = 14;
G2L["c0"]["TextScaled"] = true;
G2L["c0"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c0"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["c0"]["Size"] = UDim2.new(0, 104, 0, 36);
G2L["c0"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["c0"]["Text"] = [[Page 4]];
G2L["c0"]["Position"] = UDim2.new(0, 0, -0.32192, 0);


-- StarterGui.ScreenGui.cool.Page8.TextButton.LocalScript
G2L["c1"] = Instance.new("LocalScript", G2L["c0"]);



-- StarterGui.ScreenGui.cool.Page8.TextButton
G2L["c2"] = Instance.new("TextButton", G2L["84"]);
G2L["c2"]["TextWrapped"] = true;
G2L["c2"]["BorderSizePixel"] = 3;
G2L["c2"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c2"]["TextSize"] = 14;
G2L["c2"]["TextScaled"] = true;
G2L["c2"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c2"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["c2"]["Size"] = UDim2.new(0, 104, 0, 36);
G2L["c2"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["c2"]["Text"] = [[Page 5]];
G2L["c2"]["Position"] = UDim2.new(0.31298, 0, -0.32192, 0);


-- StarterGui.ScreenGui.cool.Page8.TextButton.LocalScript
G2L["c3"] = Instance.new("LocalScript", G2L["c2"]);



-- StarterGui.ScreenGui.cool.Page8.TextButton
G2L["c4"] = Instance.new("TextButton", G2L["84"]);
G2L["c4"]["TextWrapped"] = true;
G2L["c4"]["BorderSizePixel"] = 3;
G2L["c4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c4"]["TextSize"] = 14;
G2L["c4"]["TextScaled"] = true;
G2L["c4"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c4"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["c4"]["Size"] = UDim2.new(0, 104, 0, 36);
G2L["c4"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["c4"]["Text"] = [[Page 6]];
G2L["c4"]["Position"] = UDim2.new(0.61323, 0, -0.32192, 0);


-- StarterGui.ScreenGui.cool.Page8.TextButton.LocalScript
G2L["c5"] = Instance.new("LocalScript", G2L["c4"]);



-- StarterGui.ScreenGui.cool.Page8.TextButton
G2L["c6"] = Instance.new("TextButton", G2L["84"]);
G2L["c6"]["TextWrapped"] = true;
G2L["c6"]["BorderSizePixel"] = 3;
G2L["c6"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c6"]["TextSize"] = 14;
G2L["c6"]["TextScaled"] = true;
G2L["c6"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c6"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["c6"]["Size"] = UDim2.new(0, 104, 0, 36);
G2L["c6"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["c6"]["Text"] = [[Page 7]];
G2L["c6"]["Position"] = UDim2.new(0, 0, -0.48859, 0);


-- StarterGui.ScreenGui.cool.Page8.TextButton.LocalScript
G2L["c7"] = Instance.new("LocalScript", G2L["c6"]);



-- StarterGui.ScreenGui.cool.Page7
G2L["c8"] = Instance.new("Frame", G2L["2"]);
G2L["c8"]["Visible"] = false;
G2L["c8"]["BorderSizePixel"] = 0;
G2L["c8"]["BackgroundColor3"] = Color3.fromRGB(0, 86, 0);
G2L["c8"]["Size"] = UDim2.new(0, 466, 0, 366);
G2L["c8"]["Position"] = UDim2.new(3.60097, 0, 4.76232, 0);
G2L["c8"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c8"]["Name"] = [[Page7]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame
G2L["c9"] = Instance.new("ScrollingFrame", G2L["c8"]);
G2L["c9"]["Active"] = true;
G2L["c9"]["BorderSizePixel"] = 0;
G2L["c9"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c9"]["Size"] = UDim2.new(0, 454, 0, 353);
G2L["c9"]["ScrollBarImageColor3"] = Color3.fromRGB(131, 131, 131);
G2L["c9"]["Position"] = UDim2.new(0.01288, 0, 0.01639, 0);
G2L["c9"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel
G2L["ca"] = Instance.new("TextLabel", G2L["c9"]);
G2L["ca"]["TextWrapped"] = true;
G2L["ca"]["BorderSizePixel"] = 3;
G2L["ca"]["TextSize"] = 14;
G2L["ca"]["TextScaled"] = true;
G2L["ca"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["ca"]["FontFace"] = Font.new([[rbxasset://fonts/families/FredokaOne.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["ca"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["ca"]["Size"] = UDim2.new(0, 216, 0, 50);
G2L["ca"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["ca"]["Text"] = [[k00pgui v4(OP) page 7]];
G2L["ca"]["Position"] = UDim2.new(0.26211, 0, -0.00057, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["cb"] = Instance.new("TextButton", G2L["ca"]);
G2L["cb"]["TextWrapped"] = true;
G2L["cb"]["BorderSizePixel"] = 3;
G2L["cb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["cb"]["TextSize"] = 14;
G2L["cb"]["TextScaled"] = true;
G2L["cb"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["cb"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["cb"]["Size"] = UDim2.new(0, 160, 0, 50);
G2L["cb"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["cb"]["Text"] = [[John Doe[R6]]];
G2L["cb"]["Position"] = UDim2.new(-0.525, 0, 1.28, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["cc"] = Instance.new("Script", G2L["cb"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["cd"] = Instance.new("Script", G2L["cb"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["ce"] = Instance.new("LocalScript", G2L["cb"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["cf"] = Instance.new("RemoteEvent", G2L["cb"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["d0"] = Instance.new("TextButton", G2L["ca"]);
G2L["d0"]["TextWrapped"] = true;
G2L["d0"]["BorderSizePixel"] = 3;
G2L["d0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["d0"]["TextSize"] = 14;
G2L["d0"]["TextScaled"] = true;
G2L["d0"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["d0"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["d0"]["Size"] = UDim2.new(0, 79, 0, 31);
G2L["d0"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["d0"]["Text"] = [[R6]];
G2L["d0"]["Position"] = UDim2.new(-0.525, 0, 0.18, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["d1"] = Instance.new("Script", G2L["d0"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["d2"] = Instance.new("LocalScript", G2L["d0"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["d3"] = Instance.new("RemoteEvent", G2L["d0"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["d4"] = Instance.new("TextButton", G2L["ca"]);
G2L["d4"]["TextWrapped"] = true;
G2L["d4"]["BorderSizePixel"] = 3;
G2L["d4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["d4"]["TextSize"] = 14;
G2L["d4"]["TextScaled"] = true;
G2L["d4"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["d4"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["d4"]["Size"] = UDim2.new(0, 93, 0, 50);
G2L["d4"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["d4"]["Text"] = [[K**X sky]];
G2L["d4"]["Position"] = UDim2.new(1.05444, 0, 1.28, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["d5"] = Instance.new("Script", G2L["d4"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["d6"] = Instance.new("TextButton", G2L["ca"]);
G2L["d6"]["TextWrapped"] = true;
G2L["d6"]["BorderSizePixel"] = 3;
G2L["d6"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["d6"]["TextSize"] = 14;
G2L["d6"]["TextScaled"] = true;
G2L["d6"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["d6"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["d6"]["Size"] = UDim2.new(0, 160, 0, 50);
G2L["d6"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["d6"]["Text"] = [[Hammer[R6]]];
G2L["d6"]["Position"] = UDim2.new(0.25815, 0, 1.28, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["d7"] = Instance.new("Script", G2L["d6"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse
G2L["d8"] = Instance.new("LocalScript", G2L["d7"]);
G2L["d8"]["Enabled"] = false;
G2L["d8"]["Name"] = [[Mouse]];
G2L["d8"]["Disabled"] = true;


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.KeyDown
G2L["d9"] = Instance.new("RemoteEvent", G2L["d8"]);
G2L["d9"]["Name"] = [[KeyDown]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.Button1Down
G2L["da"] = Instance.new("RemoteEvent", G2L["d8"]);
G2L["da"]["Name"] = [[Button1Down]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.KeyUp
G2L["db"] = Instance.new("RemoteEvent", G2L["d8"]);
G2L["db"]["Name"] = [[KeyUp]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.Button1Up
G2L["dc"] = Instance.new("RemoteEvent", G2L["d8"]);
G2L["dc"]["Name"] = [[Button1Up]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["dd"] = Instance.new("TextButton", G2L["ca"]);
G2L["dd"]["TextWrapped"] = true;
G2L["dd"]["BorderSizePixel"] = 3;
G2L["dd"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["dd"]["TextSize"] = 14;
G2L["dd"]["TextScaled"] = true;
G2L["dd"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["dd"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["dd"]["Size"] = UDim2.new(0, 160, 0, 50);
G2L["dd"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["dd"]["Text"] = [[Raining Sparkles]];
G2L["dd"]["Position"] = UDim2.new(-0.525, 0, 2.54, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["de"] = Instance.new("Script", G2L["dd"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["df"] = Instance.new("LocalScript", G2L["dd"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["e0"] = Instance.new("RemoteEvent", G2L["dd"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["e1"] = Instance.new("TextButton", G2L["ca"]);
G2L["e1"]["TextWrapped"] = true;
G2L["e1"]["BorderSizePixel"] = 3;
G2L["e1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e1"]["TextSize"] = 14;
G2L["e1"]["TextScaled"] = true;
G2L["e1"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["e1"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["e1"]["Size"] = UDim2.new(0, 160, 0, 50);
G2L["e1"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["e1"]["Text"] = [[RC7]];
G2L["e1"]["Position"] = UDim2.new(0.25741, 0, 2.54, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["e2"] = Instance.new("Script", G2L["e1"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["e3"] = Instance.new("LocalScript", G2L["e1"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["e4"] = Instance.new("RemoteEvent", G2L["e1"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["e5"] = Instance.new("TextButton", G2L["ca"]);
G2L["e5"]["TextWrapped"] = true;
G2L["e5"]["BorderSizePixel"] = 3;
G2L["e5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e5"]["TextSize"] = 14;
G2L["e5"]["TextScaled"] = true;
G2L["e5"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["e5"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["e5"]["Size"] = UDim2.new(0, 93, 0, 50);
G2L["e5"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["e5"]["Text"] = [[Raining Heads]];
G2L["e5"]["Position"] = UDim2.new(1.05444, 0, 2.54, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["e6"] = Instance.new("Script", G2L["e5"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["e7"] = Instance.new("TextButton", G2L["ca"]);
G2L["e7"]["TextWrapped"] = true;
G2L["e7"]["BorderSizePixel"] = 3;
G2L["e7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e7"]["TextSize"] = 14;
G2L["e7"]["TextScaled"] = true;
G2L["e7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["e7"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["e7"]["Size"] = UDim2.new(0, 160, 0, 50);
G2L["e7"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["e7"]["Text"] = [[trollface particles]];
G2L["e7"]["Position"] = UDim2.new(-0.525, 0, 3.92, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["e8"] = Instance.new("Script", G2L["e7"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["e9"] = Instance.new("LocalScript", G2L["e7"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["ea"] = Instance.new("RemoteEvent", G2L["e7"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["eb"] = Instance.new("Script", G2L["e7"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["ec"] = Instance.new("TextButton", G2L["ca"]);
G2L["ec"]["TextWrapped"] = true;
G2L["ec"]["BorderSizePixel"] = 3;
G2L["ec"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["ec"]["TextSize"] = 14;
G2L["ec"]["TextScaled"] = true;
G2L["ec"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["ec"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["ec"]["Size"] = UDim2.new(0, 160, 0, 50);
G2L["ec"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["ec"]["Text"] = [[g**by gui]];
G2L["ec"]["Position"] = UDim2.new(0.25741, 0, 3.92, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["ed"] = Instance.new("Script", G2L["ec"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["ee"] = Instance.new("LocalScript", G2L["ec"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["ef"] = Instance.new("RemoteEvent", G2L["ec"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["f0"] = Instance.new("TextButton", G2L["ca"]);
G2L["f0"]["TextWrapped"] = true;
G2L["f0"]["BorderSizePixel"] = 3;
G2L["f0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["f0"]["TextSize"] = 14;
G2L["f0"]["TextScaled"] = true;
G2L["f0"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["f0"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["f0"]["Size"] = UDim2.new(0, 93, 0, 50);
G2L["f0"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["f0"]["Text"] = [[k00pz popups]];
G2L["f0"]["Position"] = UDim2.new(1.05444, 0, 3.92, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["f1"] = Instance.new("Script", G2L["f0"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["f2"] = Instance.new("TextButton", G2L["ca"]);
G2L["f2"]["TextWrapped"] = true;
G2L["f2"]["BorderSizePixel"] = 3;
G2L["f2"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["f2"]["TextSize"] = 14;
G2L["f2"]["TextScaled"] = true;
G2L["f2"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["f2"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["f2"]["Size"] = UDim2.new(0, 93, 0, 50);
G2L["f2"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["f2"]["Text"] = [[k00pz popups 2]];
G2L["f2"]["Position"] = UDim2.new(1.05444, 0, 5.16, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["f3"] = Instance.new("Script", G2L["f2"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["f4"] = Instance.new("TextButton", G2L["ca"]);
G2L["f4"]["TextWrapped"] = true;
G2L["f4"]["BorderSizePixel"] = 3;
G2L["f4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["f4"]["TextSize"] = 14;
G2L["f4"]["TextScaled"] = true;
G2L["f4"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["f4"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["f4"]["Size"] = UDim2.new(0, 160, 0, 50);
G2L["f4"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["f4"]["Text"] = [[anononymous particles]];
G2L["f4"]["Position"] = UDim2.new(-0.525, 0, 5.16, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["f5"] = Instance.new("Script", G2L["f4"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["f6"] = Instance.new("LocalScript", G2L["f4"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["f7"] = Instance.new("RemoteEvent", G2L["f4"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["f8"] = Instance.new("Script", G2L["f4"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["f9"] = Instance.new("TextButton", G2L["ca"]);
G2L["f9"]["TextWrapped"] = true;
G2L["f9"]["BorderSizePixel"] = 3;
G2L["f9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["f9"]["TextSize"] = 14;
G2L["f9"]["TextScaled"] = true;
G2L["f9"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["f9"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["f9"]["Size"] = UDim2.new(0, 160, 0, 50);
G2L["f9"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["f9"]["Text"] = [[Ad Popups]];
G2L["f9"]["Position"] = UDim2.new(0.25741, 0, 5.16, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["fa"] = Instance.new("Script", G2L["f9"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["fb"] = Instance.new("LocalScript", G2L["f9"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["fc"] = Instance.new("RemoteEvent", G2L["f9"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["fd"] = Instance.new("TextButton", G2L["ca"]);
G2L["fd"]["TextWrapped"] = true;
G2L["fd"]["BorderSizePixel"] = 4;
G2L["fd"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["fd"]["TextSize"] = 14;
G2L["fd"]["TextScaled"] = true;
G2L["fd"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["fd"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["fd"]["Size"] = UDim2.new(0, 160, 0, 50);
G2L["fd"]["BorderColor3"] = Color3.fromRGB(255, 0, 0);
G2L["fd"]["Text"] = [[Remove Ad Popups]];
G2L["fd"]["Position"] = UDim2.new(0.25741, 0, 6.4, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["fe"] = Instance.new("Script", G2L["fd"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["ff"] = Instance.new("LocalScript", G2L["fd"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["100"] = Instance.new("RemoteEvent", G2L["fd"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["101"] = Instance.new("TextButton", G2L["ca"]);
G2L["101"]["TextWrapped"] = true;
G2L["101"]["BorderSizePixel"] = 3;
G2L["101"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["101"]["TextSize"] = 14;
G2L["101"]["TextScaled"] = true;
G2L["101"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["101"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["101"]["Size"] = UDim2.new(0, 160, 0, 50);
G2L["101"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["101"]["Text"] = [[team f*t jumpscare scary]];
G2L["101"]["Position"] = UDim2.new(-0.525, 0, 6.4, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["102"] = Instance.new("Script", G2L["101"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["103"] = Instance.new("LocalScript", G2L["101"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["104"] = Instance.new("RemoteEvent", G2L["101"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["105"] = Instance.new("Script", G2L["101"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["106"] = Instance.new("TextButton", G2L["ca"]);
G2L["106"]["TextWrapped"] = true;
G2L["106"]["BorderSizePixel"] = 3;
G2L["106"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["106"]["TextSize"] = 14;
G2L["106"]["TextScaled"] = true;
G2L["106"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["106"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["106"]["Size"] = UDim2.new(0, 93, 0, 50);
G2L["106"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["106"]["Text"] = [[Macedonia Spam]];
G2L["106"]["Position"] = UDim2.new(1.05444, 0, 6.4, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["107"] = Instance.new("Script", G2L["106"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["108"] = Instance.new("TextButton", G2L["ca"]);
G2L["108"]["TextWrapped"] = true;
G2L["108"]["BorderSizePixel"] = 3;
G2L["108"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["108"]["TextSize"] = 14;
G2L["108"]["TextScaled"] = true;
G2L["108"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["108"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["108"]["Size"] = UDim2.new(0, 160, 0, 50);
G2L["108"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["108"]["Text"] = [[Pink Guns]];
G2L["108"]["Position"] = UDim2.new(0.74352, 0, 7.74, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["109"] = Instance.new("Script", G2L["108"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.LoadLibrary
G2L["10a"] = Instance.new("Folder", G2L["109"]);
G2L["10a"]["Name"] = [[LoadLibrary]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.LoadLibrary.RbxGui
G2L["10b"] = Instance.new("ModuleScript", G2L["10a"]);
G2L["10b"]["Name"] = [[RbxGui]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.LoadLibrary.RbxStamper
G2L["10c"] = Instance.new("ModuleScript", G2L["10a"]);
G2L["10c"]["Name"] = [[RbxStamper]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.LoadLibrary.RbxUtility
G2L["10d"] = Instance.new("ModuleScript", G2L["10a"]);
G2L["10d"]["Name"] = [[RbxUtility]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse
G2L["10e"] = Instance.new("LocalScript", G2L["109"]);
G2L["10e"]["Enabled"] = false;
G2L["10e"]["Name"] = [[Mouse]];
G2L["10e"]["Disabled"] = true;


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.KeyDown
G2L["10f"] = Instance.new("RemoteEvent", G2L["10e"]);
G2L["10f"]["Name"] = [[KeyDown]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.Target
G2L["110"] = Instance.new("ObjectValue", G2L["10e"]);
G2L["110"]["Name"] = [[Target]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.Hit
G2L["111"] = Instance.new("CFrameValue", G2L["10e"]);
G2L["111"]["Name"] = [[Hit]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.Button1Down
G2L["112"] = Instance.new("RemoteEvent", G2L["10e"]);
G2L["112"]["Name"] = [[Button1Down]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.UpdateProps
G2L["113"] = Instance.new("Script", G2L["10e"]);
G2L["113"]["Name"] = [[UpdateProps]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.updTarget
G2L["114"] = Instance.new("RemoteEvent", G2L["10e"]);
G2L["114"]["Name"] = [[updTarget]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.updHit
G2L["115"] = Instance.new("RemoteEvent", G2L["10e"]);
G2L["115"]["Name"] = [[updHit]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.X
G2L["116"] = Instance.new("NumberValue", G2L["10e"]);
G2L["116"]["Name"] = [[X]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.Y
G2L["117"] = Instance.new("NumberValue", G2L["10e"]);
G2L["117"]["Name"] = [[Y]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.updX
G2L["118"] = Instance.new("RemoteEvent", G2L["10e"]);
G2L["118"]["Name"] = [[updX]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.updY
G2L["119"] = Instance.new("RemoteEvent", G2L["10e"]);
G2L["119"]["Name"] = [[updY]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.KeyUp
G2L["11a"] = Instance.new("RemoteEvent", G2L["10e"]);
G2L["11a"]["Name"] = [[KeyUp]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.Button1Up
G2L["11b"] = Instance.new("RemoteEvent", G2L["10e"]);
G2L["11b"]["Name"] = [[Button1Up]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.Move
G2L["11c"] = Instance.new("RemoteEvent", G2L["10e"]);
G2L["11c"]["Name"] = [[Move]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.TargetFilter
G2L["11d"] = Instance.new("ObjectValue", G2L["10e"]);
G2L["11d"]["Name"] = [[TargetFilter]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.AIS
G2L["11e"] = Instance.new("RemoteEvent", G2L["10e"]);
G2L["11e"]["Name"] = [[AIS]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton
G2L["11f"] = Instance.new("TextButton", G2L["ca"]);
G2L["11f"]["TextWrapped"] = true;
G2L["11f"]["BorderSizePixel"] = 3;
G2L["11f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["11f"]["TextSize"] = 14;
G2L["11f"]["TextScaled"] = true;
G2L["11f"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["11f"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["11f"]["Size"] = UDim2.new(0, 160, 0, 50);
G2L["11f"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["11f"]["Text"] = [[boykissa jumpscere(el scary alerto!1!)]];
G2L["11f"]["Position"] = UDim2.new(0.74352, 0, 9.04, 0);


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script
G2L["120"] = Instance.new("Script", G2L["11f"]);



-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.LoadLibrary
G2L["121"] = Instance.new("Folder", G2L["120"]);
G2L["121"]["Name"] = [[LoadLibrary]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.LoadLibrary.RbxGui
G2L["122"] = Instance.new("ModuleScript", G2L["121"]);
G2L["122"]["Name"] = [[RbxGui]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.LoadLibrary.RbxStamper
G2L["123"] = Instance.new("ModuleScript", G2L["121"]);
G2L["123"]["Name"] = [[RbxStamper]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.LoadLibrary.RbxUtility
G2L["124"] = Instance.new("ModuleScript", G2L["121"]);
G2L["124"]["Name"] = [[RbxUtility]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse
G2L["125"] = Instance.new("LocalScript", G2L["120"]);
G2L["125"]["Enabled"] = false;
G2L["125"]["Name"] = [[Mouse]];
G2L["125"]["Disabled"] = true;


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.KeyDown
G2L["126"] = Instance.new("RemoteEvent", G2L["125"]);
G2L["126"]["Name"] = [[KeyDown]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.Target
G2L["127"] = Instance.new("ObjectValue", G2L["125"]);
G2L["127"]["Name"] = [[Target]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.Hit
G2L["128"] = Instance.new("CFrameValue", G2L["125"]);
G2L["128"]["Name"] = [[Hit]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.Button1Down
G2L["129"] = Instance.new("RemoteEvent", G2L["125"]);
G2L["129"]["Name"] = [[Button1Down]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.UpdateProps
G2L["12a"] = Instance.new("Script", G2L["125"]);
G2L["12a"]["Name"] = [[UpdateProps]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.updTarget
G2L["12b"] = Instance.new("RemoteEvent", G2L["125"]);
G2L["12b"]["Name"] = [[updTarget]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.updHit
G2L["12c"] = Instance.new("RemoteEvent", G2L["125"]);
G2L["12c"]["Name"] = [[updHit]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.X
G2L["12d"] = Instance.new("NumberValue", G2L["125"]);
G2L["12d"]["Name"] = [[X]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.Y
G2L["12e"] = Instance.new("NumberValue", G2L["125"]);
G2L["12e"]["Name"] = [[Y]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.updX
G2L["12f"] = Instance.new("RemoteEvent", G2L["125"]);
G2L["12f"]["Name"] = [[updX]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.updY
G2L["130"] = Instance.new("RemoteEvent", G2L["125"]);
G2L["130"]["Name"] = [[updY]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.KeyUp
G2L["131"] = Instance.new("RemoteEvent", G2L["125"]);
G2L["131"]["Name"] = [[KeyUp]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.Button1Up
G2L["132"] = Instance.new("RemoteEvent", G2L["125"]);
G2L["132"]["Name"] = [[Button1Up]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.Move
G2L["133"] = Instance.new("RemoteEvent", G2L["125"]);
G2L["133"]["Name"] = [[Move]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.TargetFilter
G2L["134"] = Instance.new("ObjectValue", G2L["125"]);
G2L["134"]["Name"] = [[TargetFilter]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.Script.Mouse.AIS
G2L["135"] = Instance.new("RemoteEvent", G2L["125"]);
G2L["135"]["Name"] = [[AIS]];


-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.ImageLabel
G2L["136"] = Instance.new("ImageLabel", G2L["c9"]);
G2L["136"]["BorderSizePixel"] = 0;
G2L["136"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["136"]["Image"] = [[rbxassetid://9018233362]];
G2L["136"]["Size"] = UDim2.new(0, 264, 0, 249);
G2L["136"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["136"]["Position"] = UDim2.new(0.01101, 0, 0.51675, 0);


-- StarterGui.ScreenGui.cool.Page7.Smooth GUI Dragging
G2L["137"] = Instance.new("LocalScript", G2L["c8"]);
G2L["137"]["Name"] = [[Smooth GUI Dragging]];


-- StarterGui.ScreenGui.cool.Page7.TextButton
G2L["138"] = Instance.new("TextButton", G2L["c8"]);
G2L["138"]["TextWrapped"] = true;
G2L["138"]["BorderSizePixel"] = 3;
G2L["138"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["138"]["TextSize"] = 14;
G2L["138"]["TextScaled"] = true;
G2L["138"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["138"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["138"]["Size"] = UDim2.new(0, 125, 0, 50);
G2L["138"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["138"]["Text"] = [[Page 1]];
G2L["138"]["Position"] = UDim2.new(0.01288, 0, -0.13661, 0);


-- StarterGui.ScreenGui.cool.Page7.TextButton.LocalScript
G2L["139"] = Instance.new("LocalScript", G2L["138"]);



-- StarterGui.ScreenGui.cool.Page7.TextButton
G2L["13a"] = Instance.new("TextButton", G2L["c8"]);
G2L["13a"]["TextWrapped"] = true;
G2L["13a"]["BorderSizePixel"] = 3;
G2L["13a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["13a"]["TextSize"] = 14;
G2L["13a"]["TextScaled"] = true;
G2L["13a"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["13a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["13a"]["Size"] = UDim2.new(0, 125, 0, 50);
G2L["13a"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["13a"]["Text"] = [[Page 2]];
G2L["13a"]["Position"] = UDim2.new(0.31545, 0, -0.14208, 0);


-- StarterGui.ScreenGui.cool.Page7.TextButton.LocalScript
G2L["13b"] = Instance.new("LocalScript", G2L["13a"]);



-- StarterGui.ScreenGui.cool.Page7.TextButton
G2L["13c"] = Instance.new("TextButton", G2L["c8"]);
G2L["13c"]["TextWrapped"] = true;
G2L["13c"]["BorderSizePixel"] = 3;
G2L["13c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["13c"]["TextSize"] = 14;
G2L["13c"]["TextScaled"] = true;
G2L["13c"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["13c"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["13c"]["Size"] = UDim2.new(0, 125, 0, 50);
G2L["13c"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["13c"]["Text"] = [[Page 3]];
G2L["13c"]["Position"] = UDim2.new(0.62017, 0, -0.14208, 0);


-- StarterGui.ScreenGui.cool.Page7.TextButton.LocalScript
G2L["13d"] = Instance.new("LocalScript", G2L["13c"]);



-- StarterGui.ScreenGui.cool.Page7.TextButton
G2L["13e"] = Instance.new("TextButton", G2L["c8"]);
G2L["13e"]["TextWrapped"] = true;
G2L["13e"]["BorderSizePixel"] = 3;
G2L["13e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["13e"]["TextSize"] = 14;
G2L["13e"]["TextScaled"] = true;
G2L["13e"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["13e"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["13e"]["Size"] = UDim2.new(0, 125, 0, 50);
G2L["13e"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["13e"]["Text"] = [[Page 4]];
G2L["13e"]["Position"] = UDim2.new(0.01288, 0, -0.29781, 0);


-- StarterGui.ScreenGui.cool.Page7.TextButton.LocalScript
G2L["13f"] = Instance.new("LocalScript", G2L["13e"]);



-- StarterGui.ScreenGui.cool.Page7.TextButton
G2L["140"] = Instance.new("TextButton", G2L["c8"]);
G2L["140"]["TextWrapped"] = true;
G2L["140"]["BorderSizePixel"] = 3;
G2L["140"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["140"]["TextSize"] = 14;
G2L["140"]["TextScaled"] = true;
G2L["140"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["140"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["140"]["Size"] = UDim2.new(0, 125, 0, 50);
G2L["140"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["140"]["Text"] = [[Page 5]];
G2L["140"]["Position"] = UDim2.new(0.32403, 0, -0.29781, 0);


-- StarterGui.ScreenGui.cool.Page7.TextButton.LocalScript
G2L["141"] = Instance.new("LocalScript", G2L["140"]);



-- StarterGui.ScreenGui.cool.Page7.TextButton
G2L["142"] = Instance.new("TextButton", G2L["c8"]);
G2L["142"]["TextWrapped"] = true;
G2L["142"]["BorderSizePixel"] = 3;
G2L["142"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["142"]["TextSize"] = 14;
G2L["142"]["TextScaled"] = true;
G2L["142"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["142"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["142"]["Size"] = UDim2.new(0, 125, 0, 50);
G2L["142"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["142"]["Text"] = [[Page 6]];
G2L["142"]["Position"] = UDim2.new(0.62017, 0, -0.29781, 0);


-- StarterGui.ScreenGui.cool.Page7.TextButton.LocalScript
G2L["143"] = Instance.new("LocalScript", G2L["142"]);



-- StarterGui.ScreenGui.cool.Page7.TextButton
G2L["144"] = Instance.new("TextButton", G2L["c8"]);
G2L["144"]["TextWrapped"] = true;
G2L["144"]["BorderSizePixel"] = 3;
G2L["144"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["144"]["TextSize"] = 14;
G2L["144"]["TextScaled"] = true;
G2L["144"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["144"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["144"]["Size"] = UDim2.new(0, 125, 0, 50);
G2L["144"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["144"]["Text"] = [[Page 8]];
G2L["144"]["Position"] = UDim2.new(0.32403, 0, -0.45902, 0);


-- StarterGui.ScreenGui.cool.Page7.TextButton.LocalScript
G2L["145"] = Instance.new("LocalScript", G2L["144"]);



-- StarterGui.ScreenGui.cool.Page6
G2L["146"] = Instance.new("Frame", G2L["2"]);
G2L["146"]["Visible"] = false;
G2L["146"]["BorderSizePixel"] = 0;
G2L["146"]["BackgroundColor3"] = Color3.fromRGB(0, 86, 0);
G2L["146"]["Size"] = UDim2.new(0, 444, 0, 291);
G2L["146"]["Position"] = UDim2.new(6.59801, 0, 5.12287, 0);
G2L["146"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["146"]["Name"] = [[Page6]];


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame
G2L["147"] = Instance.new("ScrollingFrame", G2L["146"]);
G2L["147"]["Active"] = true;
G2L["147"]["BorderSizePixel"] = 0;
G2L["147"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["147"]["Size"] = UDim2.new(0, 432, 0, 273);
G2L["147"]["ScrollBarImageColor3"] = Color3.fromRGB(132, 132, 132);
G2L["147"]["Position"] = UDim2.new(0.01351, 0, 0.03093, 0);
G2L["147"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel
G2L["148"] = Instance.new("TextLabel", G2L["147"]);
G2L["148"]["TextWrapped"] = true;
G2L["148"]["BorderSizePixel"] = 3;
G2L["148"]["TextSize"] = 14;
G2L["148"]["TextScaled"] = true;
G2L["148"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["148"]["FontFace"] = Font.new([[rbxasset://fonts/families/FredokaOne.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["148"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["148"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["148"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["148"]["Text"] = [[k00pgui v4(OP) page 6]];
G2L["148"]["Position"] = UDim2.new(0.26852, 0, -0.0005, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["149"] = Instance.new("TextButton", G2L["148"]);
G2L["149"]["TextWrapped"] = true;
G2L["149"]["BorderSizePixel"] = 3;
G2L["149"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["149"]["TextSize"] = 14;
G2L["149"]["TextScaled"] = true;
G2L["149"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["149"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["149"]["Size"] = UDim2.new(0, 140, 0, 50);
G2L["149"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["149"]["Text"] = [[Spaghetti Hub]];
G2L["149"]["Position"] = UDim2.new(-0.55, 0, 1.2, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["14a"] = Instance.new("Script", G2L["149"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["14b"] = Instance.new("LocalScript", G2L["149"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["14c"] = Instance.new("RemoteEvent", G2L["149"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["14d"] = Instance.new("TextButton", G2L["148"]);
G2L["14d"]["TextWrapped"] = true;
G2L["14d"]["BorderSizePixel"] = 3;
G2L["14d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["14d"]["TextSize"] = 14;
G2L["14d"]["TextScaled"] = true;
G2L["14d"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["14d"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["14d"]["Size"] = UDim2.new(0, 140, 0, 50);
G2L["14d"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["14d"]["Text"] = [[Nuke Gui]];
G2L["14d"]["Position"] = UDim2.new(0.24, 0, 1.2, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["14e"] = Instance.new("Script", G2L["14d"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["14f"] = Instance.new("LocalScript", G2L["14d"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["150"] = Instance.new("RemoteEvent", G2L["14d"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["151"] = Instance.new("TextButton", G2L["148"]);
G2L["151"]["TextWrapped"] = true;
G2L["151"]["BorderSizePixel"] = 3;
G2L["151"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["151"]["TextSize"] = 14;
G2L["151"]["TextScaled"] = true;
G2L["151"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["151"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["151"]["Size"] = UDim2.new(0, 96, 0, 50);
G2L["151"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["151"]["Text"] = [[c00lgui reborn]];
G2L["151"]["Position"] = UDim2.new(1.02, 0, 1.18264, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["152"] = Instance.new("Script", G2L["151"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["153"] = Instance.new("LocalScript", G2L["151"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["154"] = Instance.new("RemoteEvent", G2L["151"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["155"] = Instance.new("TextButton", G2L["148"]);
G2L["155"]["TextWrapped"] = true;
G2L["155"]["BorderSizePixel"] = 3;
G2L["155"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["155"]["TextSize"] = 14;
G2L["155"]["TextScaled"] = true;
G2L["155"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["155"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["155"]["Size"] = UDim2.new(0, 140, 0, 50);
G2L["155"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["155"]["Text"] = [[Fake Tubers GUI]];
G2L["155"]["Position"] = UDim2.new(-0.55, 0, 2.5, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["156"] = Instance.new("Script", G2L["155"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["157"] = Instance.new("LocalScript", G2L["155"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["158"] = Instance.new("RemoteEvent", G2L["155"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["159"] = Instance.new("TextButton", G2L["148"]);
G2L["159"]["TextWrapped"] = true;
G2L["159"]["BorderSizePixel"] = 3;
G2L["159"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["159"]["TextSize"] = 14;
G2L["159"]["TextScaled"] = true;
G2L["159"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["159"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["159"]["Size"] = UDim2.new(0, 140, 0, 50);
G2L["159"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["159"]["Text"] = [[tubers gui reborn]];
G2L["159"]["Position"] = UDim2.new(0.24, 0, 2.5, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["15a"] = Instance.new("Script", G2L["159"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["15b"] = Instance.new("LocalScript", G2L["159"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["15c"] = Instance.new("RemoteEvent", G2L["159"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["15d"] = Instance.new("TextButton", G2L["148"]);
G2L["15d"]["TextWrapped"] = true;
G2L["15d"]["BorderSizePixel"] = 3;
G2L["15d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["15d"]["TextSize"] = 14;
G2L["15d"]["TextScaled"] = true;
G2L["15d"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["15d"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["15d"]["Size"] = UDim2.new(0, 96, 0, 50);
G2L["15d"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["15d"]["Text"] = [[mr bean admin]];
G2L["15d"]["Position"] = UDim2.new(1.02, 0, 2.48264, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["15e"] = Instance.new("Script", G2L["15d"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["15f"] = Instance.new("LocalScript", G2L["15d"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["160"] = Instance.new("RemoteEvent", G2L["15d"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["161"] = Instance.new("TextButton", G2L["148"]);
G2L["161"]["TextWrapped"] = true;
G2L["161"]["BorderSizePixel"] = 3;
G2L["161"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["161"]["TextSize"] = 14;
G2L["161"]["TextScaled"] = true;
G2L["161"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["161"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["161"]["Size"] = UDim2.new(0, 140, 0, 50);
G2L["161"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["161"]["Text"] = [[Anime Hub V3]];
G2L["161"]["Position"] = UDim2.new(-0.55, 0, 3.8, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["162"] = Instance.new("Script", G2L["161"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["163"] = Instance.new("LocalScript", G2L["161"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["164"] = Instance.new("RemoteEvent", G2L["161"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["165"] = Instance.new("TextButton", G2L["148"]);
G2L["165"]["TextWrapped"] = true;
G2L["165"]["BorderSizePixel"] = 3;
G2L["165"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["165"]["TextSize"] = 14;
G2L["165"]["TextScaled"] = true;
G2L["165"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["165"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["165"]["Size"] = UDim2.new(0, 140, 0, 50);
G2L["165"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["165"]["Text"] = [[Neko Hub]];
G2L["165"]["Position"] = UDim2.new(0.255, 0, 3.82, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["166"] = Instance.new("Script", G2L["165"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["167"] = Instance.new("Script", G2L["165"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["168"] = Instance.new("LocalScript", G2L["165"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["169"] = Instance.new("RemoteEvent", G2L["165"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["16a"] = Instance.new("TextButton", G2L["148"]);
G2L["16a"]["TextWrapped"] = true;
G2L["16a"]["BorderSizePixel"] = 3;
G2L["16a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["16a"]["TextSize"] = 14;
G2L["16a"]["TextScaled"] = true;
G2L["16a"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["16a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["16a"]["Size"] = UDim2.new(0, 97, 0, 50);
G2L["16a"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["16a"]["Text"] = [[team fat gui by JO1TAR0[R.I.P script is beamed]]];
G2L["16a"]["Position"] = UDim2.new(1.015, 0, 3.8, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["16b"] = Instance.new("Script", G2L["16a"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["16c"] = Instance.new("Script", G2L["16a"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["16d"] = Instance.new("LocalScript", G2L["16a"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["16e"] = Instance.new("RemoteEvent", G2L["16a"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["16f"] = Instance.new("TextButton", G2L["148"]);
G2L["16f"]["TextWrapped"] = true;
G2L["16f"]["BorderSizePixel"] = 3;
G2L["16f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["16f"]["TextSize"] = 14;
G2L["16f"]["TextScaled"] = true;
G2L["16f"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["16f"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["16f"]["Size"] = UDim2.new(0, 140, 0, 50);
G2L["16f"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["16f"]["Text"] = [[Grab Knife V2[R6]]];
G2L["16f"]["Position"] = UDim2.new(-0.55, 0, 5.04, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["170"] = Instance.new("Script", G2L["16f"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["171"] = Instance.new("LocalScript", G2L["16f"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["172"] = Instance.new("RemoteEvent", G2L["16f"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["173"] = Instance.new("TextButton", G2L["148"]);
G2L["173"]["TextWrapped"] = true;
G2L["173"]["BorderSizePixel"] = 3;
G2L["173"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["173"]["TextSize"] = 14;
G2L["173"]["TextScaled"] = true;
G2L["173"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["173"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["173"]["Size"] = UDim2.new(0, 140, 0, 50);
G2L["173"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["173"]["Text"] = [[Grab Knife V3 [R6]]];
G2L["173"]["Position"] = UDim2.new(0.24, 0, 5.04, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["174"] = Instance.new("Script", G2L["173"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["175"] = Instance.new("LocalScript", G2L["173"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["176"] = Instance.new("RemoteEvent", G2L["173"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["177"] = Instance.new("TextButton", G2L["148"]);
G2L["177"]["TextWrapped"] = true;
G2L["177"]["BorderSizePixel"] = 3;
G2L["177"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["177"]["TextSize"] = 14;
G2L["177"]["TextScaled"] = true;
G2L["177"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["177"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["177"]["Size"] = UDim2.new(0, 96, 0, 26);
G2L["177"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["177"]["Text"] = [[R6]];
G2L["177"]["Position"] = UDim2.new(-0.56, 0, 0.00264, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["178"] = Instance.new("Script", G2L["177"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["179"] = Instance.new("LocalScript", G2L["177"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["17a"] = Instance.new("RemoteEvent", G2L["177"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["17b"] = Instance.new("TextButton", G2L["148"]);
G2L["17b"]["TextWrapped"] = true;
G2L["17b"]["BorderSizePixel"] = 3;
G2L["17b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["17b"]["TextSize"] = 14;
G2L["17b"]["TextScaled"] = true;
G2L["17b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["17b"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["17b"]["Size"] = UDim2.new(0, 97, 0, 50);
G2L["17b"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["17b"]["Text"] = [[Grab Knife V4 Trial [R6]]];
G2L["17b"]["Position"] = UDim2.new(1.02, 0, 5.04, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["17c"] = Instance.new("Script", G2L["17b"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["17d"] = Instance.new("Script", G2L["17b"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["17e"] = Instance.new("LocalScript", G2L["17b"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["17f"] = Instance.new("RemoteEvent", G2L["17b"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["180"] = Instance.new("TextButton", G2L["148"]);
G2L["180"]["TextWrapped"] = true;
G2L["180"]["BorderSizePixel"] = 3;
G2L["180"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["180"]["TextSize"] = 14;
G2L["180"]["TextScaled"] = true;
G2L["180"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["180"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["180"]["Size"] = UDim2.new(0, 142, 0, 50);
G2L["180"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["180"]["Text"] = [[Grab Knife V4 Premium [R6]]];
G2L["180"]["Position"] = UDim2.new(-0.56, 0, 6.28, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["181"] = Instance.new("Script", G2L["180"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["182"] = Instance.new("Script", G2L["180"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["183"] = Instance.new("LocalScript", G2L["180"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["184"] = Instance.new("RemoteEvent", G2L["180"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["185"] = Instance.new("TextButton", G2L["148"]);
G2L["185"]["TextWrapped"] = true;
G2L["185"]["BorderSizePixel"] = 3;
G2L["185"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["185"]["TextSize"] = 14;
G2L["185"]["TextScaled"] = true;
G2L["185"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["185"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["185"]["Size"] = UDim2.new(0, 142, 0, 50);
G2L["185"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["185"]["Text"] = [[team fat gui v14]];
G2L["185"]["Position"] = UDim2.new(0.235, 0, 6.28, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["186"] = Instance.new("Script", G2L["185"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["187"] = Instance.new("Script", G2L["185"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["188"] = Instance.new("LocalScript", G2L["185"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["189"] = Instance.new("RemoteEvent", G2L["185"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["18a"] = Instance.new("TextButton", G2L["148"]);
G2L["18a"]["TextWrapped"] = true;
G2L["18a"]["BorderSizePixel"] = 3;
G2L["18a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["18a"]["TextSize"] = 14;
G2L["18a"]["TextScaled"] = true;
G2L["18a"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["18a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["18a"]["Size"] = UDim2.new(0, 97, 0, 50);
G2L["18a"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["18a"]["Text"] = [[kali gui]];
G2L["18a"]["Position"] = UDim2.new(1.01, 0, 6.28, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["18b"] = Instance.new("Script", G2L["18a"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["18c"] = Instance.new("Script", G2L["18a"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["18d"] = Instance.new("LocalScript", G2L["18a"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["18e"] = Instance.new("RemoteEvent", G2L["18a"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["18f"] = Instance.new("TextButton", G2L["148"]);
G2L["18f"]["TextWrapped"] = true;
G2L["18f"]["BorderSizePixel"] = 3;
G2L["18f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["18f"]["TextSize"] = 14;
G2L["18f"]["TextScaled"] = true;
G2L["18f"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["18f"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["18f"]["Size"] = UDim2.new(0, 142, 0, 50);
G2L["18f"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["18f"]["Text"] = [[ro-xploit v7]];
G2L["18f"]["Position"] = UDim2.new(-0.55, 0, 7.54, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["190"] = Instance.new("Script", G2L["18f"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["191"] = Instance.new("Script", G2L["18f"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["192"] = Instance.new("LocalScript", G2L["18f"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["193"] = Instance.new("RemoteEvent", G2L["18f"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["194"] = Instance.new("TextButton", G2L["148"]);
G2L["194"]["TextWrapped"] = true;
G2L["194"]["BorderSizePixel"] = 3;
G2L["194"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["194"]["TextSize"] = 14;
G2L["194"]["TextScaled"] = true;
G2L["194"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["194"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["194"]["Size"] = UDim2.new(0, 142, 0, 50);
G2L["194"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["194"]["Text"] = [[Doge Army]];
G2L["194"]["Position"] = UDim2.new(0.24, 0, 7.54, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["195"] = Instance.new("Script", G2L["194"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["196"] = Instance.new("Script", G2L["194"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["197"] = Instance.new("LocalScript", G2L["194"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["198"] = Instance.new("RemoteEvent", G2L["194"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["199"] = Instance.new("TextButton", G2L["148"]);
G2L["199"]["TextWrapped"] = true;
G2L["199"]["BorderSizePixel"] = 3;
G2L["199"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["199"]["TextSize"] = 14;
G2L["199"]["TextScaled"] = true;
G2L["199"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["199"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["199"]["Size"] = UDim2.new(0, 97, 0, 50);
G2L["199"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["199"]["Text"] = [[Opgui v1.5]];
G2L["199"]["Position"] = UDim2.new(1, 0, 7.54, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["19a"] = Instance.new("Script", G2L["199"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["19b"] = Instance.new("Script", G2L["199"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["19c"] = Instance.new("LocalScript", G2L["199"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["19d"] = Instance.new("RemoteEvent", G2L["199"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["19e"] = Instance.new("TextButton", G2L["148"]);
G2L["19e"]["TextWrapped"] = true;
G2L["19e"]["BorderSizePixel"] = 3;
G2L["19e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["19e"]["TextSize"] = 14;
G2L["19e"]["TextScaled"] = true;
G2L["19e"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["19e"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["19e"]["Size"] = UDim2.new(0, 142, 0, 50);
G2L["19e"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["19e"]["Text"] = [[l33gui]];
G2L["19e"]["Position"] = UDim2.new(-0.55, 0, 8.9, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["19f"] = Instance.new("Script", G2L["19e"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["1a0"] = Instance.new("Script", G2L["19e"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["1a1"] = Instance.new("LocalScript", G2L["19e"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["1a2"] = Instance.new("RemoteEvent", G2L["19e"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["1a3"] = Instance.new("TextButton", G2L["148"]);
G2L["1a3"]["TextWrapped"] = true;
G2L["1a3"]["BorderSizePixel"] = 3;
G2L["1a3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1a3"]["TextSize"] = 14;
G2L["1a3"]["TextScaled"] = true;
G2L["1a3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1a3"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1a3"]["Size"] = UDim2.new(0, 142, 0, 50);
G2L["1a3"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1a3"]["Text"] = [[teamfat gui v17]];
G2L["1a3"]["Position"] = UDim2.new(0.25, 0, 8.9, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["1a4"] = Instance.new("Script", G2L["1a3"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["1a5"] = Instance.new("Script", G2L["1a3"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["1a6"] = Instance.new("LocalScript", G2L["1a3"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["1a7"] = Instance.new("RemoteEvent", G2L["1a3"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["1a8"] = Instance.new("TextButton", G2L["148"]);
G2L["1a8"]["TextWrapped"] = true;
G2L["1a8"]["BorderSizePixel"] = 3;
G2L["1a8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1a8"]["TextSize"] = 14;
G2L["1a8"]["TextScaled"] = true;
G2L["1a8"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1a8"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1a8"]["Size"] = UDim2.new(0, 97, 0, 50);
G2L["1a8"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1a8"]["Text"] = [[k00pgui v7]];
G2L["1a8"]["Position"] = UDim2.new(1.01, 0, 8.88, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["1a9"] = Instance.new("Script", G2L["1a8"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["1aa"] = Instance.new("Script", G2L["1a8"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["1ab"] = Instance.new("LocalScript", G2L["1a8"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["1ac"] = Instance.new("RemoteEvent", G2L["1a8"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["1ad"] = Instance.new("TextButton", G2L["148"]);
G2L["1ad"]["TextWrapped"] = true;
G2L["1ad"]["BorderSizePixel"] = 3;
G2L["1ad"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1ad"]["TextSize"] = 14;
G2L["1ad"]["TextScaled"] = true;
G2L["1ad"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1ad"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1ad"]["Size"] = UDim2.new(0, 142, 0, 50);
G2L["1ad"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1ad"]["Text"] = [[k00pgui v6]];
G2L["1ad"]["Position"] = UDim2.new(-0.55, 0, 10.18, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["1ae"] = Instance.new("Script", G2L["1ad"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["1af"] = Instance.new("Script", G2L["1ad"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["1b0"] = Instance.new("LocalScript", G2L["1ad"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["1b1"] = Instance.new("RemoteEvent", G2L["1ad"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["1b2"] = Instance.new("TextButton", G2L["148"]);
G2L["1b2"]["TextWrapped"] = true;
G2L["1b2"]["BorderSizePixel"] = 3;
G2L["1b2"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1b2"]["TextSize"] = 14;
G2L["1b2"]["TextScaled"] = true;
G2L["1b2"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1b2"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1b2"]["Size"] = UDim2.new(0, 142, 0, 50);
G2L["1b2"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1b2"]["Text"] = [[br4dgui pocket edition]];
G2L["1b2"]["Position"] = UDim2.new(0.255, 0, 10.18, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["1b3"] = Instance.new("Script", G2L["1b2"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["1b4"] = Instance.new("Script", G2L["1b2"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["1b5"] = Instance.new("LocalScript", G2L["1b2"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["1b6"] = Instance.new("RemoteEvent", G2L["1b2"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton
G2L["1b7"] = Instance.new("TextButton", G2L["148"]);
G2L["1b7"]["TextWrapped"] = true;
G2L["1b7"]["BorderSizePixel"] = 3;
G2L["1b7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1b7"]["TextSize"] = 14;
G2L["1b7"]["TextScaled"] = true;
G2L["1b7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1b7"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1b7"]["Size"] = UDim2.new(0, 97, 0, 50);
G2L["1b7"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1b7"]["Text"] = [[k00pgui ultimate private edition]];
G2L["1b7"]["Position"] = UDim2.new(1.01, 0, 10.16, 0);


-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["1b8"] = Instance.new("Script", G2L["1b7"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.Script
G2L["1b9"] = Instance.new("Script", G2L["1b7"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["1ba"] = Instance.new("LocalScript", G2L["1b7"]);



-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["1bb"] = Instance.new("RemoteEvent", G2L["1b7"]);



-- StarterGui.ScreenGui.cool.Page6.Smooth GUI Dragging
G2L["1bc"] = Instance.new("LocalScript", G2L["146"]);
G2L["1bc"]["Name"] = [[Smooth GUI Dragging]];


-- StarterGui.ScreenGui.cool.Page6.TextButton
G2L["1bd"] = Instance.new("TextButton", G2L["146"]);
G2L["1bd"]["TextWrapped"] = true;
G2L["1bd"]["BorderSizePixel"] = 3;
G2L["1bd"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1bd"]["TextSize"] = 14;
G2L["1bd"]["TextScaled"] = true;
G2L["1bd"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1bd"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1bd"]["Size"] = UDim2.new(0, 150, 0, 32);
G2L["1bd"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1bd"]["Text"] = [[Page 1]];
G2L["1bd"]["Position"] = UDim2.new(0.00676, 0, -0.11063, 0);


-- StarterGui.ScreenGui.cool.Page6.TextButton.LocalScript
G2L["1be"] = Instance.new("LocalScript", G2L["1bd"]);



-- StarterGui.ScreenGui.cool.Page6.TextButton
G2L["1bf"] = Instance.new("TextButton", G2L["146"]);
G2L["1bf"]["TextWrapped"] = true;
G2L["1bf"]["BorderSizePixel"] = 3;
G2L["1bf"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1bf"]["TextSize"] = 14;
G2L["1bf"]["TextScaled"] = true;
G2L["1bf"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1bf"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1bf"]["Size"] = UDim2.new(0, 150, 0, 32);
G2L["1bf"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1bf"]["Text"] = [[Page 2]];
G2L["1bf"]["Position"] = UDim2.new(0.37162, 0, -0.11063, 0);


-- StarterGui.ScreenGui.cool.Page6.TextButton.LocalScript
G2L["1c0"] = Instance.new("LocalScript", G2L["1bf"]);



-- StarterGui.ScreenGui.cool.Page6.TextButton
G2L["1c1"] = Instance.new("TextButton", G2L["146"]);
G2L["1c1"]["TextWrapped"] = true;
G2L["1c1"]["BorderSizePixel"] = 3;
G2L["1c1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1c1"]["TextSize"] = 14;
G2L["1c1"]["TextScaled"] = true;
G2L["1c1"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1c1"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1c1"]["Size"] = UDim2.new(0, 150, 0, 32);
G2L["1c1"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1c1"]["Text"] = [[Page 2]];
G2L["1c1"]["Position"] = UDim2.new(0.37162, 0, -0.11063, 0);


-- StarterGui.ScreenGui.cool.Page6.TextButton.LocalScript
G2L["1c2"] = Instance.new("LocalScript", G2L["1c1"]);



-- StarterGui.ScreenGui.cool.Page6.TextButton
G2L["1c3"] = Instance.new("TextButton", G2L["146"]);
G2L["1c3"]["TextWrapped"] = true;
G2L["1c3"]["BorderSizePixel"] = 3;
G2L["1c3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1c3"]["TextSize"] = 14;
G2L["1c3"]["TextScaled"] = true;
G2L["1c3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1c3"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1c3"]["Size"] = UDim2.new(0, 116, 0, 32);
G2L["1c3"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1c3"]["Text"] = [[Page 3]];
G2L["1c3"]["Position"] = UDim2.new(0.73874, 0, -0.11063, 0);


-- StarterGui.ScreenGui.cool.Page6.TextButton.LocalScript
G2L["1c4"] = Instance.new("LocalScript", G2L["1c3"]);



-- StarterGui.ScreenGui.cool.Page6.TextButton
G2L["1c5"] = Instance.new("TextButton", G2L["146"]);
G2L["1c5"]["TextWrapped"] = true;
G2L["1c5"]["BorderSizePixel"] = 3;
G2L["1c5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1c5"]["TextSize"] = 14;
G2L["1c5"]["TextScaled"] = true;
G2L["1c5"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1c5"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1c5"]["Size"] = UDim2.new(0, 150, 0, 32);
G2L["1c5"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1c5"]["Text"] = [[Page 4]];
G2L["1c5"]["Position"] = UDim2.new(0.01126, 0, -0.26183, 0);


-- StarterGui.ScreenGui.cool.Page6.TextButton.LocalScript
G2L["1c6"] = Instance.new("LocalScript", G2L["1c5"]);



-- StarterGui.ScreenGui.cool.Page6.TextButton
G2L["1c7"] = Instance.new("TextButton", G2L["146"]);
G2L["1c7"]["TextWrapped"] = true;
G2L["1c7"]["BorderSizePixel"] = 3;
G2L["1c7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1c7"]["TextSize"] = 14;
G2L["1c7"]["TextScaled"] = true;
G2L["1c7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1c7"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1c7"]["Size"] = UDim2.new(0, 150, 0, 32);
G2L["1c7"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1c7"]["Text"] = [[Page 5]];
G2L["1c7"]["Position"] = UDim2.new(0.36712, 0, -0.26183, 0);


-- StarterGui.ScreenGui.cool.Page6.TextButton.LocalScript
G2L["1c8"] = Instance.new("LocalScript", G2L["1c7"]);



-- StarterGui.ScreenGui.cool.Page6.TextButton
G2L["1c9"] = Instance.new("TextButton", G2L["146"]);
G2L["1c9"]["TextWrapped"] = true;
G2L["1c9"]["BorderSizePixel"] = 3;
G2L["1c9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1c9"]["TextSize"] = 14;
G2L["1c9"]["TextScaled"] = true;
G2L["1c9"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1c9"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1c9"]["Size"] = UDim2.new(0, 116, 0, 32);
G2L["1c9"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1c9"]["Text"] = [[Page 7]];
G2L["1c9"]["Position"] = UDim2.new(0.72523, 0, -0.26183, 0);


-- StarterGui.ScreenGui.cool.Page6.TextButton.LocalScript
G2L["1ca"] = Instance.new("LocalScript", G2L["1c9"]);



-- StarterGui.ScreenGui.cool.Page6.TextButton
G2L["1cb"] = Instance.new("TextButton", G2L["146"]);
G2L["1cb"]["TextWrapped"] = true;
G2L["1cb"]["BorderSizePixel"] = 3;
G2L["1cb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1cb"]["TextSize"] = 14;
G2L["1cb"]["TextScaled"] = true;
G2L["1cb"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1cb"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1cb"]["Size"] = UDim2.new(0, 150, 0, 32);
G2L["1cb"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1cb"]["Text"] = [[Page 8]];
G2L["1cb"]["Position"] = UDim2.new(0.36712, 0, -0.38554, 0);


-- StarterGui.ScreenGui.cool.Page6.TextButton.LocalScript
G2L["1cc"] = Instance.new("LocalScript", G2L["1cb"]);



-- StarterGui.ScreenGui.cool.Page2
G2L["1cd"] = Instance.new("Frame", G2L["2"]);
G2L["1cd"]["Visible"] = false;
G2L["1cd"]["Active"] = true;
G2L["1cd"]["BorderSizePixel"] = 7;
G2L["1cd"]["BackgroundColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1cd"]["Size"] = UDim2.new(0, 550, 0, 434);
G2L["1cd"]["Position"] = UDim2.new(5.48429, 0, 3.69709, 0);
G2L["1cd"]["BorderColor3"] = Color3.fromRGB(0, 255, 0);
G2L["1cd"]["Name"] = [[Page2]];


-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame
G2L["1ce"] = Instance.new("ScrollingFrame", G2L["1cd"]);
G2L["1ce"]["Active"] = true;
G2L["1ce"]["BorderSizePixel"] = 0;
G2L["1ce"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1ce"]["Size"] = UDim2.new(0, 528, 0, 417);
G2L["1ce"]["ScrollBarImageColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1ce"]["Position"] = UDim2.new(0.03306, 0, 0.03687, 0);
G2L["1ce"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.TextLabel
G2L["1cf"] = Instance.new("TextLabel", G2L["1ce"]);
G2L["1cf"]["TextWrapped"] = true;
G2L["1cf"]["BorderSizePixel"] = 3;
G2L["1cf"]["TextSize"] = 14;
G2L["1cf"]["TextScaled"] = true;
G2L["1cf"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1cf"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1cf"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1cf"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["1cf"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1cf"]["Text"] = [[k00pgui(OP) v4 Page 2]];
G2L["1cf"]["Position"] = UDim2.new(0.2591, 0, 0, 0);


-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.TextLabel.TextButton
G2L["1d0"] = Instance.new("TextButton", G2L["1cf"]);
G2L["1d0"]["TextWrapped"] = true;
G2L["1d0"]["BorderSizePixel"] = 3;
G2L["1d0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1d0"]["TextSize"] = 14;
G2L["1d0"]["TextScaled"] = true;
G2L["1d0"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1d0"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1d0"]["Size"] = UDim2.new(0, 343, 0, 50);
G2L["1d0"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1d0"]["Text"] = [[Canada Spam]];
G2L["1d0"]["Position"] = UDim2.new(-0.405, 0, 1.38, 0);


-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.TextLabel.TextButton.Script
G2L["1d1"] = Instance.new("Script", G2L["1d0"]);



-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.TextLabel.TextButton
G2L["1d2"] = Instance.new("TextButton", G2L["1cf"]);
G2L["1d2"]["TextWrapped"] = true;
G2L["1d2"]["BorderSizePixel"] = 3;
G2L["1d2"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1d2"]["TextSize"] = 14;
G2L["1d2"]["TextScaled"] = true;
G2L["1d2"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1d2"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1d2"]["Size"] = UDim2.new(0, 343, 0, 50);
G2L["1d2"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1d2"]["Text"] = [[Opkidd Avatar All]];
G2L["1d2"]["Position"] = UDim2.new(-0.405, 0, 2.64, 0);


-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.TextLabel.TextButton.Script
G2L["1d3"] = Instance.new("Script", G2L["1d2"]);



-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.TextLabel.TextButton
G2L["1d4"] = Instance.new("TextButton", G2L["1cf"]);
G2L["1d4"]["TextWrapped"] = true;
G2L["1d4"]["BorderSizePixel"] = 3;
G2L["1d4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1d4"]["TextSize"] = 14;
G2L["1d4"]["TextScaled"] = true;
G2L["1d4"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1d4"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1d4"]["Size"] = UDim2.new(0, 343, 0, 50);
G2L["1d4"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1d4"]["Text"] = [[Shake Baseplate]];
G2L["1d4"]["Position"] = UDim2.new(-0.405, 0, 3.86, 0);


-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.TextLabel.TextButton.Script
G2L["1d5"] = Instance.new("Script", G2L["1d4"]);



-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.TextLabel.TextButton
G2L["1d6"] = Instance.new("TextButton", G2L["1cf"]);
G2L["1d6"]["TextWrapped"] = true;
G2L["1d6"]["BorderSizePixel"] = 3;
G2L["1d6"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1d6"]["TextSize"] = 14;
G2L["1d6"]["TextScaled"] = true;
G2L["1d6"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1d6"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1d6"]["Size"] = UDim2.new(0, 343, 0, 50);
G2L["1d6"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1d6"]["Text"] = [[Head Mesh]];
G2L["1d6"]["Position"] = UDim2.new(-0.405, 0, 5.2, 0);


-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.TextLabel.TextButton.Script
G2L["1d7"] = Instance.new("Script", G2L["1d6"]);



-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.TextLabel.TextButton
G2L["1d8"] = Instance.new("TextButton", G2L["1cf"]);
G2L["1d8"]["TextWrapped"] = true;
G2L["1d8"]["BorderSizePixel"] = 3;
G2L["1d8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1d8"]["TextSize"] = 14;
G2L["1d8"]["TextScaled"] = true;
G2L["1d8"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1d8"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1d8"]["Size"] = UDim2.new(0, 343, 0, 50);
G2L["1d8"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1d8"]["Text"] = [[How Bad Can I Be Skybox]];
G2L["1d8"]["Position"] = UDim2.new(-0.405, 0, 6.54, 0);


-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.TextLabel.TextButton.Script
G2L["1d9"] = Instance.new("Script", G2L["1d8"]);



-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.TextLabel.TextButton
G2L["1da"] = Instance.new("TextButton", G2L["1cf"]);
G2L["1da"]["TextWrapped"] = true;
G2L["1da"]["BorderSizePixel"] = 3;
G2L["1da"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1da"]["TextSize"] = 14;
G2L["1da"]["TextScaled"] = true;
G2L["1da"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1da"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1da"]["Size"] = UDim2.new(0, 343, 0, 50);
G2L["1da"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1da"]["Text"] = [[Byte Code Destroy]];
G2L["1da"]["Position"] = UDim2.new(-0.405, 0, 7.82, 0);


-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.TextLabel.TextButton.Script
G2L["1db"] = Instance.new("Script", G2L["1da"]);



-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.TextLabel.TextButton.Script
G2L["1dc"] = Instance.new("Script", G2L["1da"]);



-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.TextLabel.TextButton
G2L["1dd"] = Instance.new("TextButton", G2L["1cf"]);
G2L["1dd"]["TextWrapped"] = true;
G2L["1dd"]["BorderSizePixel"] = 3;
G2L["1dd"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1dd"]["TextSize"] = 14;
G2L["1dd"]["TextScaled"] = true;
G2L["1dd"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1dd"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1dd"]["Size"] = UDim2.new(0, 343, 0, 50);
G2L["1dd"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1dd"]["Text"] = [[colorize and meshify looped]];
G2L["1dd"]["Position"] = UDim2.new(-0.405, 0, 9.28, 0);


-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.TextLabel.TextButton.Script
G2L["1de"] = Instance.new("Script", G2L["1dd"]);



-- StarterGui.ScreenGui.cool.Page2.ScrollingFrame.ImageLabel
G2L["1df"] = Instance.new("ImageLabel", G2L["1ce"]);
G2L["1df"]["BorderSizePixel"] = 0;
G2L["1df"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1df"]["Image"] = [[rbxassetid://9018233362]];
G2L["1df"]["Size"] = UDim2.new(0, 362, 0, 271);
G2L["1df"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1df"]["Position"] = UDim2.new(0.08565, 0, 0.62836, 0);


-- StarterGui.ScreenGui.cool.Page2.Smooth GUI Dragging
G2L["1e0"] = Instance.new("LocalScript", G2L["1cd"]);
G2L["1e0"]["Name"] = [[Smooth GUI Dragging]];


-- StarterGui.ScreenGui.cool.Page2.TextButton
G2L["1e1"] = Instance.new("TextButton", G2L["1cd"]);
G2L["1e1"]["TextWrapped"] = true;
G2L["1e1"]["BorderSizePixel"] = 3;
G2L["1e1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1e1"]["TextSize"] = 14;
G2L["1e1"]["TextScaled"] = true;
G2L["1e1"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1e1"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1e1"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["1e1"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1e1"]["Text"] = [[Page 1]];
G2L["1e1"]["Position"] = UDim2.new(0, 0, -0.13364, 0);


-- StarterGui.ScreenGui.cool.Page2.TextButton.LocalScript
G2L["1e2"] = Instance.new("LocalScript", G2L["1e1"]);



-- StarterGui.ScreenGui.cool.Page2.TextButton
G2L["1e3"] = Instance.new("TextButton", G2L["1cd"]);
G2L["1e3"]["TextWrapped"] = true;
G2L["1e3"]["BorderSizePixel"] = 3;
G2L["1e3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1e3"]["TextSize"] = 14;
G2L["1e3"]["TextScaled"] = true;
G2L["1e3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1e3"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1e3"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["1e3"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1e3"]["Text"] = [[Page 3]];
G2L["1e3"]["Position"] = UDim2.new(0.38364, 0, -0.13364, 0);


-- StarterGui.ScreenGui.cool.Page2.TextButton.LocalScript
G2L["1e4"] = Instance.new("LocalScript", G2L["1e3"]);



-- StarterGui.ScreenGui.cool.Page2.TextButton
G2L["1e5"] = Instance.new("TextButton", G2L["1cd"]);
G2L["1e5"]["TextWrapped"] = true;
G2L["1e5"]["BorderSizePixel"] = 3;
G2L["1e5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1e5"]["TextSize"] = 14;
G2L["1e5"]["TextScaled"] = true;
G2L["1e5"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1e5"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1e5"]["Size"] = UDim2.new(0, 152, 0, 50);
G2L["1e5"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1e5"]["Text"] = [[Page 4]];
G2L["1e5"]["Position"] = UDim2.new(0.76727, 0, -0.13364, 0);


-- StarterGui.ScreenGui.cool.Page2.TextButton.LocalScript
G2L["1e6"] = Instance.new("LocalScript", G2L["1e5"]);



-- StarterGui.ScreenGui.cool.Page2.TextButton
G2L["1e7"] = Instance.new("TextButton", G2L["1cd"]);
G2L["1e7"]["TextWrapped"] = true;
G2L["1e7"]["BorderSizePixel"] = 3;
G2L["1e7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1e7"]["TextSize"] = 14;
G2L["1e7"]["TextScaled"] = true;
G2L["1e7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1e7"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1e7"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["1e7"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1e7"]["Text"] = [[Page 5]];
G2L["1e7"]["Position"] = UDim2.new(-0.00182, 0, -0.27189, 0);


-- StarterGui.ScreenGui.cool.Page2.TextButton.LocalScript
G2L["1e8"] = Instance.new("LocalScript", G2L["1e7"]);



-- StarterGui.ScreenGui.cool.Page2.TextButton
G2L["1e9"] = Instance.new("TextButton", G2L["1cd"]);
G2L["1e9"]["TextWrapped"] = true;
G2L["1e9"]["BorderSizePixel"] = 3;
G2L["1e9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1e9"]["TextSize"] = 14;
G2L["1e9"]["TextScaled"] = true;
G2L["1e9"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1e9"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1e9"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["1e9"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1e9"]["Text"] = [[Page 6]];
G2L["1e9"]["Position"] = UDim2.new(0.38909, 0, -0.27189, 0);


-- StarterGui.ScreenGui.cool.Page2.TextButton.LocalScript
G2L["1ea"] = Instance.new("LocalScript", G2L["1e9"]);



-- StarterGui.ScreenGui.cool.Page2.TextButton
G2L["1eb"] = Instance.new("TextButton", G2L["1cd"]);
G2L["1eb"]["TextWrapped"] = true;
G2L["1eb"]["BorderSizePixel"] = 3;
G2L["1eb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1eb"]["TextSize"] = 14;
G2L["1eb"]["TextScaled"] = true;
G2L["1eb"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1eb"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1eb"]["Size"] = UDim2.new(0, 152, 0, 50);
G2L["1eb"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1eb"]["Text"] = [[Page 7]];
G2L["1eb"]["Position"] = UDim2.new(0.76727, 0, -0.27189, 0);


-- StarterGui.ScreenGui.cool.Page2.TextButton.LocalScript
G2L["1ec"] = Instance.new("LocalScript", G2L["1eb"]);



-- StarterGui.ScreenGui.cool.Page2.TextButton
G2L["1ed"] = Instance.new("TextButton", G2L["1cd"]);
G2L["1ed"]["TextWrapped"] = true;
G2L["1ed"]["BorderSizePixel"] = 3;
G2L["1ed"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1ed"]["TextSize"] = 14;
G2L["1ed"]["TextScaled"] = true;
G2L["1ed"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1ed"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1ed"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["1ed"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1ed"]["Text"] = [[Page 8]];
G2L["1ed"]["Position"] = UDim2.new(-0.00182, 0, -0.40783, 0);


-- StarterGui.ScreenGui.cool.Page2.TextButton.LocalScript
G2L["1ee"] = Instance.new("LocalScript", G2L["1ed"]);



-- StarterGui.ScreenGui.cool.Page1
G2L["1ef"] = Instance.new("Frame", G2L["2"]);
G2L["1ef"]["Visible"] = false;
G2L["1ef"]["BorderSizePixel"] = 0;
G2L["1ef"]["BackgroundColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1ef"]["Size"] = UDim2.new(0, 594, 0, 471);
G2L["1ef"]["Position"] = UDim2.new(5.91262, 0, 3.68095, 0);
G2L["1ef"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1ef"]["Name"] = [[Page1]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame
G2L["1f0"] = Instance.new("ScrollingFrame", G2L["1ef"]);
G2L["1f0"]["Active"] = true;
G2L["1f0"]["BorderSizePixel"] = 0;
G2L["1f0"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1f0"]["Size"] = UDim2.new(0, 578, 0, 456);
G2L["1f0"]["ScrollBarImageColor3"] = Color3.fromRGB(153, 153, 153);
G2L["1f0"]["Position"] = UDim2.new(0.01347, 0, 0.01486, 0);
G2L["1f0"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel
G2L["1f1"] = Instance.new("TextLabel", G2L["1f0"]);
G2L["1f1"]["TextWrapped"] = true;
G2L["1f1"]["BorderSizePixel"] = 3;
G2L["1f1"]["TextSize"] = 20;
G2L["1f1"]["TextScaled"] = true;
G2L["1f1"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1f1"]["FontFace"] = Font.new([[rbxasset://fonts/families/FredokaOne.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1f1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1f1"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["1f1"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1f1"]["Text"] = [[k00pgui(OP) v4]];
G2L["1f1"]["Position"] = UDim2.new(0.32872, 0, -0.00318, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel
G2L["1f2"] = Instance.new("TextLabel", G2L["1f0"]);
G2L["1f2"]["TextWrapped"] = true;
G2L["1f2"]["BorderSizePixel"] = 3;
G2L["1f2"]["TextSize"] = 20;
G2L["1f2"]["TextScaled"] = true;
G2L["1f2"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1f2"]["FontFace"] = Font.new([[rbxasset://fonts/families/FredokaOne.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1f2"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1f2"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["1f2"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1f2"]["Text"] = [[reamke by zelow]];
G2L["1f2"]["Position"] = UDim2.new(0.32872, 0, 0.06379, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["1f3"] = Instance.new("TextButton", G2L["1f2"]);
G2L["1f3"]["TextWrapped"] = true;
G2L["1f3"]["BorderSizePixel"] = 3;
G2L["1f3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1f3"]["TextSize"] = 20;
G2L["1f3"]["TextScaled"] = true;
G2L["1f3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1f3"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1f3"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["1f3"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1f3"]["Text"] = [[Decal 1]];
G2L["1f3"]["Position"] = UDim2.new(-0.905, 0, 1.36, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["1f4"] = Instance.new("Script", G2L["1f3"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["1f5"] = Instance.new("TextButton", G2L["1f2"]);
G2L["1f5"]["TextWrapped"] = true;
G2L["1f5"]["BorderSizePixel"] = 3;
G2L["1f5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1f5"]["TextSize"] = 20;
G2L["1f5"]["TextScaled"] = true;
G2L["1f5"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1f5"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1f5"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["1f5"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1f5"]["Text"] = [[Decal 2]];
G2L["1f5"]["Position"] = UDim2.new(-0.905, 0, 2.12, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["1f6"] = Instance.new("Script", G2L["1f5"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["1f7"] = Instance.new("TextButton", G2L["1f2"]);
G2L["1f7"]["TextWrapped"] = true;
G2L["1f7"]["BorderSizePixel"] = 3;
G2L["1f7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1f7"]["TextSize"] = 20;
G2L["1f7"]["TextScaled"] = true;
G2L["1f7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1f7"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1f7"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["1f7"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1f7"]["Text"] = [[Decal 3]];
G2L["1f7"]["Position"] = UDim2.new(-0.545, 0, 1.36, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["1f8"] = Instance.new("Script", G2L["1f7"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["1f9"] = Instance.new("TextButton", G2L["1f2"]);
G2L["1f9"]["TextWrapped"] = true;
G2L["1f9"]["BorderSizePixel"] = 3;
G2L["1f9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1f9"]["TextSize"] = 20;
G2L["1f9"]["TextScaled"] = true;
G2L["1f9"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1f9"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1f9"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["1f9"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1f9"]["Text"] = [[Decal 4]];
G2L["1f9"]["Position"] = UDim2.new(-0.545, 0, 2.12, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["1fa"] = Instance.new("Script", G2L["1f9"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["1fb"] = Instance.new("TextButton", G2L["1f2"]);
G2L["1fb"]["TextWrapped"] = true;
G2L["1fb"]["BorderSizePixel"] = 3;
G2L["1fb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1fb"]["TextSize"] = 20;
G2L["1fb"]["TextScaled"] = true;
G2L["1fb"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1fb"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1fb"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["1fb"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1fb"]["Text"] = [[Skybox 1]];
G2L["1fb"]["Position"] = UDim2.new(-0.19, 0, 1.36, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["1fc"] = Instance.new("Script", G2L["1fb"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["1fd"] = Instance.new("TextButton", G2L["1f2"]);
G2L["1fd"]["TextWrapped"] = true;
G2L["1fd"]["BorderSizePixel"] = 3;
G2L["1fd"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1fd"]["TextSize"] = 20;
G2L["1fd"]["TextScaled"] = true;
G2L["1fd"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1fd"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1fd"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["1fd"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1fd"]["Text"] = [[Skybox 2]];
G2L["1fd"]["Position"] = UDim2.new(-0.19, 0, 2.12, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["1fe"] = Instance.new("Script", G2L["1fd"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["1ff"] = Instance.new("TextButton", G2L["1f2"]);
G2L["1ff"]["TextWrapped"] = true;
G2L["1ff"]["BorderSizePixel"] = 3;
G2L["1ff"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["1ff"]["TextSize"] = 20;
G2L["1ff"]["TextScaled"] = true;
G2L["1ff"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1ff"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1ff"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["1ff"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["1ff"]["Text"] = [[Skybox 3]];
G2L["1ff"]["Position"] = UDim2.new(0.16, 0, 1.36, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["200"] = Instance.new("Script", G2L["1ff"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["201"] = Instance.new("TextButton", G2L["1f2"]);
G2L["201"]["TextWrapped"] = true;
G2L["201"]["BorderSizePixel"] = 3;
G2L["201"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["201"]["TextSize"] = 20;
G2L["201"]["TextScaled"] = true;
G2L["201"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["201"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["201"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["201"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["201"]["Text"] = [[Skybox 4]];
G2L["201"]["Position"] = UDim2.new(0.16, 0, 2.12, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["202"] = Instance.new("Script", G2L["201"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["203"] = Instance.new("TextButton", G2L["1f2"]);
G2L["203"]["TextWrapped"] = true;
G2L["203"]["BorderSizePixel"] = 3;
G2L["203"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["203"]["TextSize"] = 20;
G2L["203"]["TextScaled"] = true;
G2L["203"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["203"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["203"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["203"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["203"]["Text"] = [[particles 1]];
G2L["203"]["Position"] = UDim2.new(0.54, 0, 1.36, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["204"] = Instance.new("Script", G2L["203"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["205"] = Instance.new("TextButton", G2L["1f2"]);
G2L["205"]["TextWrapped"] = true;
G2L["205"]["BorderSizePixel"] = 3;
G2L["205"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["205"]["TextSize"] = 20;
G2L["205"]["TextScaled"] = true;
G2L["205"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["205"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["205"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["205"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["205"]["Text"] = [[particles 2]];
G2L["205"]["Position"] = UDim2.new(0.54, 0, 2.12, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["206"] = Instance.new("Script", G2L["205"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["207"] = Instance.new("TextButton", G2L["1f2"]);
G2L["207"]["TextWrapped"] = true;
G2L["207"]["BorderSizePixel"] = 3;
G2L["207"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["207"]["TextSize"] = 20;
G2L["207"]["TextScaled"] = true;
G2L["207"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["207"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["207"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["207"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["207"]["Text"] = [[particles 3]];
G2L["207"]["Position"] = UDim2.new(0.9, 0, 1.36, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["208"] = Instance.new("Script", G2L["207"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["209"] = Instance.new("TextButton", G2L["1f2"]);
G2L["209"]["TextWrapped"] = true;
G2L["209"]["BorderSizePixel"] = 3;
G2L["209"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["209"]["TextSize"] = 20;
G2L["209"]["TextScaled"] = true;
G2L["209"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["209"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["209"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["209"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["209"]["Text"] = [[particles 4]];
G2L["209"]["Position"] = UDim2.new(0.9, 0, 2.12, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["20a"] = Instance.new("Script", G2L["209"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["20b"] = Instance.new("TextButton", G2L["1f2"]);
G2L["20b"]["TextWrapped"] = true;
G2L["20b"]["BorderSizePixel"] = 3;
G2L["20b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["20b"]["TextSize"] = 20;
G2L["20b"]["TextScaled"] = true;
G2L["20b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["20b"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["20b"]["Size"] = UDim2.new(0, 49, 0, 30);
G2L["20b"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["20b"]["Text"] = [[Hint 1]];
G2L["20b"]["Position"] = UDim2.new(1.285, 0, 1.36, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["20c"] = Instance.new("Script", G2L["20b"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["20d"] = Instance.new("TextButton", G2L["1f2"]);
G2L["20d"]["TextWrapped"] = true;
G2L["20d"]["BorderSizePixel"] = 3;
G2L["20d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["20d"]["TextSize"] = 20;
G2L["20d"]["TextScaled"] = true;
G2L["20d"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["20d"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["20d"]["Size"] = UDim2.new(0, 49, 0, 30);
G2L["20d"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["20d"]["Text"] = [[Hint 2]];
G2L["20d"]["Position"] = UDim2.new(1.285, 0, 2.12, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["20e"] = Instance.new("Script", G2L["20d"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["20f"] = Instance.new("TextButton", G2L["1f2"]);
G2L["20f"]["TextWrapped"] = true;
G2L["20f"]["BorderSizePixel"] = 3;
G2L["20f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["20f"]["TextSize"] = 20;
G2L["20f"]["TextScaled"] = true;
G2L["20f"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["20f"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["20f"]["Size"] = UDim2.new(0, 46, 0, 30);
G2L["20f"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["20f"]["Text"] = [[Hint 4]];
G2L["20f"]["Position"] = UDim2.new(1.595, 0, 2.10658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["210"] = Instance.new("Script", G2L["20f"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["211"] = Instance.new("TextButton", G2L["1f2"]);
G2L["211"]["TextWrapped"] = true;
G2L["211"]["BorderSizePixel"] = 3;
G2L["211"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["211"]["TextSize"] = 20;
G2L["211"]["TextScaled"] = true;
G2L["211"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["211"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["211"]["Size"] = UDim2.new(0, 46, 0, 30);
G2L["211"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["211"]["Text"] = [[Hint 3]];
G2L["211"]["Position"] = UDim2.new(1.595, 0, 1.34658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["212"] = Instance.new("Script", G2L["211"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["213"] = Instance.new("TextButton", G2L["1f2"]);
G2L["213"]["TextWrapped"] = true;
G2L["213"]["BorderSizePixel"] = 3;
G2L["213"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["213"]["TextSize"] = 20;
G2L["213"]["TextScaled"] = true;
G2L["213"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["213"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["213"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["213"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["213"]["Text"] = [[Message 1]];
G2L["213"]["Position"] = UDim2.new(-0.905, 0, 2.98658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["214"] = Instance.new("Script", G2L["213"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["215"] = Instance.new("TextButton", G2L["1f2"]);
G2L["215"]["TextWrapped"] = true;
G2L["215"]["BorderSizePixel"] = 3;
G2L["215"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["215"]["TextSize"] = 20;
G2L["215"]["TextScaled"] = true;
G2L["215"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["215"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["215"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["215"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["215"]["Text"] = [[Message 2]];
G2L["215"]["Position"] = UDim2.new(-0.545, 0, 3.00658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["216"] = Instance.new("Script", G2L["215"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["217"] = Instance.new("TextButton", G2L["1f2"]);
G2L["217"]["TextWrapped"] = true;
G2L["217"]["BorderSizePixel"] = 3;
G2L["217"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["217"]["TextSize"] = 20;
G2L["217"]["TextScaled"] = true;
G2L["217"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["217"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["217"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["217"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["217"]["Text"] = [[Message 3]];
G2L["217"]["Position"] = UDim2.new(-0.905, 0, 3.82658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["218"] = Instance.new("Script", G2L["217"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["219"] = Instance.new("TextButton", G2L["1f2"]);
G2L["219"]["TextWrapped"] = true;
G2L["219"]["BorderSizePixel"] = 3;
G2L["219"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["219"]["TextSize"] = 20;
G2L["219"]["TextScaled"] = true;
G2L["219"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["219"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["219"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["219"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["219"]["Text"] = [[Message 4]];
G2L["219"]["Position"] = UDim2.new(-0.545, 0, 3.82658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["21a"] = Instance.new("Script", G2L["219"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["21b"] = Instance.new("TextButton", G2L["1f2"]);
G2L["21b"]["TextWrapped"] = true;
G2L["21b"]["BorderSizePixel"] = 3;
G2L["21b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["21b"]["TextSize"] = 20;
G2L["21b"]["TextScaled"] = true;
G2L["21b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["21b"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["21b"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["21b"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["21b"]["Text"] = [[funni skybox 1]];
G2L["21b"]["Position"] = UDim2.new(-0.19, 0, 3.00658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["21c"] = Instance.new("Script", G2L["21b"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Images/Asian Head Funny  :3
G2L["21d"] = Instance.new("Decal", G2L["21c"]);
G2L["21d"]["Name"] = [[Images/Asian Head Funny  :3]];
G2L["21d"]["Texture"] = [[http://www.roblox.com/asset/?id=275216996]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["21e"] = Instance.new("TextButton", G2L["1f2"]);
G2L["21e"]["TextWrapped"] = true;
G2L["21e"]["BorderSizePixel"] = 3;
G2L["21e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["21e"]["TextSize"] = 20;
G2L["21e"]["TextScaled"] = true;
G2L["21e"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["21e"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["21e"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["21e"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["21e"]["Text"] = [[funni skybox 2]];
G2L["21e"]["Position"] = UDim2.new(-0.19, 0, 3.82658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["21f"] = Instance.new("Script", G2L["21e"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Images/Asian Head Funny  :3
G2L["220"] = Instance.new("Decal", G2L["21f"]);
G2L["220"]["Name"] = [[Images/Asian Head Funny  :3]];
G2L["220"]["Texture"] = [[http://www.roblox.com/asset/?id=275216996]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.FUNNY GUY
G2L["221"] = Instance.new("Decal", G2L["21f"]);
G2L["221"]["Name"] = [[FUNNY GUY]];
G2L["221"]["Texture"] = [[http://www.roblox.com/asset/?id=13793493472]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["222"] = Instance.new("TextButton", G2L["1f2"]);
G2L["222"]["TextWrapped"] = true;
G2L["222"]["BorderSizePixel"] = 3;
G2L["222"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["222"]["TextSize"] = 20;
G2L["222"]["TextScaled"] = true;
G2L["222"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["222"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["222"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["222"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["222"]["Text"] = [[Clear Skyboxes]];
G2L["222"]["Position"] = UDim2.new(1.21, 0, 8.88658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["223"] = Instance.new("Script", G2L["222"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["224"] = Instance.new("TextButton", G2L["1f2"]);
G2L["224"]["TextWrapped"] = true;
G2L["224"]["BorderSizePixel"] = 3;
G2L["224"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["224"]["TextSize"] = 20;
G2L["224"]["TextScaled"] = true;
G2L["224"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["224"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["224"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["224"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["224"]["Text"] = [[funni skybox 4]];
G2L["224"]["Position"] = UDim2.new(0.16, 0, 3.82658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["225"] = Instance.new("Script", G2L["224"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Images/Asian Head Funny  :3
G2L["226"] = Instance.new("Decal", G2L["225"]);
G2L["226"]["Name"] = [[Images/Asian Head Funny  :3]];
G2L["226"]["Texture"] = [[http://www.roblox.com/asset/?id=275216996]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.funny TF2 scout
G2L["227"] = Instance.new("Decal", G2L["225"]);
G2L["227"]["Name"] = [[funny TF2 scout]];
G2L["227"]["Texture"] = [[http://www.roblox.com/asset/?id=8683686271]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.funny cat!!!!!!!
G2L["228"] = Instance.new("Decal", G2L["225"]);
G2L["228"]["Name"] = [[funny cat!!!!!!!]];
G2L["228"]["Texture"] = [[http://www.roblox.com/asset/?id=13184253294]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["229"] = Instance.new("TextButton", G2L["1f2"]);
G2L["229"]["TextWrapped"] = true;
G2L["229"]["BorderSizePixel"] = 3;
G2L["229"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["229"]["TextSize"] = 20;
G2L["229"]["TextScaled"] = true;
G2L["229"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["229"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["229"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["229"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["229"]["Text"] = [[k00p op jumpscare 1]];
G2L["229"]["Position"] = UDim2.new(0.54, 0, 3.00658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["22a"] = Instance.new("Script", G2L["229"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Images/Asian Head Funny  :3
G2L["22b"] = Instance.new("Decal", G2L["22a"]);
G2L["22b"]["Name"] = [[Images/Asian Head Funny  :3]];
G2L["22b"]["Texture"] = [[http://www.roblox.com/asset/?id=275216996]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.funny TF2 scout
G2L["22c"] = Instance.new("Decal", G2L["22a"]);
G2L["22c"]["Name"] = [[funny TF2 scout]];
G2L["22c"]["Texture"] = [[http://www.roblox.com/asset/?id=8683686271]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["22d"] = Instance.new("TextButton", G2L["1f2"]);
G2L["22d"]["TextWrapped"] = true;
G2L["22d"]["BorderSizePixel"] = 3;
G2L["22d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["22d"]["TextSize"] = 20;
G2L["22d"]["TextScaled"] = true;
G2L["22d"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["22d"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["22d"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["22d"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["22d"]["Text"] = [[k00p op jumpscare 2]];
G2L["22d"]["Position"] = UDim2.new(0.54, 0, 3.82658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["22e"] = Instance.new("Script", G2L["22d"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Images/Asian Head Funny  :3
G2L["22f"] = Instance.new("Decal", G2L["22e"]);
G2L["22f"]["Name"] = [[Images/Asian Head Funny  :3]];
G2L["22f"]["Texture"] = [[http://www.roblox.com/asset/?id=275216996]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.funny TF2 scout
G2L["230"] = Instance.new("Decal", G2L["22e"]);
G2L["230"]["Name"] = [[funny TF2 scout]];
G2L["230"]["Texture"] = [[http://www.roblox.com/asset/?id=8683686271]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["231"] = Instance.new("TextButton", G2L["1f2"]);
G2L["231"]["TextWrapped"] = true;
G2L["231"]["BorderSizePixel"] = 3;
G2L["231"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["231"]["TextSize"] = 20;
G2L["231"]["TextScaled"] = true;
G2L["231"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["231"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["231"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["231"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["231"]["Text"] = [[funni jumpscare 1]];
G2L["231"]["Position"] = UDim2.new(0.925, 0, 3.00658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["232"] = Instance.new("Script", G2L["231"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Images/Asian Head Funny  :3
G2L["233"] = Instance.new("Decal", G2L["232"]);
G2L["233"]["Name"] = [[Images/Asian Head Funny  :3]];
G2L["233"]["Texture"] = [[http://www.roblox.com/asset/?id=275216996]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.funny TF2 scout
G2L["234"] = Instance.new("Decal", G2L["232"]);
G2L["234"]["Name"] = [[funny TF2 scout]];
G2L["234"]["Texture"] = [[http://www.roblox.com/asset/?id=8683686271]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Yes, yes, yes, oh my God.
G2L["235"] = Instance.new("Sound", G2L["232"]);
G2L["235"]["Name"] = [[Yes, yes, yes, oh my God.]];
G2L["235"]["SoundId"] = [[rbxassetid://6148925438]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Yes, yes, yes, oh my God..Oh My God, They Killed Kenny! | SOUTH PARK MEME
G2L["236"] = Instance.new("Decal", G2L["235"]);
G2L["236"]["Name"] = [[Oh My God, They Killed Kenny! | SOUTH PARK MEME]];
G2L["236"]["Texture"] = [[http://www.roblox.com/asset/?id=13383483875]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["237"] = Instance.new("TextButton", G2L["1f2"]);
G2L["237"]["TextWrapped"] = true;
G2L["237"]["BorderSizePixel"] = 3;
G2L["237"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["237"]["TextSize"] = 20;
G2L["237"]["TextScaled"] = true;
G2L["237"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["237"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["237"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["237"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["237"]["Text"] = [[funni jumpscare 2]];
G2L["237"]["Position"] = UDim2.new(0.925, 0, 3.82658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["238"] = Instance.new("Script", G2L["237"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Images/Asian Head Funny  :3
G2L["239"] = Instance.new("Decal", G2L["238"]);
G2L["239"]["Name"] = [[Images/Asian Head Funny  :3]];
G2L["239"]["Texture"] = [[http://www.roblox.com/asset/?id=275216996]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.funny TF2 scout
G2L["23a"] = Instance.new("Decal", G2L["238"]);
G2L["23a"]["Name"] = [[funny TF2 scout]];
G2L["23a"]["Texture"] = [[http://www.roblox.com/asset/?id=8683686271]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Yes, yes, yes, oh my God.
G2L["23b"] = Instance.new("Sound", G2L["238"]);
G2L["23b"]["Name"] = [[Yes, yes, yes, oh my God.]];
G2L["23b"]["SoundId"] = [[rbxassetid://6148925438]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Yes, yes, yes, oh my God..Oh My God, They Killed Kenny! | SOUTH PARK MEME
G2L["23c"] = Instance.new("Decal", G2L["23b"]);
G2L["23c"]["Name"] = [[Oh My God, They Killed Kenny! | SOUTH PARK MEME]];
G2L["23c"]["Texture"] = [[http://www.roblox.com/asset/?id=13383483875]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.10 Coems🤑
G2L["23d"] = Instance.new("Decal", G2L["238"]);
G2L["23d"]["Name"] = [[10 Coems🤑]];
G2L["23d"]["Texture"] = [[http://www.roblox.com/asset/?id=13033244553]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["23e"] = Instance.new("TextButton", G2L["1f2"]);
G2L["23e"]["TextWrapped"] = true;
G2L["23e"]["BorderSizePixel"] = 3;
G2L["23e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["23e"]["TextSize"] = 20;
G2L["23e"]["TextScaled"] = true;
G2L["23e"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["23e"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["23e"]["Size"] = UDim2.new(0, 95, 0, 38);
G2L["23e"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["23e"]["Text"] = [[R6]];
G2L["23e"]["Position"] = UDim2.new(1.285, 0, -0.94, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["23f"] = Instance.new("Script", G2L["23e"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["240"] = Instance.new("LocalScript", G2L["23e"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["241"] = Instance.new("RemoteEvent", G2L["23e"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.re
G2L["242"] = Instance.new("TextButton", G2L["1f2"]);
G2L["242"]["TextWrapped"] = true;
G2L["242"]["BorderSizePixel"] = 3;
G2L["242"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["242"]["TextSize"] = 20;
G2L["242"]["TextScaled"] = true;
G2L["242"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["242"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["242"]["Size"] = UDim2.new(0, 95, 0, 38);
G2L["242"]["Name"] = [[re]];
G2L["242"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["242"]["Text"] = [[RE]];
G2L["242"]["Position"] = UDim2.new(-0.77, 0, -0.94, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.re.Script
G2L["243"] = Instance.new("Script", G2L["242"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["244"] = Instance.new("TextButton", G2L["1f2"]);
G2L["244"]["TextWrapped"] = true;
G2L["244"]["BorderSizePixel"] = 3;
G2L["244"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["244"]["TextSize"] = 20;
G2L["244"]["TextScaled"] = true;
G2L["244"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["244"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["244"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["244"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["244"]["Text"] = [[k00p funni skybox 1]];
G2L["244"]["Position"] = UDim2.new(1.285, 0, 2.98658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["245"] = Instance.new("Script", G2L["244"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["246"] = Instance.new("LocalScript", G2L["244"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["247"] = Instance.new("RemoteEvent", G2L["244"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["248"] = Instance.new("TextButton", G2L["1f2"]);
G2L["248"]["TextWrapped"] = true;
G2L["248"]["BorderSizePixel"] = 3;
G2L["248"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["248"]["TextSize"] = 20;
G2L["248"]["TextScaled"] = true;
G2L["248"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["248"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["248"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["248"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["248"]["Text"] = [[k00p funni skybox 2]];
G2L["248"]["Position"] = UDim2.new(1.285, 0, 3.80658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["249"] = Instance.new("Script", G2L["248"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.dd
G2L["24a"] = Instance.new("Decal", G2L["249"]);
G2L["24a"]["Name"] = [[dd]];
G2L["24a"]["Texture"] = [[http://www.roblox.com/asset/?id=14469892834]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["24b"] = Instance.new("TextButton", G2L["1f2"]);
G2L["24b"]["TextWrapped"] = true;
G2L["24b"]["BorderSizePixel"] = 3;
G2L["24b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["24b"]["TextSize"] = 20;
G2L["24b"]["TextScaled"] = true;
G2L["24b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["24b"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["24b"]["Size"] = UDim2.new(0, 95, 0, 38);
G2L["24b"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["24b"]["Text"] = [[Play Theme]];
G2L["24b"]["Position"] = UDim2.new(1.285, 0, 0.12, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["24c"] = Instance.new("Script", G2L["24b"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["24d"] = Instance.new("LocalScript", G2L["24b"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["24e"] = Instance.new("RemoteEvent", G2L["24b"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["24f"] = Instance.new("TextButton", G2L["1f2"]);
G2L["24f"]["TextWrapped"] = true;
G2L["24f"]["BorderSizePixel"] = 3;
G2L["24f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["24f"]["TextSize"] = 20;
G2L["24f"]["TextScaled"] = true;
G2L["24f"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["24f"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["24f"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["24f"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["24f"]["Text"] = [[c00lgui reborn v1]];
G2L["24f"]["Position"] = UDim2.new(1.435, 0, 11.36658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["250"] = Instance.new("Script", G2L["24f"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["251"] = Instance.new("LocalScript", G2L["24f"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["252"] = Instance.new("RemoteEvent", G2L["24f"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["253"] = Instance.new("TextButton", G2L["1f2"]);
G2L["253"]["TextWrapped"] = true;
G2L["253"]["BorderSizePixel"] = 3;
G2L["253"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["253"]["TextSize"] = 20;
G2L["253"]["TextScaled"] = true;
G2L["253"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["253"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["253"]["Size"] = UDim2.new(0, 536, 0, 30);
G2L["253"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["253"]["Text"] = [[DESTORY [EMERGENCY ONLY]]];
G2L["253"]["Position"] = UDim2.new(-0.855, 0, 4.76658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["254"] = Instance.new("Script", G2L["253"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["255"] = Instance.new("LocalScript", G2L["253"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["256"] = Instance.new("RemoteEvent", G2L["253"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["257"] = Instance.new("TextButton", G2L["1f2"]);
G2L["257"]["TextWrapped"] = true;
G2L["257"]["BorderSizePixel"] = 3;
G2L["257"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["257"]["TextSize"] = 20;
G2L["257"]["TextScaled"] = true;
G2L["257"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["257"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["257"]["Size"] = UDim2.new(0, 38, 0, 71);
G2L["257"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["257"]["Text"] = [[anti ban ]];
G2L["257"]["Position"] = UDim2.new(1.635, 0, 2.98658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["258"] = Instance.new("Script", G2L["257"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["259"] = Instance.new("LocalScript", G2L["257"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["25a"] = Instance.new("RemoteEvent", G2L["257"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["25b"] = Instance.new("TextButton", G2L["1f2"]);
G2L["25b"]["TextWrapped"] = true;
G2L["25b"]["BorderSizePixel"] = 3;
G2L["25b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["25b"]["TextSize"] = 20;
G2L["25b"]["TextScaled"] = true;
G2L["25b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["25b"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["25b"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["25b"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["25b"]["Text"] = [[Anti-Leave]];
G2L["25b"]["Position"] = UDim2.new(-0.855, 0, 5.62658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["25c"] = Instance.new("Script", G2L["25b"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.MainModule
G2L["25d"] = Instance.new("ModuleScript", G2L["25c"]);
G2L["25d"]["Name"] = [[MainModule]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.MainModule.LOLNO
G2L["25e"] = Instance.new("LocalScript", G2L["25d"]);
G2L["25e"]["Enabled"] = false;
G2L["25e"]["Name"] = [[LOLNO]];
G2L["25e"]["Disabled"] = true;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["25f"] = Instance.new("LocalScript", G2L["25b"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["260"] = Instance.new("RemoteEvent", G2L["25b"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["261"] = Instance.new("TextButton", G2L["1f2"]);
G2L["261"]["TextWrapped"] = true;
G2L["261"]["BorderSizePixel"] = 3;
G2L["261"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["261"]["TextSize"] = 20;
G2L["261"]["TextScaled"] = true;
G2L["261"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["261"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["261"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["261"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["261"]["Text"] = [[Ball Rain]];
G2L["261"]["Position"] = UDim2.new(-0.39, 0, 5.62658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["262"] = Instance.new("Script", G2L["261"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["263"] = Instance.new("TextButton", G2L["1f2"]);
G2L["263"]["TextWrapped"] = true;
G2L["263"]["BorderSizePixel"] = 3;
G2L["263"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["263"]["TextSize"] = 20;
G2L["263"]["TextScaled"] = true;
G2L["263"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["263"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["263"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["263"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["263"]["Text"] = [[Avatars]];
G2L["263"]["Position"] = UDim2.new(0.08, 0, 5.62658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["264"] = Instance.new("Script", G2L["263"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["265"] = Instance.new("LocalScript", G2L["263"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["266"] = Instance.new("RemoteEvent", G2L["263"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["267"] = Instance.new("TextButton", G2L["1f2"]);
G2L["267"]["TextWrapped"] = true;
G2L["267"]["BorderSizePixel"] = 3;
G2L["267"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["267"]["TextSize"] = 20;
G2L["267"]["TextScaled"] = true;
G2L["267"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["267"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["267"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["267"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["267"]["Text"] = [[k00pkidd face all]];
G2L["267"]["Position"] = UDim2.new(0.54, 0, 5.62658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["268"] = Instance.new("Script", G2L["267"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Png (1)
G2L["269"] = Instance.new("Decal", G2L["268"]);
G2L["269"]["Name"] = [[Png (1)]];
G2L["269"]["Texture"] = [[http://www.roblox.com/asset/?id=14406225277]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["26a"] = Instance.new("LocalScript", G2L["267"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["26b"] = Instance.new("RemoteEvent", G2L["267"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["26c"] = Instance.new("TextButton", G2L["1f2"]);
G2L["26c"]["TextWrapped"] = true;
G2L["26c"]["BorderSizePixel"] = 3;
G2L["26c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["26c"]["TextSize"] = 20;
G2L["26c"]["TextScaled"] = true;
G2L["26c"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["26c"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["26c"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["26c"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["26c"]["Text"] = [[KaaX face all]];
G2L["26c"]["Position"] = UDim2.new(1, 0, 5.62658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["26d"] = Instance.new("Script", G2L["26c"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Png (1)
G2L["26e"] = Instance.new("Decal", G2L["26d"]);
G2L["26e"]["Name"] = [[Png (1)]];
G2L["26e"]["Texture"] = [[http://www.roblox.com/asset/?id=14406225277]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["26f"] = Instance.new("LocalScript", G2L["26c"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["270"] = Instance.new("RemoteEvent", G2L["26c"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["271"] = Instance.new("TextButton", G2L["1f2"]);
G2L["271"]["TextWrapped"] = true;
G2L["271"]["BorderSizePixel"] = 3;
G2L["271"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["271"]["TextSize"] = 20;
G2L["271"]["TextScaled"] = true;
G2L["271"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["271"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["271"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["271"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["271"]["Text"] = [[fire brick rain]];
G2L["271"]["Position"] = UDim2.new(1.435, 0, 5.62658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["272"] = Instance.new("Script", G2L["271"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Png (1)
G2L["273"] = Instance.new("Decal", G2L["272"]);
G2L["273"]["Name"] = [[Png (1)]];
G2L["273"]["Texture"] = [[http://www.roblox.com/asset/?id=14406225277]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["274"] = Instance.new("LocalScript", G2L["271"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["275"] = Instance.new("RemoteEvent", G2L["271"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["276"] = Instance.new("TextButton", G2L["1f2"]);
G2L["276"]["TextWrapped"] = true;
G2L["276"]["BorderSizePixel"] = 3;
G2L["276"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["276"]["TextSize"] = 20;
G2L["276"]["TextScaled"] = true;
G2L["276"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["276"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["276"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["276"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["276"]["Text"] = [[Teams]];
G2L["276"]["Position"] = UDim2.new(-0.855, 0, 6.46658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["277"] = Instance.new("Script", G2L["276"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Png (1)
G2L["278"] = Instance.new("Decal", G2L["277"]);
G2L["278"]["Name"] = [[Png (1)]];
G2L["278"]["Texture"] = [[http://www.roblox.com/asset/?id=14406225277]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["279"] = Instance.new("LocalScript", G2L["276"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["27a"] = Instance.new("RemoteEvent", G2L["276"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["27b"] = Instance.new("TextButton", G2L["1f2"]);
G2L["27b"]["TextWrapped"] = true;
G2L["27b"]["BorderSizePixel"] = 3;
G2L["27b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["27b"]["TextSize"] = 20;
G2L["27b"]["TextScaled"] = true;
G2L["27b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["27b"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["27b"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["27b"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["27b"]["Text"] = [[funni hamsta skybox]];
G2L["27b"]["Position"] = UDim2.new(-0.39, 0, 6.46658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["27c"] = Instance.new("Script", G2L["27b"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["27d"] = Instance.new("TextButton", G2L["1f2"]);
G2L["27d"]["TextWrapped"] = true;
G2L["27d"]["BorderSizePixel"] = 3;
G2L["27d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["27d"]["TextSize"] = 20;
G2L["27d"]["TextScaled"] = true;
G2L["27d"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["27d"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["27d"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["27d"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["27d"]["Text"] = [[coem face all]];
G2L["27d"]["Position"] = UDim2.new(0.08, 0, 6.46658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["27e"] = Instance.new("Script", G2L["27d"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.10 Coems🤑
G2L["27f"] = Instance.new("Decal", G2L["27e"]);
G2L["27f"]["Name"] = [[10 Coems🤑]];
G2L["27f"]["Texture"] = [[http://www.roblox.com/asset/?id=13033244553]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["280"] = Instance.new("TextButton", G2L["1f2"]);
G2L["280"]["TextWrapped"] = true;
G2L["280"]["BorderSizePixel"] = 3;
G2L["280"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["280"]["TextSize"] = 20;
G2L["280"]["TextScaled"] = true;
G2L["280"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["280"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["280"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["280"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["280"]["Text"] = [[trollface face all]];
G2L["280"]["Position"] = UDim2.new(0.54, 0, 6.46658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["281"] = Instance.new("Script", G2L["280"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.10 Coems🤑
G2L["282"] = Instance.new("Decal", G2L["281"]);
G2L["282"]["Name"] = [[10 Coems🤑]];
G2L["282"]["Texture"] = [[http://www.roblox.com/asset/?id=13033244553]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Trollface
G2L["283"] = Instance.new("Decal", G2L["281"]);
G2L["283"]["Name"] = [[Trollface]];
G2L["283"]["Texture"] = [[http://www.roblox.com/asset/?id=8126977748]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["284"] = Instance.new("TextButton", G2L["1f2"]);
G2L["284"]["TextWrapped"] = true;
G2L["284"]["BorderSizePixel"] = 3;
G2L["284"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["284"]["TextSize"] = 20;
G2L["284"]["TextScaled"] = true;
G2L["284"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["284"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["284"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["284"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["284"]["Text"] = [[BGui]];
G2L["284"]["Position"] = UDim2.new(1, 0, 6.46658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["285"] = Instance.new("Script", G2L["284"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["286"] = Instance.new("LocalScript", G2L["284"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["287"] = Instance.new("RemoteEvent", G2L["284"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["288"] = Instance.new("TextButton", G2L["1f2"]);
G2L["288"]["TextWrapped"] = true;
G2L["288"]["BorderSizePixel"] = 3;
G2L["288"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["288"]["TextSize"] = 20;
G2L["288"]["TextScaled"] = true;
G2L["288"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["288"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["288"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["288"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["288"]["Text"] = [[Kill All]];
G2L["288"]["Position"] = UDim2.new(1.435, 0, 6.46658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["289"] = Instance.new("Script", G2L["288"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["28a"] = Instance.new("LocalScript", G2L["288"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["28b"] = Instance.new("RemoteEvent", G2L["288"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["28c"] = Instance.new("TextButton", G2L["1f2"]);
G2L["28c"]["TextWrapped"] = true;
G2L["28c"]["BorderSizePixel"] = 3;
G2L["28c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["28c"]["TextSize"] = 20;
G2L["28c"]["TextScaled"] = true;
G2L["28c"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["28c"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["28c"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["28c"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["28c"]["Text"] = [[Water]];
G2L["28c"]["Position"] = UDim2.new(-0.855, 0, 7.26658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["28d"] = Instance.new("Script", G2L["28c"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["28e"] = Instance.new("LocalScript", G2L["28c"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["28f"] = Instance.new("RemoteEvent", G2L["28c"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["290"] = Instance.new("Script", G2L["28c"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["291"] = Instance.new("TextButton", G2L["1f2"]);
G2L["291"]["TextWrapped"] = true;
G2L["291"]["BorderSizePixel"] = 3;
G2L["291"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["291"]["TextSize"] = 20;
G2L["291"]["TextScaled"] = true;
G2L["291"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["291"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["291"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["291"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["291"]["Text"] = [[Unanchor]];
G2L["291"]["Position"] = UDim2.new(-0.39, 0, 7.26658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["292"] = Instance.new("Script", G2L["291"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["293"] = Instance.new("LocalScript", G2L["291"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["294"] = Instance.new("RemoteEvent", G2L["291"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["295"] = Instance.new("TextButton", G2L["1f2"]);
G2L["295"]["TextWrapped"] = true;
G2L["295"]["BorderSizePixel"] = 3;
G2L["295"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["295"]["TextSize"] = 20;
G2L["295"]["TextScaled"] = true;
G2L["295"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["295"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["295"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["295"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["295"]["Text"] = [[Anchor]];
G2L["295"]["Position"] = UDim2.new(0.08, 0, 7.26658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["296"] = Instance.new("Script", G2L["295"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["297"] = Instance.new("LocalScript", G2L["295"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["298"] = Instance.new("RemoteEvent", G2L["295"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["299"] = Instance.new("TextButton", G2L["1f2"]);
G2L["299"]["TextWrapped"] = true;
G2L["299"]["BorderSizePixel"] = 3;
G2L["299"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["299"]["TextSize"] = 20;
G2L["299"]["TextScaled"] = true;
G2L["299"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["299"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["299"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["299"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["299"]["Text"] = [[Ghost]];
G2L["299"]["Position"] = UDim2.new(0.54, 0, 7.26658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["29a"] = Instance.new("Script", G2L["299"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.FakeMouse
G2L["29b"] = Instance.new("ModuleScript", G2L["29a"]);
G2L["29b"]["Name"] = [[FakeMouse]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.FakeMouse.Client
G2L["29c"] = Instance.new("LocalScript", G2L["29b"]);
G2L["29c"]["Enabled"] = false;
G2L["29c"]["Name"] = [[Client]];
G2L["29c"]["Disabled"] = true;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.FakeMouse.GetPlr
G2L["29d"] = Instance.new("RemoteEvent", G2L["29b"]);
G2L["29d"]["Name"] = [[GetPlr]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.FakeMouse.GetPlrE
G2L["29e"] = Instance.new("RemoteFunction", G2L["29b"]);
G2L["29e"]["Name"] = [[GetPlrE]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["29f"] = Instance.new("TextButton", G2L["1f2"]);
G2L["29f"]["TextWrapped"] = true;
G2L["29f"]["BorderSizePixel"] = 3;
G2L["29f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["29f"]["TextSize"] = 20;
G2L["29f"]["TextScaled"] = true;
G2L["29f"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["29f"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["29f"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["29f"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["29f"]["Text"] = [[Disco]];
G2L["29f"]["Position"] = UDim2.new(1, 0, 7.26658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2a0"] = Instance.new("Script", G2L["29f"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2a1"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2a1"]["TextWrapped"] = true;
G2L["2a1"]["BorderSizePixel"] = 3;
G2L["2a1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2a1"]["TextSize"] = 20;
G2L["2a1"]["TextScaled"] = true;
G2L["2a1"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2a1"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2a1"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["2a1"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2a1"]["Text"] = [[Destroy da gaem]];
G2L["2a1"]["Position"] = UDim2.new(1.435, 0, 7.26658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2a2"] = Instance.new("Script", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2a3"] = Instance.new("Script", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.MainModule
G2L["2a4"] = Instance.new("ModuleScript", G2L["2a3"]);
G2L["2a4"]["Name"] = [[MainModule]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.MainModule.LOLNO
G2L["2a5"] = Instance.new("LocalScript", G2L["2a4"]);
G2L["2a5"]["Enabled"] = false;
G2L["2a5"]["Name"] = [[LOLNO]];
G2L["2a5"]["Disabled"] = true;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["2a6"] = Instance.new("LocalScript", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["2a7"] = Instance.new("RemoteEvent", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2a8"] = Instance.new("Script", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2a9"] = Instance.new("Script", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Png (1)
G2L["2aa"] = Instance.new("Decal", G2L["2a9"]);
G2L["2aa"]["Name"] = [[Png (1)]];
G2L["2aa"]["Texture"] = [[http://www.roblox.com/asset/?id=14406225277]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["2ab"] = Instance.new("LocalScript", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["2ac"] = Instance.new("RemoteEvent", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2ad"] = Instance.new("Script", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Png (1)
G2L["2ae"] = Instance.new("Decal", G2L["2ad"]);
G2L["2ae"]["Name"] = [[Png (1)]];
G2L["2ae"]["Texture"] = [[http://www.roblox.com/asset/?id=14406225277]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["2af"] = Instance.new("LocalScript", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["2b0"] = Instance.new("RemoteEvent", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2b1"] = Instance.new("Script", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Png (1)
G2L["2b2"] = Instance.new("Decal", G2L["2b1"]);
G2L["2b2"]["Name"] = [[Png (1)]];
G2L["2b2"]["Texture"] = [[http://www.roblox.com/asset/?id=14406225277]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["2b3"] = Instance.new("LocalScript", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["2b4"] = Instance.new("RemoteEvent", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2b5"] = Instance.new("Script", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Png (1)
G2L["2b6"] = Instance.new("Decal", G2L["2b5"]);
G2L["2b6"]["Name"] = [[Png (1)]];
G2L["2b6"]["Texture"] = [[http://www.roblox.com/asset/?id=14406225277]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["2b7"] = Instance.new("LocalScript", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["2b8"] = Instance.new("RemoteEvent", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2b9"] = Instance.new("Script", G2L["2a1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Png (1)
G2L["2ba"] = Instance.new("Decal", G2L["2b9"]);
G2L["2ba"]["Name"] = [[Png (1)]];
G2L["2ba"]["Texture"] = [[http://www.roblox.com/asset/?id=14406225277]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2bb"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2bb"]["TextWrapped"] = true;
G2L["2bb"]["BorderSizePixel"] = 3;
G2L["2bb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2bb"]["TextSize"] = 20;
G2L["2bb"]["TextScaled"] = true;
G2L["2bb"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2bb"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2bb"]["Size"] = UDim2.new(0, 42, 0, 30);
G2L["2bb"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2bb"]["Text"] = [[Big Particles 1]];
G2L["2bb"]["Position"] = UDim2.new(-0.855, 0, 8.10658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2bc"] = Instance.new("Script", G2L["2bb"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2bd"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2bd"]["TextWrapped"] = true;
G2L["2bd"]["BorderSizePixel"] = 3;
G2L["2bd"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2bd"]["TextSize"] = 20;
G2L["2bd"]["TextScaled"] = true;
G2L["2bd"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2bd"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2bd"]["Size"] = UDim2.new(0, 42, 0, 30);
G2L["2bd"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2bd"]["Text"] = [[Big Particles 2]];
G2L["2bd"]["Position"] = UDim2.new(-0.595, 0, 8.10658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2be"] = Instance.new("Script", G2L["2bd"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2bf"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2bf"]["TextWrapped"] = true;
G2L["2bf"]["BorderSizePixel"] = 3;
G2L["2bf"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2bf"]["TextSize"] = 20;
G2L["2bf"]["TextScaled"] = true;
G2L["2bf"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2bf"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2bf"]["Size"] = UDim2.new(0, 42, 0, 30);
G2L["2bf"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2bf"]["Text"] = [[Big Particles 3]];
G2L["2bf"]["Position"] = UDim2.new(-0.855, 0, 8.90658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2c0"] = Instance.new("Script", G2L["2bf"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2c1"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2c1"]["TextWrapped"] = true;
G2L["2c1"]["BorderSizePixel"] = 3;
G2L["2c1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2c1"]["TextSize"] = 20;
G2L["2c1"]["TextScaled"] = true;
G2L["2c1"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2c1"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2c1"]["Size"] = UDim2.new(0, 42, 0, 30);
G2L["2c1"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2c1"]["Text"] = [[Big Particles 4]];
G2L["2c1"]["Position"] = UDim2.new(-0.6, 0, 8.90658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2c2"] = Instance.new("Script", G2L["2c1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2c3"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2c3"]["TextWrapped"] = true;
G2L["2c3"]["BorderSizePixel"] = 3;
G2L["2c3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2c3"]["TextSize"] = 20;
G2L["2c3"]["TextScaled"] = true;
G2L["2c3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2c3"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2c3"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["2c3"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2c3"]["Text"] = [[k**pkidd toadroast remake]];
G2L["2c3"]["Position"] = UDim2.new(-0.31, 0, 8.10658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2c4"] = Instance.new("Script", G2L["2c3"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["2c5"] = Instance.new("LocalScript", G2L["2c3"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["2c6"] = Instance.new("RemoteEvent", G2L["2c3"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2c7"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2c7"]["TextWrapped"] = true;
G2L["2c7"]["BorderSizePixel"] = 3;
G2L["2c7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2c7"]["TextSize"] = 20;
G2L["2c7"]["TextScaled"] = true;
G2L["2c7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2c7"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2c7"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["2c7"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2c7"]["Text"] = [[Explodes]];
G2L["2c7"]["Position"] = UDim2.new(-0.31, 0, 8.90658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2c8"] = Instance.new("Script", G2L["2c7"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2c9"] = Instance.new("Script", G2L["2c7"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2ca"] = Instance.new("Script", G2L["2c7"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["2cb"] = Instance.new("LocalScript", G2L["2c7"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["2cc"] = Instance.new("RemoteEvent", G2L["2c7"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2cd"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2cd"]["TextWrapped"] = true;
G2L["2cd"]["BorderSizePixel"] = 3;
G2L["2cd"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2cd"]["TextSize"] = 20;
G2L["2cd"]["TextScaled"] = true;
G2L["2cd"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2cd"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2cd"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["2cd"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2cd"]["Text"] = [[Raining Tacos]];
G2L["2cd"]["Position"] = UDim2.new(0.15, 0, 8.10658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2ce"] = Instance.new("Script", G2L["2cd"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2cf"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2cf"]["TextWrapped"] = true;
G2L["2cf"]["BorderSizePixel"] = 3;
G2L["2cf"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2cf"]["TextSize"] = 20;
G2L["2cf"]["TextScaled"] = true;
G2L["2cf"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2cf"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2cf"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["2cf"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2cf"]["Text"] = [[Random Speed]];
G2L["2cf"]["Position"] = UDim2.new(0.15, 0, 8.90658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2d0"] = Instance.new("Script", G2L["2cf"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2d1"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2d1"]["TextWrapped"] = true;
G2L["2d1"]["BorderSizePixel"] = 3;
G2L["2d1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2d1"]["TextSize"] = 20;
G2L["2d1"]["TextScaled"] = true;
G2L["2d1"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2d1"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2d1"]["Size"] = UDim2.new(0, 48, 0, 30);
G2L["2d1"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2d1"]["Text"] = [[Spinning Particles 1]];
G2L["2d1"]["Position"] = UDim2.new(0.61, 0, 8.10658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2d2"] = Instance.new("Script", G2L["2d1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part
G2L["2d3"] = Instance.new("Part", G2L["2d2"]);
G2L["2d3"]["Anchored"] = true;
G2L["2d3"]["BottomSurface"] = Enum.SurfaceType.Smooth;
G2L["2d3"]["TopSurface"] = Enum.SurfaceType.Smooth;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d3"]["Size"] = Vector3.new(4, 1, 2);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d3"]["Color"] = Color3.fromRGB(101, 109, 27);
G2L["2d3"]["Rotation"] = Vector3.new(0, -20.213, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2d4"] = Instance.new("ParticleEmitter", G2L["2d3"]);
G2L["2d4"]["LightInfluence"] = 1;
G2L["2d4"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d4"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d4"]["Texture"] = [[rbxassetid://14405509678]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d4"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2d5"] = Instance.new("ParticleEmitter", G2L["2d3"]);
G2L["2d5"]["LightInfluence"] = 1;
G2L["2d5"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d5"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d5"]["Texture"] = [[rbxassetid://14405509678]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d5"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2d6"] = Instance.new("ParticleEmitter", G2L["2d3"]);
G2L["2d6"]["LightInfluence"] = 1;
G2L["2d6"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d6"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d6"]["Texture"] = [[rbxassetid://14405509678]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d6"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2d7"] = Instance.new("ParticleEmitter", G2L["2d3"]);
G2L["2d7"]["LightInfluence"] = 1;
G2L["2d7"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d7"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d7"]["Texture"] = [[rbxassetid://14405509678]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d7"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2d8"] = Instance.new("ParticleEmitter", G2L["2d3"]);
G2L["2d8"]["LightInfluence"] = 1;
G2L["2d8"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d8"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d8"]["Texture"] = [[rbxassetid://14405509678]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2d8"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2d9"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2d9"]["TextWrapped"] = true;
G2L["2d9"]["BorderSizePixel"] = 3;
G2L["2d9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2d9"]["TextSize"] = 20;
G2L["2d9"]["TextScaled"] = true;
G2L["2d9"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2d9"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2d9"]["Size"] = UDim2.new(0, 48, 0, 30);
G2L["2d9"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2d9"]["Text"] = [[Spinning Particles 2]];
G2L["2d9"]["Position"] = UDim2.new(0.61, 0, 8.90658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2da"] = Instance.new("Script", G2L["2d9"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part
G2L["2db"] = Instance.new("Part", G2L["2da"]);
G2L["2db"]["Anchored"] = true;
G2L["2db"]["BottomSurface"] = Enum.SurfaceType.Smooth;
G2L["2db"]["TopSurface"] = Enum.SurfaceType.Smooth;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2db"]["Size"] = Vector3.new(4, 1, 2);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2db"]["Color"] = Color3.fromRGB(101, 109, 27);
G2L["2db"]["Rotation"] = Vector3.new(0, -20.213, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2dc"] = Instance.new("ParticleEmitter", G2L["2db"]);
G2L["2dc"]["LightInfluence"] = 1;
G2L["2dc"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2dc"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2dc"]["Texture"] = [[rbxassetid://11426291165]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2dc"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2dd"] = Instance.new("ParticleEmitter", G2L["2db"]);
G2L["2dd"]["LightInfluence"] = 1;
G2L["2dd"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2dd"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2dd"]["Texture"] = [[rbxassetid://11426291165]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2dd"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2de"] = Instance.new("ParticleEmitter", G2L["2db"]);
G2L["2de"]["LightInfluence"] = 1;
G2L["2de"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2de"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2de"]["Texture"] = [[rbxassetid://11426291165]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2de"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2df"] = Instance.new("ParticleEmitter", G2L["2db"]);
G2L["2df"]["LightInfluence"] = 1;
G2L["2df"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2df"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2df"]["Texture"] = [[rbxassetid://11426291165]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2df"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2e0"] = Instance.new("ParticleEmitter", G2L["2db"]);
G2L["2e0"]["LightInfluence"] = 1;
G2L["2e0"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e0"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e0"]["Texture"] = [[rbxassetid://11426291165]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e0"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2e1"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2e1"]["TextWrapped"] = true;
G2L["2e1"]["BorderSizePixel"] = 3;
G2L["2e1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2e1"]["TextSize"] = 20;
G2L["2e1"]["TextScaled"] = true;
G2L["2e1"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2e1"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2e1"]["Size"] = UDim2.new(0, 48, 0, 30);
G2L["2e1"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2e1"]["Text"] = [[Spinning Particles 3]];
G2L["2e1"]["Position"] = UDim2.new(0.9, 0, 8.10658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2e2"] = Instance.new("Script", G2L["2e1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part
G2L["2e3"] = Instance.new("Part", G2L["2e2"]);
G2L["2e3"]["Anchored"] = true;
G2L["2e3"]["BottomSurface"] = Enum.SurfaceType.Smooth;
G2L["2e3"]["TopSurface"] = Enum.SurfaceType.Smooth;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e3"]["Size"] = Vector3.new(4, 1, 2);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e3"]["Color"] = Color3.fromRGB(101, 109, 27);
G2L["2e3"]["Rotation"] = Vector3.new(0, -20.213, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2e4"] = Instance.new("ParticleEmitter", G2L["2e3"]);
G2L["2e4"]["LightInfluence"] = 1;
G2L["2e4"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e4"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e4"]["Texture"] = [[rbxassetid://12168410006]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e4"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2e5"] = Instance.new("ParticleEmitter", G2L["2e3"]);
G2L["2e5"]["LightInfluence"] = 1;
G2L["2e5"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e5"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e5"]["Texture"] = [[rbxassetid://12168410006]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e5"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2e6"] = Instance.new("ParticleEmitter", G2L["2e3"]);
G2L["2e6"]["LightInfluence"] = 1;
G2L["2e6"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e6"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e6"]["Texture"] = [[rbxassetid://12168410006]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e6"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2e7"] = Instance.new("ParticleEmitter", G2L["2e3"]);
G2L["2e7"]["LightInfluence"] = 1;
G2L["2e7"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e7"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e7"]["Texture"] = [[rbxassetid://12168410006]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e7"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2e8"] = Instance.new("ParticleEmitter", G2L["2e3"]);
G2L["2e8"]["LightInfluence"] = 1;
G2L["2e8"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e8"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e8"]["Texture"] = [[rbxassetid://12168410006]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2e8"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2e9"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2e9"]["TextWrapped"] = true;
G2L["2e9"]["BorderSizePixel"] = 3;
G2L["2e9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2e9"]["TextSize"] = 20;
G2L["2e9"]["TextScaled"] = true;
G2L["2e9"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2e9"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2e9"]["Size"] = UDim2.new(0, 48, 0, 30);
G2L["2e9"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2e9"]["Text"] = [[Spinning Particles 4]];
G2L["2e9"]["Position"] = UDim2.new(0.9, 0, 8.88658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2ea"] = Instance.new("Script", G2L["2e9"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part
G2L["2eb"] = Instance.new("Part", G2L["2ea"]);
G2L["2eb"]["Anchored"] = true;
G2L["2eb"]["BottomSurface"] = Enum.SurfaceType.Smooth;
G2L["2eb"]["TopSurface"] = Enum.SurfaceType.Smooth;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2eb"]["Size"] = Vector3.new(4, 1, 2);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2eb"]["Color"] = Color3.fromRGB(101, 109, 27);
G2L["2eb"]["Rotation"] = Vector3.new(0, -20.213, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2ec"] = Instance.new("ParticleEmitter", G2L["2eb"]);
G2L["2ec"]["LightInfluence"] = 1;
G2L["2ec"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2ec"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2ec"]["Texture"] = [[rbxassetid://14405509678]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2ec"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2ed"] = Instance.new("ParticleEmitter", G2L["2eb"]);
G2L["2ed"]["LightInfluence"] = 1;
G2L["2ed"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2ed"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2ed"]["Texture"] = [[rbxassetid://14405509678]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2ed"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2ee"] = Instance.new("ParticleEmitter", G2L["2eb"]);
G2L["2ee"]["LightInfluence"] = 1;
G2L["2ee"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2ee"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2ee"]["Texture"] = [[rbxassetid://14405509678]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2ee"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2ef"] = Instance.new("ParticleEmitter", G2L["2eb"]);
G2L["2ef"]["LightInfluence"] = 1;
G2L["2ef"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2ef"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2ef"]["Texture"] = [[rbxassetid://14405509678]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2ef"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Part.ParticleEmitter
G2L["2f0"] = Instance.new("ParticleEmitter", G2L["2eb"]);
G2L["2f0"]["LightInfluence"] = 1;
G2L["2f0"]["SpreadAngle"] = Vector2.new(99, 99);
-- [ERROR] cannot convert Speed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2f0"]["Size"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 17),NumberSequenceKeypoint.new(1.000, 17)};
-- [ERROR] cannot convert RotSpeed, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2f0"]["Texture"] = [[rbxassetid://14405509678]];
-- [ERROR] cannot convert Rotation, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["2f0"]["Rate"] = 12.01;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2f1"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2f1"]["TextWrapped"] = true;
G2L["2f1"]["BorderSizePixel"] = 3;
G2L["2f1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2f1"]["TextSize"] = 20;
G2L["2f1"]["TextScaled"] = true;
G2L["2f1"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2f1"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2f1"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["2f1"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2f1"]["Text"] = [[Baseplate Generate]];
G2L["2f1"]["Position"] = UDim2.new(1.21, 0, 8.10658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2f2"] = Instance.new("Script", G2L["2f1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2f3"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2f3"]["TextWrapped"] = true;
G2L["2f3"]["BorderSizePixel"] = 3;
G2L["2f3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2f3"]["TextSize"] = 20;
G2L["2f3"]["TextScaled"] = true;
G2L["2f3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2f3"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2f3"]["Size"] = UDim2.new(0, 62, 0, 30);
G2L["2f3"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2f3"]["Text"] = [[funni skybox 3]];
G2L["2f3"]["Position"] = UDim2.new(0.16, 0, 3.00658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2f4"] = Instance.new("Script", G2L["2f3"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Images/Asian Head Funny  :3
G2L["2f5"] = Instance.new("Decal", G2L["2f4"]);
G2L["2f5"]["Name"] = [[Images/Asian Head Funny  :3]];
G2L["2f5"]["Texture"] = [[http://www.roblox.com/asset/?id=275216996]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.funny TF2 scout
G2L["2f6"] = Instance.new("Decal", G2L["2f4"]);
G2L["2f6"]["Name"] = [[funny TF2 scout]];
G2L["2f6"]["Texture"] = [[http://www.roblox.com/asset/?id=8683686271]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["2f7"] = Instance.new("LocalScript", G2L["2f3"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["2f8"] = Instance.new("RemoteEvent", G2L["2f3"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2f9"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2f9"]["TextWrapped"] = true;
G2L["2f9"]["BorderSizePixel"] = 3;
G2L["2f9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2f9"]["TextSize"] = 20;
G2L["2f9"]["TextScaled"] = true;
G2L["2f9"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2f9"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2f9"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["2f9"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2f9"]["Text"] = [[Shedletsky]];
G2L["2f9"]["Position"] = UDim2.new(-0.855, 0, 9.76658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.ServerEventHandler
G2L["2fa"] = Instance.new("Script", G2L["2f9"]);
G2L["2fa"]["Name"] = [[ServerEventHandler]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2fb"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2fb"]["TextWrapped"] = true;
G2L["2fb"]["BorderSizePixel"] = 3;
G2L["2fb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2fb"]["TextSize"] = 20;
G2L["2fb"]["TextScaled"] = true;
G2L["2fb"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2fb"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2fb"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["2fb"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2fb"]["Text"] = [[666]];
G2L["2fb"]["Position"] = UDim2.new(-0.385, 0, 9.76658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2fc"] = Instance.new("Script", G2L["2fb"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["2fd"] = Instance.new("TextButton", G2L["1f2"]);
G2L["2fd"]["TextWrapped"] = true;
G2L["2fd"]["BorderSizePixel"] = 3;
G2L["2fd"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2fd"]["TextSize"] = 20;
G2L["2fd"]["TextScaled"] = true;
G2L["2fd"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2fd"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2fd"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["2fd"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["2fd"]["Text"] = [[Zombie[R6]]];
G2L["2fd"]["Position"] = UDim2.new(0.08, 0, 9.76658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2fe"] = Instance.new("Script", G2L["2fd"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["2ff"] = Instance.new("Script", G2L["2fd"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["300"] = Instance.new("LocalScript", G2L["2fd"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["301"] = Instance.new("RemoteEvent", G2L["2fd"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.rc7
G2L["302"] = Instance.new("TextButton", G2L["1f2"]);
G2L["302"]["TextWrapped"] = true;
G2L["302"]["BorderSizePixel"] = 3;
G2L["302"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["302"]["TextSize"] = 20;
G2L["302"]["TextScaled"] = true;
G2L["302"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["302"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["302"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["302"]["Name"] = [[rc7]];
G2L["302"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["302"]["Text"] = [[Rc7]];
G2L["302"]["Position"] = UDim2.new(0.54, 0, 9.76658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.rc7.Script
G2L["303"] = Instance.new("Script", G2L["302"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.rc7.LocalScript
G2L["304"] = Instance.new("LocalScript", G2L["302"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.rc7.RemoteEvent
G2L["305"] = Instance.new("RemoteEvent", G2L["302"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.rc7
G2L["306"] = Instance.new("TextButton", G2L["1f2"]);
G2L["306"]["TextWrapped"] = true;
G2L["306"]["BorderSizePixel"] = 3;
G2L["306"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["306"]["TextSize"] = 20;
G2L["306"]["TextScaled"] = true;
G2L["306"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["306"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["306"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["306"]["Name"] = [[rc7]];
G2L["306"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["306"]["Text"] = [[Team Fat Jumpscare]];
G2L["306"]["Position"] = UDim2.new(1, 0, 9.76658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.rc7.Script
G2L["307"] = Instance.new("Script", G2L["306"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.rc7.LocalScript
G2L["308"] = Instance.new("LocalScript", G2L["306"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.rc7.RemoteEvent
G2L["309"] = Instance.new("RemoteEvent", G2L["306"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.rc7
G2L["30a"] = Instance.new("TextButton", G2L["1f2"]);
G2L["30a"]["TextWrapped"] = true;
G2L["30a"]["BorderSizePixel"] = 3;
G2L["30a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["30a"]["TextSize"] = 20;
G2L["30a"]["TextScaled"] = true;
G2L["30a"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["30a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["30a"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["30a"]["Name"] = [[rc7]];
G2L["30a"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["30a"]["Text"] = [[Kick All]];
G2L["30a"]["Position"] = UDim2.new(1.435, 0, 9.76658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.rc7.Script
G2L["30b"] = Instance.new("Script", G2L["30a"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.rc7.LocalScript
G2L["30c"] = Instance.new("LocalScript", G2L["30a"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.rc7.RemoteEvent
G2L["30d"] = Instance.new("RemoteEvent", G2L["30a"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["30e"] = Instance.new("TextButton", G2L["1f2"]);
G2L["30e"]["TextWrapped"] = true;
G2L["30e"]["BorderSizePixel"] = 3;
G2L["30e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["30e"]["TextSize"] = 20;
G2L["30e"]["TextScaled"] = true;
G2L["30e"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["30e"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["30e"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["30e"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["30e"]["Text"] = [[Spawn Dummy]];
G2L["30e"]["Position"] = UDim2.new(-0.855, 0, 10.56658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["30f"] = Instance.new("Script", G2L["30e"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy
G2L["310"] = Instance.new("Model", G2L["30f"]);
-- [ERROR] cannot convert WorldPivot, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["310"]["Name"] = [[Dummy]];
-- [ERROR] cannot convert PrimaryPart, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head
G2L["311"] = Instance.new("Part", G2L["310"]);
G2L["311"]["TopSurface"] = Enum.SurfaceType.Smooth;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["311"]["Locked"] = true;
G2L["311"]["Size"] = Vector3.new(2, 1, 1);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["311"]["Color"] = Color3.fromRGB(174, 174, 174);
G2L["311"]["Rotation"] = Vector3.new(0, -90, 0);
G2L["311"]["Name"] = [[Head]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.Mesh
G2L["312"] = Instance.new("SpecialMesh", G2L["311"]);
G2L["312"]["Scale"] = Vector3.new(1.25, 1.25, 1.25);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.HairAttachment
G2L["313"] = Instance.new("Attachment", G2L["311"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["313"]["Name"] = [[HairAttachment]];
G2L["313"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.HatAttachment
G2L["314"] = Instance.new("Attachment", G2L["311"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["314"]["Name"] = [[HatAttachment]];
G2L["314"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.FaceFrontAttachment
G2L["315"] = Instance.new("Attachment", G2L["311"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["315"]["Name"] = [[FaceFrontAttachment]];
G2L["315"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.FaceCenterAttachment
G2L["316"] = Instance.new("Attachment", G2L["311"]);
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["316"]["Name"] = [[FaceCenterAttachment]];
G2L["316"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.GettingUp
G2L["317"] = Instance.new("Sound", G2L["311"]);
G2L["317"]["RollOffMaxDistance"] = 150;
G2L["317"]["Volume"] = 0.65;
G2L["317"]["Name"] = [[GettingUp]];
G2L["317"]["RollOffMinDistance"] = 5;
G2L["317"]["SoundId"] = [[rbxasset://sounds/action_get_up.mp3]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.GettingUp.CharacterSoundEvent
G2L["318"] = Instance.new("RemoteEvent", G2L["317"]);
G2L["318"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.Died
G2L["319"] = Instance.new("Sound", G2L["311"]);
G2L["319"]["RollOffMaxDistance"] = 150;
G2L["319"]["Volume"] = 0.65;
G2L["319"]["Name"] = [[Died]];
G2L["319"]["RollOffMinDistance"] = 5;
G2L["319"]["SoundId"] = [[rbxasset://sounds/uuhhh.mp3]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.Died.CharacterSoundEvent
G2L["31a"] = Instance.new("RemoteEvent", G2L["319"]);
G2L["31a"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.FreeFalling
G2L["31b"] = Instance.new("Sound", G2L["311"]);
G2L["31b"]["TimePosition"] = 0.11429;
G2L["31b"]["RollOffMaxDistance"] = 150;
G2L["31b"]["Volume"] = 0.65;
G2L["31b"]["Looped"] = true;
G2L["31b"]["Name"] = [[FreeFalling]];
G2L["31b"]["RollOffMinDistance"] = 5;
G2L["31b"]["SoundId"] = [[rbxasset://sounds/action_falling.mp3]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.FreeFalling.CharacterSoundEvent
G2L["31c"] = Instance.new("RemoteEvent", G2L["31b"]);
G2L["31c"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.Jumping
G2L["31d"] = Instance.new("Sound", G2L["311"]);
G2L["31d"]["RollOffMaxDistance"] = 150;
G2L["31d"]["Volume"] = 0.65;
G2L["31d"]["Name"] = [[Jumping]];
G2L["31d"]["RollOffMinDistance"] = 5;
G2L["31d"]["SoundId"] = [[rbxasset://sounds/action_jump.mp3]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.Jumping.CharacterSoundEvent
G2L["31e"] = Instance.new("RemoteEvent", G2L["31d"]);
G2L["31e"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.Landing
G2L["31f"] = Instance.new("Sound", G2L["311"]);
G2L["31f"]["RollOffMaxDistance"] = 150;
G2L["31f"]["Volume"] = 0.65;
G2L["31f"]["Name"] = [[Landing]];
G2L["31f"]["RollOffMinDistance"] = 5;
G2L["31f"]["SoundId"] = [[rbxasset://sounds/action_jump_land.mp3]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.Landing.CharacterSoundEvent
G2L["320"] = Instance.new("RemoteEvent", G2L["31f"]);
G2L["320"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.Splash
G2L["321"] = Instance.new("Sound", G2L["311"]);
G2L["321"]["RollOffMaxDistance"] = 150;
G2L["321"]["Volume"] = 0.65;
G2L["321"]["Name"] = [[Splash]];
G2L["321"]["RollOffMinDistance"] = 5;
G2L["321"]["SoundId"] = [[rbxasset://sounds/impact_water.mp3]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.Splash.CharacterSoundEvent
G2L["322"] = Instance.new("RemoteEvent", G2L["321"]);
G2L["322"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.Running
G2L["323"] = Instance.new("Sound", G2L["311"]);
G2L["323"]["TimePosition"] = 0.83446;
G2L["323"]["PlaybackSpeed"] = 1.85;
G2L["323"]["RollOffMaxDistance"] = 150;
G2L["323"]["Volume"] = 0.65;
G2L["323"]["Looped"] = true;
G2L["323"]["Name"] = [[Running]];
G2L["323"]["RollOffMinDistance"] = 5;
G2L["323"]["SoundId"] = [[rbxasset://sounds/action_footsteps_plastic.mp3]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.Running.CharacterSoundEvent
G2L["324"] = Instance.new("RemoteEvent", G2L["323"]);
G2L["324"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.Swimming
G2L["325"] = Instance.new("Sound", G2L["311"]);
G2L["325"]["PlaybackSpeed"] = 1.6;
G2L["325"]["RollOffMaxDistance"] = 150;
G2L["325"]["Volume"] = 0.65;
G2L["325"]["Looped"] = true;
G2L["325"]["Name"] = [[Swimming]];
G2L["325"]["RollOffMinDistance"] = 5;
G2L["325"]["SoundId"] = [[rbxasset://sounds/action_swim.mp3]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.Swimming.CharacterSoundEvent
G2L["326"] = Instance.new("RemoteEvent", G2L["325"]);
G2L["326"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.Climbing
G2L["327"] = Instance.new("Sound", G2L["311"]);
G2L["327"]["RollOffMaxDistance"] = 150;
G2L["327"]["Volume"] = 0.65;
G2L["327"]["Looped"] = true;
G2L["327"]["Name"] = [[Climbing]];
G2L["327"]["RollOffMinDistance"] = 5;
G2L["327"]["SoundId"] = [[rbxasset://sounds/action_footsteps_plastic.mp3]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.Climbing.CharacterSoundEvent
G2L["328"] = Instance.new("RemoteEvent", G2L["327"]);
G2L["328"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Head.face
G2L["329"] = Instance.new("Decal", G2L["311"]);
G2L["329"]["Name"] = [[face]];
G2L["329"]["Texture"] = [[rbxassetid://144080495]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Torso
G2L["32a"] = Instance.new("Part", G2L["310"]);
G2L["32a"]["RightSurface"] = Enum.SurfaceType.Weld;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["32a"]["Locked"] = true;
G2L["32a"]["Size"] = Vector3.new(2, 2, 1);
G2L["32a"]["LeftSurface"] = Enum.SurfaceType.Weld;
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["32a"]["Color"] = Color3.fromRGB(174, 174, 174);
G2L["32a"]["Rotation"] = Vector3.new(0, -90, 0);
G2L["32a"]["Name"] = [[Torso]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Torso.roblox
G2L["32b"] = Instance.new("Decal", G2L["32a"]);
G2L["32b"]["Name"] = [[roblox]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Torso.NeckAttachment
G2L["32c"] = Instance.new("Attachment", G2L["32a"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["32c"]["Name"] = [[NeckAttachment]];
G2L["32c"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Torso.BodyFrontAttachment
G2L["32d"] = Instance.new("Attachment", G2L["32a"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["32d"]["Name"] = [[BodyFrontAttachment]];
G2L["32d"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Torso.BodyBackAttachment
G2L["32e"] = Instance.new("Attachment", G2L["32a"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["32e"]["Name"] = [[BodyBackAttachment]];
G2L["32e"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Torso.LeftCollarAttachment
G2L["32f"] = Instance.new("Attachment", G2L["32a"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["32f"]["Name"] = [[LeftCollarAttachment]];
G2L["32f"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Torso.RightCollarAttachment
G2L["330"] = Instance.new("Attachment", G2L["32a"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["330"]["Name"] = [[RightCollarAttachment]];
G2L["330"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Torso.WaistFrontAttachment
G2L["331"] = Instance.new("Attachment", G2L["32a"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["331"]["Name"] = [[WaistFrontAttachment]];
G2L["331"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Torso.WaistCenterAttachment
G2L["332"] = Instance.new("Attachment", G2L["32a"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["332"]["Name"] = [[WaistCenterAttachment]];
G2L["332"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Torso.WaistBackAttachment
G2L["333"] = Instance.new("Attachment", G2L["32a"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["333"]["Name"] = [[WaistBackAttachment]];
G2L["333"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Torso.Right Shoulder
G2L["334"] = Instance.new("Motor6D", G2L["32a"]);
-- [ERROR] cannot convert Part1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["334"]["MaxVelocity"] = 0.1;
-- [ERROR] cannot convert C1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert C0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["334"]["Name"] = [[Right Shoulder]];
-- [ERROR] cannot convert Part0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Torso.Left Shoulder
G2L["335"] = Instance.new("Motor6D", G2L["32a"]);
-- [ERROR] cannot convert Part1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["335"]["MaxVelocity"] = 0.1;
-- [ERROR] cannot convert C1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert C0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["335"]["Name"] = [[Left Shoulder]];
-- [ERROR] cannot convert Part0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Torso.Right Hip
G2L["336"] = Instance.new("Motor6D", G2L["32a"]);
-- [ERROR] cannot convert Part1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["336"]["MaxVelocity"] = 0.1;
-- [ERROR] cannot convert C1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert C0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["336"]["Name"] = [[Right Hip]];
-- [ERROR] cannot convert Part0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Torso.Left Hip
G2L["337"] = Instance.new("Motor6D", G2L["32a"]);
-- [ERROR] cannot convert Part1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["337"]["MaxVelocity"] = 0.1;
-- [ERROR] cannot convert C1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert C0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["337"]["Name"] = [[Left Hip]];
-- [ERROR] cannot convert Part0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Torso.Neck
G2L["338"] = Instance.new("Motor6D", G2L["32a"]);
-- [ERROR] cannot convert Part1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["338"]["MaxVelocity"] = 0.1;
-- [ERROR] cannot convert C1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert C0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["338"]["Name"] = [[Neck]];
-- [ERROR] cannot convert Part0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Left Arm
G2L["339"] = Instance.new("Part", G2L["310"]);
G2L["339"]["CanCollide"] = false;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["339"]["Locked"] = true;
G2L["339"]["Size"] = Vector3.new(1, 2, 1);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["339"]["Color"] = Color3.fromRGB(174, 174, 174);
G2L["339"]["Rotation"] = Vector3.new(0, -90, 0);
G2L["339"]["Name"] = [[Left Arm]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Left Arm.LeftShoulderAttachment
G2L["33a"] = Instance.new("Attachment", G2L["339"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["33a"]["Name"] = [[LeftShoulderAttachment]];
G2L["33a"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Left Arm.LeftGripAttachment
G2L["33b"] = Instance.new("Attachment", G2L["339"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["33b"]["Name"] = [[LeftGripAttachment]];
G2L["33b"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Right Arm
G2L["33c"] = Instance.new("Part", G2L["310"]);
G2L["33c"]["CanCollide"] = false;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["33c"]["Locked"] = true;
G2L["33c"]["Size"] = Vector3.new(1, 2, 1);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["33c"]["Color"] = Color3.fromRGB(174, 174, 174);
G2L["33c"]["Rotation"] = Vector3.new(0, -90, 0);
G2L["33c"]["Name"] = [[Right Arm]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Right Arm.RightShoulderAttachment
G2L["33d"] = Instance.new("Attachment", G2L["33c"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["33d"]["Name"] = [[RightShoulderAttachment]];
G2L["33d"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Right Arm.RightGripAttachment
G2L["33e"] = Instance.new("Attachment", G2L["33c"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["33e"]["Name"] = [[RightGripAttachment]];
G2L["33e"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Left Leg
G2L["33f"] = Instance.new("Part", G2L["310"]);
G2L["33f"]["BottomSurface"] = Enum.SurfaceType.Smooth;
G2L["33f"]["CanCollide"] = false;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["33f"]["Locked"] = true;
G2L["33f"]["Size"] = Vector3.new(1, 2, 1);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["33f"]["Color"] = Color3.fromRGB(174, 174, 174);
G2L["33f"]["Rotation"] = Vector3.new(0, -90, 0);
G2L["33f"]["Name"] = [[Left Leg]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Left Leg.LeftFootAttachment
G2L["340"] = Instance.new("Attachment", G2L["33f"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["340"]["Name"] = [[LeftFootAttachment]];
G2L["340"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Right Leg
G2L["341"] = Instance.new("Part", G2L["310"]);
G2L["341"]["BottomSurface"] = Enum.SurfaceType.Smooth;
G2L["341"]["CanCollide"] = false;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["341"]["Locked"] = true;
G2L["341"]["Size"] = Vector3.new(1, 2, 1);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["341"]["Color"] = Color3.fromRGB(174, 174, 174);
G2L["341"]["Rotation"] = Vector3.new(0, -90, 0);
G2L["341"]["Name"] = [[Right Leg]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Right Leg.RightFootAttachment
G2L["342"] = Instance.new("Attachment", G2L["341"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["342"]["Name"] = [[RightFootAttachment]];
G2L["342"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Humanoid
G2L["343"] = Instance.new("Humanoid", G2L["310"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Humanoid.Animator
G2L["344"] = Instance.new("Animator", G2L["343"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Humanoid.Respawn
G2L["345"] = Instance.new("Script", G2L["343"]);
G2L["345"]["Name"] = [[Respawn]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Humanoid.Jump
G2L["346"] = Instance.new("LocalScript", G2L["343"]);
G2L["346"]["Name"] = [[Jump]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.HumanoidRootPart
G2L["347"] = Instance.new("Part", G2L["310"]);
G2L["347"]["BottomSurface"] = Enum.SurfaceType.Smooth;
G2L["347"]["CanCollide"] = false;
G2L["347"]["Transparency"] = 1;
G2L["347"]["TopSurface"] = Enum.SurfaceType.Smooth;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["347"]["Locked"] = true;
G2L["347"]["Size"] = Vector3.new(2, 2, 1);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["347"]["Color"] = Color3.fromRGB(174, 174, 174);
G2L["347"]["Rotation"] = Vector3.new(0, -90, 0);
G2L["347"]["Name"] = [[HumanoidRootPart]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.HumanoidRootPart.RootAttachment
G2L["348"] = Instance.new("Attachment", G2L["347"]);
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["348"]["Name"] = [[RootAttachment]];
G2L["348"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.HumanoidRootPart.RootJoint
G2L["349"] = Instance.new("Motor6D", G2L["347"]);
-- [ERROR] cannot convert Part1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["349"]["MaxVelocity"] = 0.1;
-- [ERROR] cannot convert C1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert C0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["349"]["Name"] = [[RootJoint]];
-- [ERROR] cannot convert Part0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Health
G2L["34a"] = Instance.new("Script", G2L["310"]);
G2L["34a"]["Name"] = [[Health]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate
G2L["34b"] = Instance.new("LocalScript", G2L["310"]);
G2L["34b"]["Name"] = [[Animate]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.idle
G2L["34c"] = Instance.new("StringValue", G2L["34b"]);
G2L["34c"]["Name"] = [[idle]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.idle.Animation1
G2L["34d"] = Instance.new("Animation", G2L["34c"]);
G2L["34d"]["Name"] = [[Animation1]];
G2L["34d"]["AnimationId"] = [[http://www.roblox.com/asset/?id=180435571]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.idle.Animation1.Weight
G2L["34e"] = Instance.new("NumberValue", G2L["34d"]);
G2L["34e"]["Name"] = [[Weight]];
G2L["34e"]["Value"] = 9;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.idle.Animation2
G2L["34f"] = Instance.new("Animation", G2L["34c"]);
G2L["34f"]["Name"] = [[Animation2]];
G2L["34f"]["AnimationId"] = [[http://www.roblox.com/asset/?id=180435792]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.idle.Animation2.Weight
G2L["350"] = Instance.new("NumberValue", G2L["34f"]);
G2L["350"]["Name"] = [[Weight]];
G2L["350"]["Value"] = 1;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.walk
G2L["351"] = Instance.new("StringValue", G2L["34b"]);
G2L["351"]["Name"] = [[walk]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.walk.WalkAnim
G2L["352"] = Instance.new("Animation", G2L["351"]);
G2L["352"]["Name"] = [[WalkAnim]];
G2L["352"]["AnimationId"] = [[http://www.roblox.com/asset/?id=180426354]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.run
G2L["353"] = Instance.new("StringValue", G2L["34b"]);
G2L["353"]["Name"] = [[run]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.run.RunAnim
G2L["354"] = Instance.new("Animation", G2L["353"]);
G2L["354"]["Name"] = [[RunAnim]];
G2L["354"]["AnimationId"] = [[http://www.roblox.com/asset/?id=180426354]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.jump
G2L["355"] = Instance.new("StringValue", G2L["34b"]);
G2L["355"]["Name"] = [[jump]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.jump.JumpAnim
G2L["356"] = Instance.new("Animation", G2L["355"]);
G2L["356"]["Name"] = [[JumpAnim]];
G2L["356"]["AnimationId"] = [[http://www.roblox.com/asset/?id=125750702]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.climb
G2L["357"] = Instance.new("StringValue", G2L["34b"]);
G2L["357"]["Name"] = [[climb]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.climb.ClimbAnim
G2L["358"] = Instance.new("Animation", G2L["357"]);
G2L["358"]["Name"] = [[ClimbAnim]];
G2L["358"]["AnimationId"] = [[http://www.roblox.com/asset/?id=180436334]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.toolnone
G2L["359"] = Instance.new("StringValue", G2L["34b"]);
G2L["359"]["Name"] = [[toolnone]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.toolnone.ToolNoneAnim
G2L["35a"] = Instance.new("Animation", G2L["359"]);
G2L["35a"]["Name"] = [[ToolNoneAnim]];
G2L["35a"]["AnimationId"] = [[http://www.roblox.com/asset/?id=182393478]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.fall
G2L["35b"] = Instance.new("StringValue", G2L["34b"]);
G2L["35b"]["Name"] = [[fall]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.fall.FallAnim
G2L["35c"] = Instance.new("Animation", G2L["35b"]);
G2L["35c"]["Name"] = [[FallAnim]];
G2L["35c"]["AnimationId"] = [[http://www.roblox.com/asset/?id=180436148]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.sit
G2L["35d"] = Instance.new("StringValue", G2L["34b"]);
G2L["35d"]["Name"] = [[sit]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.sit.SitAnim
G2L["35e"] = Instance.new("Animation", G2L["35d"]);
G2L["35e"]["Name"] = [[SitAnim]];
G2L["35e"]["AnimationId"] = [[http://www.roblox.com/asset/?id=178130996]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate.ScaleDampeningPercent
G2L["35f"] = Instance.new("NumberValue", G2L["34b"]);
G2L["35f"]["Name"] = [[ScaleDampeningPercent]];
G2L["35f"]["Value"] = 0.4;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Body Colors
G2L["360"] = Instance.new("BodyColors", G2L["310"]);
-- [ERROR] cannot convert RightLegColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert LeftLegColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["360"]["HeadColor3"] = Color3.fromRGB(174, 174, 174);
G2L["360"]["LeftLegColor3"] = Color3.fromRGB(174, 174, 174);
-- [ERROR] cannot convert LeftArmColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert RightArmColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["360"]["LeftArmColor3"] = Color3.fromRGB(174, 174, 174);
-- [ERROR] cannot convert HeadColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert TorsoColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["360"]["TorsoColor3"] = Color3.fromRGB(174, 174, 174);
G2L["360"]["RightLegColor3"] = Color3.fromRGB(174, 174, 174);
G2L["360"]["RightArmColor3"] = Color3.fromRGB(174, 174, 174);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky
G2L["361"] = Instance.new("TextButton", G2L["1f2"]);
G2L["361"]["TextWrapped"] = true;
G2L["361"]["BorderSizePixel"] = 3;
G2L["361"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["361"]["TextSize"] = 20;
G2L["361"]["TextScaled"] = true;
G2L["361"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["361"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["361"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["361"]["Name"] = [[sky]];
G2L["361"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["361"]["Text"] = [[Make Sky Better]];
G2L["361"]["Position"] = UDim2.new(-0.385, 0, 10.56658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky.Script
G2L["362"] = Instance.new("Script", G2L["361"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky.Script.yaw
G2L["363"] = Instance.new("Model", G2L["362"]);
-- [ERROR] cannot convert WorldPivot, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["363"]["Name"] = [[yaw]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky.Script.yaw.Graphics  Script- ServerScriptService
G2L["364"] = Instance.new("Script", G2L["363"]);
G2L["364"]["Name"] = [[Graphics  Script- ServerScriptService]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky.Script.yaw.Thumbnail (Delete)
G2L["365"] = Instance.new("Model", G2L["363"]);
-- [ERROR] cannot convert WorldPivot, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["365"]["Name"] = [[Thumbnail (Delete)]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky.Script.yaw.Thumbnail (Delete).Part
G2L["366"] = Instance.new("Part", G2L["365"]);
G2L["366"]["BottomSurface"] = Enum.SurfaceType.Smooth;
G2L["366"]["CanCollide"] = false;
G2L["366"]["CanQuery"] = false;
G2L["366"]["TopSurface"] = Enum.SurfaceType.Smooth;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["366"]["Material"] = Enum.Material.Neon;
G2L["366"]["Size"] = Vector3.new(3, 3, 0.1);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["366"]["Color"] = Color3.fromRGB(92, 94, 106);
G2L["366"]["CanTouch"] = false;
G2L["366"]["Rotation"] = Vector3.new(0, 69.787, 0);
G2L["366"]["CastShadow"] = false;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky.Script.yaw.Thumbnail (Delete).Part
G2L["367"] = Instance.new("Part", G2L["365"]);
G2L["367"]["BottomSurface"] = Enum.SurfaceType.Smooth;
G2L["367"]["CanCollide"] = false;
G2L["367"]["Transparency"] = 1;
G2L["367"]["CanQuery"] = false;
G2L["367"]["TopSurface"] = Enum.SurfaceType.Smooth;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["367"]["Material"] = Enum.Material.Neon;
G2L["367"]["Size"] = Vector3.new(2.4, 2.4, 0.001);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["367"]["Color"] = Color3.fromRGB(92, 94, 106);
G2L["367"]["CanTouch"] = false;
G2L["367"]["Rotation"] = Vector3.new(0, 69.787, 0);
G2L["367"]["CastShadow"] = false;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky.Script.yaw.Thumbnail (Delete).Part.Decal
G2L["368"] = Instance.new("Decal", G2L["367"]);
G2L["368"]["Texture"] = [[rbxassetid://7733975185]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky.Script.yaw.Thumbnail (Delete).Part.PointLight
G2L["369"] = Instance.new("PointLight", G2L["367"]);
G2L["369"]["Range"] = 6;
G2L["369"]["Brightness"] = 3;


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky.Script.yaw.shamsterky
G2L["36a"] = Instance.new("TextButton", G2L["363"]);
G2L["36a"]["TextWrapped"] = true;
G2L["36a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["36a"]["TextSize"] = 14;
G2L["36a"]["TextScaled"] = true;
G2L["36a"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["36a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["36a"]["Size"] = UDim2.new(0, 99, 0, 39);
G2L["36a"]["Name"] = [[shamsterky]];
G2L["36a"]["BorderColor3"] = Color3.fromRGB(0, 54, 12);
G2L["36a"]["Text"] = [[funny hamster doing melting a funny thing skybox]];
G2L["36a"]["Position"] = UDim2.new(-0.87059, 0, -13.92857, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky.Script.yaw.shamsterky.Script
G2L["36b"] = Instance.new("Script", G2L["36a"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky
G2L["36c"] = Instance.new("TextButton", G2L["1f2"]);
G2L["36c"]["TextWrapped"] = true;
G2L["36c"]["BorderSizePixel"] = 3;
G2L["36c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["36c"]["TextSize"] = 20;
G2L["36c"]["TextScaled"] = true;
G2L["36c"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["36c"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["36c"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["36c"]["Name"] = [[sky]];
G2L["36c"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["36c"]["Text"] = [[burning lgbtq flag skybox]];
G2L["36c"]["Position"] = UDim2.new(0.08, 0, 10.56658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky.Script
G2L["36d"] = Instance.new("Script", G2L["36c"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky
G2L["36e"] = Instance.new("TextButton", G2L["1f2"]);
G2L["36e"]["TextWrapped"] = true;
G2L["36e"]["BorderSizePixel"] = 3;
G2L["36e"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["36e"]["TextSize"] = 20;
G2L["36e"]["TextScaled"] = true;
G2L["36e"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["36e"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["36e"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["36e"]["Name"] = [[sky]];
G2L["36e"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["36e"]["Text"] = [[pull out funny german flag skybox]];
G2L["36e"]["Position"] = UDim2.new(0.54, 0, 10.56658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky.Script
G2L["36f"] = Instance.new("Script", G2L["36e"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky
G2L["370"] = Instance.new("TextButton", G2L["1f2"]);
G2L["370"]["TextWrapped"] = true;
G2L["370"]["BorderSizePixel"] = 3;
G2L["370"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["370"]["TextSize"] = 20;
G2L["370"]["TextScaled"] = true;
G2L["370"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["370"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["370"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["370"]["Name"] = [[sky]];
G2L["370"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["370"]["Text"] = [[Ambatukam Skybox]];
G2L["370"]["Position"] = UDim2.new(1, 0, 10.56658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky.Script
G2L["371"] = Instance.new("Script", G2L["370"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky
G2L["372"] = Instance.new("TextButton", G2L["1f2"]);
G2L["372"]["TextWrapped"] = true;
G2L["372"]["BorderSizePixel"] = 3;
G2L["372"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["372"]["TextSize"] = 20;
G2L["372"]["TextScaled"] = true;
G2L["372"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["372"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["372"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["372"]["Name"] = [[sky]];
G2L["372"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["372"]["Text"] = [[DreamyBull All]];
G2L["372"]["Position"] = UDim2.new(1.435, 0, 10.56658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky.Script
G2L["373"] = Instance.new("Script", G2L["372"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.sky.RemoteEvent
G2L["374"] = Instance.new("RemoteEvent", G2L["372"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["375"] = Instance.new("TextButton", G2L["1f2"]);
G2L["375"]["TextWrapped"] = true;
G2L["375"]["BorderSizePixel"] = 3;
G2L["375"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["375"]["TextSize"] = 20;
G2L["375"]["TextScaled"] = true;
G2L["375"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["375"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["375"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["375"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["375"]["Text"] = [[Opgui v1.5]];
G2L["375"]["Position"] = UDim2.new(-0.855, 0, 11.36658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["376"] = Instance.new("Script", G2L["375"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["377"] = Instance.new("LocalScript", G2L["375"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["378"] = Instance.new("RemoteEvent", G2L["375"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["379"] = Instance.new("TextButton", G2L["1f2"]);
G2L["379"]["TextWrapped"] = true;
G2L["379"]["BorderSizePixel"] = 3;
G2L["379"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["379"]["TextSize"] = 20;
G2L["379"]["TextScaled"] = true;
G2L["379"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["379"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["379"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["379"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["379"]["Text"] = [[Project A1 gui]];
G2L["379"]["Position"] = UDim2.new(-0.39, 0, 11.36658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["37a"] = Instance.new("Script", G2L["379"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["37b"] = Instance.new("LocalScript", G2L["379"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["37c"] = Instance.new("RemoteEvent", G2L["379"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["37d"] = Instance.new("TextButton", G2L["1f2"]);
G2L["37d"]["TextWrapped"] = true;
G2L["37d"]["BorderSizePixel"] = 3;
G2L["37d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["37d"]["TextSize"] = 20;
G2L["37d"]["TextScaled"] = true;
G2L["37d"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["37d"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["37d"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["37d"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["37d"]["Text"] = [[l*ckgui v3]];
G2L["37d"]["Position"] = UDim2.new(0.08, 0, 11.36658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["37e"] = Instance.new("Script", G2L["37d"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["37f"] = Instance.new("LocalScript", G2L["37d"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["380"] = Instance.new("RemoteEvent", G2L["37d"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["381"] = Instance.new("TextButton", G2L["1f2"]);
G2L["381"]["TextWrapped"] = true;
G2L["381"]["BorderSizePixel"] = 3;
G2L["381"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["381"]["TextSize"] = 20;
G2L["381"]["TextScaled"] = true;
G2L["381"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["381"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["381"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["381"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["381"]["Text"] = [[tubers gui]];
G2L["381"]["Position"] = UDim2.new(0.54, 0, 11.36658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["382"] = Instance.new("Script", G2L["381"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["383"] = Instance.new("LocalScript", G2L["381"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["384"] = Instance.new("RemoteEvent", G2L["381"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["385"] = Instance.new("TextButton", G2L["1f2"]);
G2L["385"]["TextWrapped"] = true;
G2L["385"]["BorderSizePixel"] = 3;
G2L["385"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["385"]["TextSize"] = 20;
G2L["385"]["TextScaled"] = true;
G2L["385"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["385"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["385"]["Size"] = UDim2.new(0, 78, 0, 30);
G2L["385"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["385"]["Text"] = [[H1GUI v3]];
G2L["385"]["Position"] = UDim2.new(1, 0, 11.36658, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["386"] = Instance.new("Script", G2L["385"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
G2L["387"] = Instance.new("LocalScript", G2L["385"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.RemoteEvent
G2L["388"] = Instance.new("RemoteEvent", G2L["385"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel
G2L["389"] = Instance.new("TextLabel", G2L["1f0"]);
G2L["389"]["TextWrapped"] = true;
G2L["389"]["BorderSizePixel"] = 3;
G2L["389"]["TextSize"] = 20;
G2L["389"]["TextScaled"] = true;
G2L["389"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["389"]["FontFace"] = Font.new([[rbxasset://fonts/families/FredokaOne.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["389"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["389"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["389"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["389"]["Text"] = [[Music]];
G2L["389"]["Position"] = UDim2.new(0.32872, 0, 0.71492, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["38a"] = Instance.new("TextButton", G2L["389"]);
G2L["38a"]["TextWrapped"] = true;
G2L["38a"]["BorderSizePixel"] = 3;
G2L["38a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["38a"]["TextSize"] = 14;
G2L["38a"]["TextScaled"] = true;
G2L["38a"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["38a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["38a"]["Size"] = UDim2.new(0, 112, 0, 34);
G2L["38a"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["38a"]["Text"] = [[BloodPop]];
G2L["38a"]["Position"] = UDim2.new(-0.815, 0, 1.4, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["38b"] = Instance.new("Script", G2L["38a"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["38c"] = Instance.new("TextButton", G2L["389"]);
G2L["38c"]["TextWrapped"] = true;
G2L["38c"]["BorderSizePixel"] = 3;
G2L["38c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["38c"]["TextSize"] = 14;
G2L["38c"]["TextScaled"] = true;
G2L["38c"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["38c"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["38c"]["Size"] = UDim2.new(0, 112, 0, 34);
G2L["38c"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["38c"]["Text"] = [[Rain Sound]];
G2L["38c"]["Position"] = UDim2.new(-0.14, 0, 1.4, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["38d"] = Instance.new("Script", G2L["38c"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Rain Sound Effect
G2L["38e"] = Instance.new("Sound", G2L["38d"]);
G2L["38e"]["Name"] = [[Rain Sound Effect]];
G2L["38e"]["SoundId"] = [[rbxassetid://9064263922]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["38f"] = Instance.new("TextButton", G2L["389"]);
G2L["38f"]["TextWrapped"] = true;
G2L["38f"]["BorderSizePixel"] = 3;
G2L["38f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["38f"]["TextSize"] = 14;
G2L["38f"]["TextScaled"] = true;
G2L["38f"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["38f"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["38f"]["Size"] = UDim2.new(0, 64, 0, 34);
G2L["38f"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["38f"]["Text"] = [[Phonk 1]];
G2L["38f"]["Position"] = UDim2.new(0.495, 0, 1.4, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["390"] = Instance.new("Script", G2L["38f"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Rain Sound Effect
G2L["391"] = Instance.new("Sound", G2L["390"]);
G2L["391"]["Name"] = [[Rain Sound Effect]];
G2L["391"]["SoundId"] = [[rbxassetid://9064263922]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Phonk Vol. 2 - The Final Phonk
G2L["392"] = Instance.new("Sound", G2L["390"]);
G2L["392"]["Name"] = [[Phonk Vol. 2 - The Final Phonk]];
G2L["392"]["SoundId"] = [[rbxassetid://14145620056]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["393"] = Instance.new("TextButton", G2L["389"]);
G2L["393"]["TextWrapped"] = true;
G2L["393"]["BorderSizePixel"] = 3;
G2L["393"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["393"]["TextSize"] = 14;
G2L["393"]["TextScaled"] = true;
G2L["393"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["393"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["393"]["Size"] = UDim2.new(0, 63, 0, 34);
G2L["393"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["393"]["Text"] = [[Phonk 2]];
G2L["393"]["Position"] = UDim2.new(0.855, 0, 1.4, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["394"] = Instance.new("Script", G2L["393"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Rain Sound Effect
G2L["395"] = Instance.new("Sound", G2L["394"]);
G2L["395"]["Name"] = [[Rain Sound Effect]];
G2L["395"]["SoundId"] = [[rbxassetid://9064263922]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Phonk Vol. 2 - The Final Phonk
G2L["396"] = Instance.new("Sound", G2L["394"]);
G2L["396"]["Name"] = [[Phonk Vol. 2 - The Final Phonk]];
G2L["396"]["SoundId"] = [[rbxassetid://14145620056]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Phonk Vol. 2 - No Lights
G2L["397"] = Instance.new("Sound", G2L["394"]);
G2L["397"]["Name"] = [[Phonk Vol. 2 - No Lights]];
G2L["397"]["SoundId"] = [[rbxassetid://14145623221]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["398"] = Instance.new("TextButton", G2L["389"]);
G2L["398"]["TextWrapped"] = true;
G2L["398"]["BorderSizePixel"] = 3;
G2L["398"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["398"]["TextSize"] = 14;
G2L["398"]["TextScaled"] = true;
G2L["398"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["398"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["398"]["Size"] = UDim2.new(0, 64, 0, 34);
G2L["398"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["398"]["Text"] = [[Phonk 3]];
G2L["398"]["Position"] = UDim2.new(0.495, 0, 2.28, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["399"] = Instance.new("Script", G2L["398"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Rain Sound Effect
G2L["39a"] = Instance.new("Sound", G2L["399"]);
G2L["39a"]["Name"] = [[Rain Sound Effect]];
G2L["39a"]["SoundId"] = [[rbxassetid://9064263922]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Phonk Vol. 2 - The Final Phonk
G2L["39b"] = Instance.new("Sound", G2L["399"]);
G2L["39b"]["Name"] = [[Phonk Vol. 2 - The Final Phonk]];
G2L["39b"]["SoundId"] = [[rbxassetid://14145620056]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Phonk Vol. 2 - Distorted
G2L["39c"] = Instance.new("Sound", G2L["399"]);
G2L["39c"]["Name"] = [[Phonk Vol. 2 - Distorted]];
G2L["39c"]["SoundId"] = [[rbxassetid://14145625078]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["39d"] = Instance.new("TextButton", G2L["389"]);
G2L["39d"]["TextWrapped"] = true;
G2L["39d"]["BorderSizePixel"] = 3;
G2L["39d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["39d"]["TextSize"] = 14;
G2L["39d"]["TextScaled"] = true;
G2L["39d"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["39d"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["39d"]["Size"] = UDim2.new(0, 64, 0, 34);
G2L["39d"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["39d"]["Text"] = [[short phonk]];
G2L["39d"]["Position"] = UDim2.new(0.855, 0, 2.28, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["39e"] = Instance.new("Script", G2L["39d"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Rain Sound Effect
G2L["39f"] = Instance.new("Sound", G2L["39e"]);
G2L["39f"]["Name"] = [[Rain Sound Effect]];
G2L["39f"]["SoundId"] = [[rbxassetid://9064263922]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Phonk Vol. 2 - The Final Phonk
G2L["3a0"] = Instance.new("Sound", G2L["39e"]);
G2L["3a0"]["Name"] = [[Phonk Vol. 2 - The Final Phonk]];
G2L["3a0"]["SoundId"] = [[rbxassetid://14145620056]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Phonk Vol. 2 - Distorted
G2L["3a1"] = Instance.new("Sound", G2L["39e"]);
G2L["3a1"]["Name"] = [[Phonk Vol. 2 - Distorted]];
G2L["3a1"]["SoundId"] = [[rbxassetid://14145625078]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["3a2"] = Instance.new("TextButton", G2L["389"]);
G2L["3a2"]["TextWrapped"] = true;
G2L["3a2"]["BorderSizePixel"] = 3;
G2L["3a2"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3a2"]["TextSize"] = 14;
G2L["3a2"]["TextScaled"] = true;
G2L["3a2"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3a2"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3a2"]["Size"] = UDim2.new(0, 112, 0, 34);
G2L["3a2"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3a2"]["Text"] = [[You Are Now Entering The World Of k**pkidd]];
G2L["3a2"]["Position"] = UDim2.new(1.28, 0, 1.4, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["3a3"] = Instance.new("Script", G2L["3a2"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Rain Sound Effect
G2L["3a4"] = Instance.new("Sound", G2L["3a3"]);
G2L["3a4"]["Name"] = [[Rain Sound Effect]];
G2L["3a4"]["SoundId"] = [[rbxassetid://9064263922]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["3a5"] = Instance.new("TextButton", G2L["389"]);
G2L["3a5"]["TextWrapped"] = true;
G2L["3a5"]["BorderSizePixel"] = 3;
G2L["3a5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3a5"]["TextSize"] = 14;
G2L["3a5"]["TextScaled"] = true;
G2L["3a5"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3a5"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3a5"]["Size"] = UDim2.new(0, 112, 0, 34);
G2L["3a5"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3a5"]["Text"] = [[Loud Music]];
G2L["3a5"]["Position"] = UDim2.new(1.28, 0, 2.28, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["3a6"] = Instance.new("Script", G2L["3a5"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Rain Sound Effect
G2L["3a7"] = Instance.new("Sound", G2L["3a6"]);
G2L["3a7"]["Name"] = [[Rain Sound Effect]];
G2L["3a7"]["SoundId"] = [[rbxassetid://9064263922]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["3a8"] = Instance.new("TextButton", G2L["389"]);
G2L["3a8"]["TextWrapped"] = true;
G2L["3a8"]["BorderSizePixel"] = 3;
G2L["3a8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3a8"]["TextSize"] = 14;
G2L["3a8"]["TextScaled"] = true;
G2L["3a8"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3a8"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3a8"]["Size"] = UDim2.new(0, 112, 0, 34);
G2L["3a8"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3a8"]["Text"] = [[gangsta paradise remix]];
G2L["3a8"]["Position"] = UDim2.new(-0.14, 0, 2.28, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["3a9"] = Instance.new("Script", G2L["3a8"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Rain Sound Effect
G2L["3aa"] = Instance.new("Sound", G2L["3a9"]);
G2L["3aa"]["Name"] = [[Rain Sound Effect]];
G2L["3aa"]["SoundId"] = [[rbxassetid://9064263922]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["3ab"] = Instance.new("TextButton", G2L["389"]);
G2L["3ab"]["TextWrapped"] = true;
G2L["3ab"]["BorderSizePixel"] = 3;
G2L["3ab"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3ab"]["TextSize"] = 14;
G2L["3ab"]["TextScaled"] = true;
G2L["3ab"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3ab"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3ab"]["Size"] = UDim2.new(0, 112, 0, 34);
G2L["3ab"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3ab"]["Text"] = [[You Are Now Entering Realm Of Tubers93]];
G2L["3ab"]["Position"] = UDim2.new(-0.815, 0, 2.28, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["3ac"] = Instance.new("Script", G2L["3ab"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Rain Sound Effect
G2L["3ad"] = Instance.new("Sound", G2L["3ac"]);
G2L["3ad"]["Name"] = [[Rain Sound Effect]];
G2L["3ad"]["SoundId"] = [[rbxassetid://9064263922]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["3ae"] = Instance.new("TextButton", G2L["389"]);
G2L["3ae"]["TextWrapped"] = true;
G2L["3ae"]["BorderSizePixel"] = 3;
G2L["3ae"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3ae"]["TextSize"] = 14;
G2L["3ae"]["TextScaled"] = true;
G2L["3ae"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3ae"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3ae"]["Size"] = UDim2.new(0, 112, 0, 34);
G2L["3ae"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3ae"]["Text"] = [[I.M.Meen Original Audio]];
G2L["3ae"]["Position"] = UDim2.new(-0.82, 0, 3.16, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["3af"] = Instance.new("Script", G2L["3ae"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Rain Sound Effect
G2L["3b0"] = Instance.new("Sound", G2L["3af"]);
G2L["3b0"]["Name"] = [[Rain Sound Effect]];
G2L["3b0"]["SoundId"] = [[rbxassetid://9064263922]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["3b1"] = Instance.new("TextButton", G2L["389"]);
G2L["3b1"]["TextWrapped"] = true;
G2L["3b1"]["BorderSizePixel"] = 3;
G2L["3b1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3b1"]["TextSize"] = 14;
G2L["3b1"]["TextScaled"] = true;
G2L["3b1"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3b1"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3b1"]["Size"] = UDim2.new(0, 112, 0, 34);
G2L["3b1"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3b1"]["Text"] = [[I.M.Meen Loud Audio]];
G2L["3b1"]["Position"] = UDim2.new(-0.14, 0, 3.16, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["3b2"] = Instance.new("Script", G2L["3b1"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Rain Sound Effect
G2L["3b3"] = Instance.new("Sound", G2L["3b2"]);
G2L["3b3"]["Name"] = [[Rain Sound Effect]];
G2L["3b3"]["SoundId"] = [[rbxassetid://9064263922]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["3b4"] = Instance.new("TextButton", G2L["389"]);
G2L["3b4"]["TextWrapped"] = true;
G2L["3b4"]["BorderSizePixel"] = 3;
G2L["3b4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3b4"]["TextSize"] = 14;
G2L["3b4"]["TextScaled"] = true;
G2L["3b4"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3b4"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3b4"]["Size"] = UDim2.new(0, 112, 0, 34);
G2L["3b4"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3b4"]["Text"] = [[g00by theme]];
G2L["3b4"]["Position"] = UDim2.new(0.495, 0, 3.16, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["3b5"] = Instance.new("Script", G2L["3b4"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Rain Sound Effect
G2L["3b6"] = Instance.new("Sound", G2L["3b5"]);
G2L["3b6"]["Name"] = [[Rain Sound Effect]];
G2L["3b6"]["SoundId"] = [[rbxassetid://9064263922]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["3b7"] = Instance.new("TextButton", G2L["389"]);
G2L["3b7"]["TextWrapped"] = true;
G2L["3b7"]["BorderSizePixel"] = 3;
G2L["3b7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3b7"]["TextSize"] = 14;
G2L["3b7"]["TextScaled"] = true;
G2L["3b7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3b7"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3b7"]["Size"] = UDim2.new(0, 112, 0, 34);
G2L["3b7"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3b7"]["Text"] = [[goofy music lol]];
G2L["3b7"]["Position"] = UDim2.new(1.195, 0, 3.16, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["3b8"] = Instance.new("Script", G2L["3b7"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Rain Sound Effect
G2L["3b9"] = Instance.new("Sound", G2L["3b8"]);
G2L["3b9"]["Name"] = [[Rain Sound Effect]];
G2L["3b9"]["SoundId"] = [[rbxassetid://9064263922]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["3ba"] = Instance.new("TextButton", G2L["389"]);
G2L["3ba"]["TextWrapped"] = true;
G2L["3ba"]["BorderSizePixel"] = 3;
G2L["3ba"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3ba"]["TextSize"] = 14;
G2L["3ba"]["TextScaled"] = true;
G2L["3ba"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3ba"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3ba"]["Size"] = UDim2.new(0, 136, 0, 34);
G2L["3ba"]["BorderColor3"] = Color3.fromRGB(255, 0, 0);
G2L["3ba"]["Text"] = [[Stop All Sound]];
G2L["3ba"]["Position"] = UDim2.new(-0.82, 0, 4.3, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["3bb"] = Instance.new("Script", G2L["3ba"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Rain Sound Effect
G2L["3bc"] = Instance.new("Sound", G2L["3bb"]);
G2L["3bc"]["Name"] = [[Rain Sound Effect]];
G2L["3bc"]["SoundId"] = [[rbxassetid://9064263922]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["3bd"] = Instance.new("TextButton", G2L["389"]);
G2L["3bd"]["TextWrapped"] = true;
G2L["3bd"]["BorderSizePixel"] = 3;
G2L["3bd"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3bd"]["TextSize"] = 14;
G2L["3bd"]["TextScaled"] = true;
G2L["3bd"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3bd"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3bd"]["Size"] = UDim2.new(0, 136, 0, 34);
G2L["3bd"]["BorderColor3"] = Color3.fromRGB(255, 0, 0);
G2L["3bd"]["Text"] = [[Distort All Sound]];
G2L["3bd"]["Position"] = UDim2.new(0.035, 0, 4.3, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["3be"] = Instance.new("Script", G2L["3bd"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Rain Sound Effect
G2L["3bf"] = Instance.new("Sound", G2L["3be"]);
G2L["3bf"]["Name"] = [[Rain Sound Effect]];
G2L["3bf"]["SoundId"] = [[rbxassetid://9064263922]];


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton
G2L["3c0"] = Instance.new("TextButton", G2L["389"]);
G2L["3c0"]["TextWrapped"] = true;
G2L["3c0"]["BorderSizePixel"] = 3;
G2L["3c0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3c0"]["TextSize"] = 14;
G2L["3c0"]["TextScaled"] = true;
G2L["3c0"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3c0"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3c0"]["Size"] = UDim2.new(0, 136, 0, 34);
G2L["3c0"]["BorderColor3"] = Color3.fromRGB(255, 0, 0);
G2L["3c0"]["Text"] = [[Reverb all sound]];
G2L["3c0"]["Position"] = UDim2.new(0.925, 0, 4.3, 0);


-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script
G2L["3c1"] = Instance.new("Script", G2L["3c0"]);



-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Rain Sound Effect
G2L["3c2"] = Instance.new("Sound", G2L["3c1"]);
G2L["3c2"]["Name"] = [[Rain Sound Effect]];
G2L["3c2"]["SoundId"] = [[rbxassetid://9064263922]];


-- StarterGui.ScreenGui.cool.Page1.TextButton
G2L["3c3"] = Instance.new("TextButton", G2L["1ef"]);
G2L["3c3"]["TextWrapped"] = true;
G2L["3c3"]["BorderSizePixel"] = 3;
G2L["3c3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3c3"]["TextSize"] = 14;
G2L["3c3"]["TextScaled"] = true;
G2L["3c3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3c3"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3c3"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["3c3"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3c3"]["Text"] = [[k00p coffe shop]];
G2L["3c3"]["Position"] = UDim2.new(0.3266, 0, -0.10616, 0);


-- StarterGui.ScreenGui.cool.Page1.TextButton.Script
G2L["3c4"] = Instance.new("Script", G2L["3c3"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
G2L["3c5"] = Instance.new("LocalScript", G2L["3c3"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton.RemoteEvent
G2L["3c6"] = Instance.new("RemoteEvent", G2L["3c3"]);



-- StarterGui.ScreenGui.cool.Page1.Smooth GUI Dragging
G2L["3c7"] = Instance.new("LocalScript", G2L["1ef"]);
G2L["3c7"]["Name"] = [[Smooth GUI Dragging]];


-- StarterGui.ScreenGui.cool.Page1.TextButton
G2L["3c8"] = Instance.new("TextButton", G2L["1ef"]);
G2L["3c8"]["TextWrapped"] = true;
G2L["3c8"]["BorderSizePixel"] = 3;
G2L["3c8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3c8"]["TextSize"] = 14;
G2L["3c8"]["TextScaled"] = true;
G2L["3c8"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3c8"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3c8"]["Size"] = UDim2.new(0, 188, 0, 50);
G2L["3c8"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3c8"]["Text"] = [[Chicken Arms[R6]]];
G2L["3c8"]["Position"] = UDim2.new(1.01178, 0, 0.00637, 0);


-- StarterGui.ScreenGui.cool.Page1.TextButton.Script
G2L["3c9"] = Instance.new("Script", G2L["3c8"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton.Script.RemoteEvent
G2L["3ca"] = Instance.new("RemoteEvent", G2L["3c9"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
G2L["3cb"] = Instance.new("LocalScript", G2L["3c8"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton
G2L["3cc"] = Instance.new("TextButton", G2L["1ef"]);
G2L["3cc"]["TextWrapped"] = true;
G2L["3cc"]["BorderSizePixel"] = 3;
G2L["3cc"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3cc"]["TextSize"] = 14;
G2L["3cc"]["TextScaled"] = true;
G2L["3cc"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3cc"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3cc"]["Size"] = UDim2.new(0, 188, 0, 50);
G2L["3cc"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3cc"]["Text"] = [[Guards]];
G2L["3cc"]["Position"] = UDim2.new(1.01178, 0, 0.13588, 0);


-- StarterGui.ScreenGui.cool.Page1.TextButton.Script
G2L["3cd"] = Instance.new("Script", G2L["3cc"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
G2L["3ce"] = Instance.new("LocalScript", G2L["3cc"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton.RemoteEvent
G2L["3cf"] = Instance.new("RemoteEvent", G2L["3cc"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton
G2L["3d0"] = Instance.new("TextButton", G2L["1ef"]);
G2L["3d0"]["TextWrapped"] = true;
G2L["3d0"]["BorderSizePixel"] = 3;
G2L["3d0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3d0"]["TextSize"] = 14;
G2L["3d0"]["TextScaled"] = true;
G2L["3d0"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3d0"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3d0"]["Size"] = UDim2.new(0, 188, 0, 50);
G2L["3d0"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3d0"]["Text"] = [[c**lboi script]];
G2L["3d0"]["Position"] = UDim2.new(1.01178, 0, 0.26964, 0);


-- StarterGui.ScreenGui.cool.Page1.TextButton.Script
G2L["3d1"] = Instance.new("Script", G2L["3d0"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
G2L["3d2"] = Instance.new("LocalScript", G2L["3d0"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton.RemoteEvent
G2L["3d3"] = Instance.new("RemoteEvent", G2L["3d0"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton
G2L["3d4"] = Instance.new("TextButton", G2L["1ef"]);
G2L["3d4"]["TextWrapped"] = true;
G2L["3d4"]["BorderSizePixel"] = 3;
G2L["3d4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3d4"]["TextSize"] = 14;
G2L["3d4"]["TextScaled"] = true;
G2L["3d4"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3d4"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3d4"]["Size"] = UDim2.new(0, 188, 0, 50);
G2L["3d4"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3d4"]["Text"] = [[Remove Backdoor]];
G2L["3d4"]["Position"] = UDim2.new(1.01178, 0, 0.39703, 0);


-- StarterGui.ScreenGui.cool.Page1.TextButton.Script
G2L["3d5"] = Instance.new("Script", G2L["3d4"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
G2L["3d6"] = Instance.new("LocalScript", G2L["3d4"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton.RemoteEvent
G2L["3d7"] = Instance.new("RemoteEvent", G2L["3d4"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton
G2L["3d8"] = Instance.new("TextButton", G2L["1ef"]);
G2L["3d8"]["TextWrapped"] = true;
G2L["3d8"]["BorderSizePixel"] = 3;
G2L["3d8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3d8"]["TextSize"] = 14;
G2L["3d8"]["TextScaled"] = true;
G2L["3d8"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3d8"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3d8"]["Size"] = UDim2.new(0, 188, 0, 50);
G2L["3d8"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3d8"]["Text"] = [[g**by gui]];
G2L["3d8"]["Position"] = UDim2.new(1.01178, 0, 0.52654, 0);


-- StarterGui.ScreenGui.cool.Page1.TextButton.Script
G2L["3d9"] = Instance.new("Script", G2L["3d8"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
G2L["3da"] = Instance.new("LocalScript", G2L["3d8"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton.RemoteEvent
G2L["3db"] = Instance.new("RemoteEvent", G2L["3d8"]);



-- StarterGui.ScreenGui.cool.Page1.k*** k*** [Noot Noot Crasher]
G2L["3dc"] = Instance.new("TextButton", G2L["1ef"]);
G2L["3dc"]["TextWrapped"] = true;
G2L["3dc"]["BorderSizePixel"] = 3;
G2L["3dc"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3dc"]["TextSize"] = 14;
G2L["3dc"]["TextScaled"] = true;
G2L["3dc"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3dc"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3dc"]["Size"] = UDim2.new(0, 188, 0, 50);
G2L["3dc"]["Name"] = [[k*** k*** [Noot Noot Crasher]]];
G2L["3dc"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3dc"]["Text"] = [[k*** k*** [Noot Noot Crasher]]];
G2L["3dc"]["Position"] = UDim2.new(1.01178, 0, 0.65393, 0);


-- StarterGui.ScreenGui.cool.Page1.k*** k*** [Noot Noot Crasher].Read Me!1!!!
G2L["3dd"] = Instance.new("Script", G2L["3dc"]);
G2L["3dd"]["Name"] = [[Read Me!1!!!]];


-- StarterGui.ScreenGui.cool.Page1.k*** k*** [Noot Noot Crasher].noot nott crasher script
G2L["3de"] = Instance.new("Script", G2L["3dc"]);
G2L["3de"]["Name"] = [[noot nott crasher script]];


-- StarterGui.ScreenGui.cool.Page1.TextButton
G2L["3df"] = Instance.new("TextButton", G2L["1ef"]);
G2L["3df"]["TextWrapped"] = true;
G2L["3df"]["BorderSizePixel"] = 3;
G2L["3df"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3df"]["TextSize"] = 14;
G2L["3df"]["TextScaled"] = true;
G2L["3df"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3df"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3df"]["Size"] = UDim2.new(0, 188, 0, 50);
G2L["3df"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3df"]["Text"] = [[funni decal spam]];
G2L["3df"]["Position"] = UDim2.new(1.01178, 0, 0.78769, 0);


-- StarterGui.ScreenGui.cool.Page1.TextButton.Script
G2L["3e0"] = Instance.new("Script", G2L["3df"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton.Script
G2L["3e1"] = Instance.new("Script", G2L["3df"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton.Script
G2L["3e2"] = Instance.new("Script", G2L["3df"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
G2L["3e3"] = Instance.new("LocalScript", G2L["3df"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton.RemoteEvent
G2L["3e4"] = Instance.new("RemoteEvent", G2L["3df"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton
G2L["3e5"] = Instance.new("TextButton", G2L["1ef"]);
G2L["3e5"]["TextWrapped"] = true;
G2L["3e5"]["BorderSizePixel"] = 3;
G2L["3e5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3e5"]["TextSize"] = 14;
G2L["3e5"]["TextScaled"] = true;
G2L["3e5"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3e5"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3e5"]["Size"] = UDim2.new(0, 188, 0, 33);
G2L["3e5"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3e5"]["Text"] = [[Low Hp All]];
G2L["3e5"]["Position"] = UDim2.new(1.01178, 0, 0.92994, 0);


-- StarterGui.ScreenGui.cool.Page1.TextButton.Script
G2L["3e6"] = Instance.new("Script", G2L["3e5"]);



-- StarterGui.ScreenGui.cool.Page1.k00perz?!?!?!?
G2L["3e7"] = Instance.new("ImageLabel", G2L["1ef"]);
G2L["3e7"]["BorderSizePixel"] = 0;
G2L["3e7"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3e7"]["Image"] = [[rbxassetid://12168410006]];
G2L["3e7"]["Size"] = UDim2.new(0, 118, 0, 100);
G2L["3e7"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3e7"]["Name"] = [[k00perz?!?!?!?]];
G2L["3e7"]["Position"] = UDim2.new(-0.19865, 0, -0.00637, 0);


-- StarterGui.ScreenGui.cool.Page1.k00perz?!?!?!?
G2L["3e8"] = Instance.new("ImageLabel", G2L["1ef"]);
G2L["3e8"]["BorderSizePixel"] = 0;
G2L["3e8"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3e8"]["Image"] = [[rbxassetid://11426291165]];
G2L["3e8"]["Size"] = UDim2.new(0, 118, 0, 100);
G2L["3e8"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3e8"]["Name"] = [[k00perz?!?!?!?]];
G2L["3e8"]["Position"] = UDim2.new(-0.19865, 0, 0.22718, 0);


-- StarterGui.ScreenGui.cool.Page1.k00perz?!?!?!?
G2L["3e9"] = Instance.new("ImageLabel", G2L["1ef"]);
G2L["3e9"]["BorderSizePixel"] = 0;
G2L["3e9"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3e9"]["Image"] = [[rbxassetid://14405509678]];
G2L["3e9"]["Size"] = UDim2.new(0, 118, 0, 100);
G2L["3e9"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3e9"]["Name"] = [[k00perz?!?!?!?]];
G2L["3e9"]["Position"] = UDim2.new(-0.19865, 0, 0.4586, 0);


-- StarterGui.ScreenGui.cool.Page1.k00perz?!?!?!?
G2L["3ea"] = Instance.new("ImageLabel", G2L["1ef"]);
G2L["3ea"]["BorderSizePixel"] = 0;
G2L["3ea"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3ea"]["Image"] = [[rbxassetid://9018233362]];
G2L["3ea"]["Size"] = UDim2.new(0, 118, 0, 100);
G2L["3ea"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3ea"]["Name"] = [[k00perz?!?!?!?]];
G2L["3ea"]["Position"] = UDim2.new(-0.19865, 0, 0.69639, 0);


-- StarterGui.ScreenGui.cool.Page1.k00perz?!?!?!?
G2L["3eb"] = Instance.new("ImageLabel", G2L["1ef"]);
G2L["3eb"]["BorderSizePixel"] = 0;
G2L["3eb"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3eb"]["Image"] = [[rbxassetid://9422866248]];
G2L["3eb"]["Size"] = UDim2.new(0, 118, 0, 76);
G2L["3eb"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3eb"]["Name"] = [[k00perz?!?!?!?]];
G2L["3eb"]["Position"] = UDim2.new(-0.19865, 0, 0.93418, 0);


-- StarterGui.ScreenGui.cool.Page1.TextButton
G2L["3ec"] = Instance.new("TextButton", G2L["1ef"]);
G2L["3ec"]["TextWrapped"] = true;
G2L["3ec"]["BorderSizePixel"] = 3;
G2L["3ec"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3ec"]["TextSize"] = 14;
G2L["3ec"]["TextScaled"] = true;
G2L["3ec"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3ec"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3ec"]["Size"] = UDim2.new(0, 174, 0, 50);
G2L["3ec"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3ec"]["Text"] = [[Page 2]];
G2L["3ec"]["Position"] = UDim2.new(0.71044, 0, -0.11253, 0);


-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
G2L["3ed"] = Instance.new("LocalScript", G2L["3ec"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton
G2L["3ee"] = Instance.new("TextButton", G2L["1ef"]);
G2L["3ee"]["TextWrapped"] = true;
G2L["3ee"]["BorderSizePixel"] = 3;
G2L["3ee"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3ee"]["TextSize"] = 14;
G2L["3ee"]["TextScaled"] = true;
G2L["3ee"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3ee"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3ee"]["Size"] = UDim2.new(0, 174, 0, 50);
G2L["3ee"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3ee"]["Text"] = [[Page 3]];
G2L["3ee"]["Position"] = UDim2.new(0.00673, 0, -0.11253, 0);


-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
G2L["3ef"] = Instance.new("LocalScript", G2L["3ee"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton
G2L["3f0"] = Instance.new("TextButton", G2L["1ef"]);
G2L["3f0"]["TextWrapped"] = true;
G2L["3f0"]["BorderSizePixel"] = 3;
G2L["3f0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3f0"]["TextSize"] = 14;
G2L["3f0"]["TextScaled"] = true;
G2L["3f0"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3f0"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3f0"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["3f0"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3f0"]["Text"] = [[Page 4]];
G2L["3f0"]["Position"] = UDim2.new(0.3266, 0, -0.23142, 0);


-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
G2L["3f1"] = Instance.new("LocalScript", G2L["3f0"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton
G2L["3f2"] = Instance.new("TextButton", G2L["1ef"]);
G2L["3f2"]["TextWrapped"] = true;
G2L["3f2"]["BorderSizePixel"] = 3;
G2L["3f2"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3f2"]["TextSize"] = 14;
G2L["3f2"]["TextScaled"] = true;
G2L["3f2"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3f2"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3f2"]["Size"] = UDim2.new(0, 174, 0, 50);
G2L["3f2"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3f2"]["Text"] = [[Page 5]];
G2L["3f2"]["Position"] = UDim2.new(0.00673, 0, -0.23142, 0);


-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
G2L["3f3"] = Instance.new("LocalScript", G2L["3f2"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton
G2L["3f4"] = Instance.new("TextButton", G2L["1ef"]);
G2L["3f4"]["TextWrapped"] = true;
G2L["3f4"]["BorderSizePixel"] = 3;
G2L["3f4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3f4"]["TextSize"] = 14;
G2L["3f4"]["TextScaled"] = true;
G2L["3f4"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3f4"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3f4"]["Size"] = UDim2.new(0, 174, 0, 50);
G2L["3f4"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3f4"]["Text"] = [[Page 6]];
G2L["3f4"]["Position"] = UDim2.new(0.70707, 0, -0.23142, 0);


-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
G2L["3f5"] = Instance.new("LocalScript", G2L["3f4"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton
G2L["3f6"] = Instance.new("TextButton", G2L["1ef"]);
G2L["3f6"]["TextWrapped"] = true;
G2L["3f6"]["BorderSizePixel"] = 3;
G2L["3f6"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3f6"]["TextSize"] = 14;
G2L["3f6"]["TextScaled"] = true;
G2L["3f6"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3f6"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3f6"]["Size"] = UDim2.new(0, 174, 0, 50);
G2L["3f6"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3f6"]["Text"] = [[Page 7]];
G2L["3f6"]["Position"] = UDim2.new(0.00673, 0, -0.35669, 0);


-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
G2L["3f7"] = Instance.new("LocalScript", G2L["3f6"]);



-- StarterGui.ScreenGui.cool.Page1.TextButton
G2L["3f8"] = Instance.new("TextButton", G2L["1ef"]);
G2L["3f8"]["TextWrapped"] = true;
G2L["3f8"]["BorderSizePixel"] = 3;
G2L["3f8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3f8"]["TextSize"] = 14;
G2L["3f8"]["TextScaled"] = true;
G2L["3f8"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3f8"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3f8"]["Size"] = UDim2.new(0, 174, 0, 50);
G2L["3f8"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3f8"]["Text"] = [[Page 8]];
G2L["3f8"]["Position"] = UDim2.new(0.33333, 0, -0.35669, 0);


-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
G2L["3f9"] = Instance.new("LocalScript", G2L["3f8"]);



-- StarterGui.ScreenGui.cool.Main
G2L["3fa"] = Instance.new("Frame", G2L["2"]);
G2L["3fa"]["Visible"] = false;
G2L["3fa"]["BorderSizePixel"] = 0;
G2L["3fa"]["BackgroundColor3"] = Color3.fromRGB(58, 58, 58);
G2L["3fa"]["Size"] = UDim2.new(0, 446, 0, 250);
G2L["3fa"]["Position"] = UDim2.new(5.353, 0, 3.521, 0);
G2L["3fa"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3fa"]["Name"] = [[Main]];


-- StarterGui.ScreenGui.cool.Main.TopRow
G2L["3fb"] = Instance.new("Frame", G2L["3fa"]);
G2L["3fb"]["BorderSizePixel"] = 0;
G2L["3fb"]["BackgroundColor3"] = Color3.fromRGB(49, 49, 49);
G2L["3fb"]["Size"] = UDim2.new(0, 446, 0, 41);
G2L["3fb"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3fb"]["Name"] = [[TopRow]];


-- StarterGui.ScreenGui.cool.Main.TopRow.TextLabel
G2L["3fc"] = Instance.new("TextLabel", G2L["3fb"]);
G2L["3fc"]["TextWrapped"] = true;
G2L["3fc"]["BorderSizePixel"] = 3;
G2L["3fc"]["TextSize"] = 20;
G2L["3fc"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["3fc"]["TextScaled"] = true;
G2L["3fc"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3fc"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3fc"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3fc"]["BackgroundTransparency"] = 1;
G2L["3fc"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["3fc"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["3fc"]["Text"] = [[k00pgui v4 op edition page 3(the executor)]];


-- StarterGui.ScreenGui.cool.Main.TopRow.TopMidRow
G2L["3fd"] = Instance.new("Frame", G2L["3fb"]);
G2L["3fd"]["BorderSizePixel"] = 0;
G2L["3fd"]["BackgroundColor3"] = Color3.fromRGB(49, 49, 49);
G2L["3fd"]["Size"] = UDim2.new(1, 0, 0, 21);
G2L["3fd"]["Position"] = UDim2.new(0, 0, 0.4878, 0);
G2L["3fd"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3fd"]["Name"] = [[TopMidRow]];


-- StarterGui.ScreenGui.cool.Main.TopRow.TopMidRow.UIListLayout
G2L["3fe"] = Instance.new("UIListLayout", G2L["3fd"]);
G2L["3fe"]["Padding"] = UDim.new(0, 5);
G2L["3fe"]["SortOrder"] = Enum.SortOrder.LayoutOrder;
G2L["3fe"]["FillDirection"] = Enum.FillDirection.Horizontal;


-- StarterGui.ScreenGui.cool.Main.BottomRow
G2L["3ff"] = Instance.new("Frame", G2L["3fa"]);
G2L["3ff"]["BorderSizePixel"] = 0;
G2L["3ff"]["BackgroundColor3"] = Color3.fromRGB(49, 49, 49);
G2L["3ff"]["Size"] = UDim2.new(1, 0, 0, 47);
G2L["3ff"]["Position"] = UDim2.new(0, 0, 0.812, 0);
G2L["3ff"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["3ff"]["Name"] = [[BottomRow]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.UIListLayout
G2L["400"] = Instance.new("UIListLayout", G2L["3ff"]);
G2L["400"]["Padding"] = UDim.new(0, 5);
G2L["400"]["SortOrder"] = Enum.SortOrder.LayoutOrder;
G2L["400"]["FillDirection"] = Enum.FillDirection.Horizontal;


-- StarterGui.ScreenGui.cool.Main.BottomRow.Execute
G2L["401"] = Instance.new("TextButton", G2L["3ff"]);
G2L["401"]["BorderSizePixel"] = 3;
G2L["401"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["401"]["TextSize"] = 20;
G2L["401"]["BackgroundColor3"] = Color3.fromRGB(0, 86, 0);
G2L["401"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["401"]["Size"] = UDim2.new(0, 100, 1, 0);
G2L["401"]["Name"] = [[Execute]];
G2L["401"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["401"]["Text"] = [[Execute]];
G2L["401"]["Position"] = UDim2.new(0, 0, 0.29787, 0);


-- StarterGui.ScreenGui.cool.Main.BottomRow.Execute.Script
G2L["402"] = Instance.new("Script", G2L["401"]);



-- StarterGui.ScreenGui.cool.Main.BottomRow.Execute.Script.Loadstring
G2L["403"] = Instance.new("ModuleScript", G2L["402"]);
G2L["403"]["Name"] = [[Loadstring]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.Execute.Script.Loadstring.LuaZ
G2L["404"] = Instance.new("ModuleScript", G2L["403"]);
G2L["404"]["Name"] = [[LuaZ]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.Execute.Script.Loadstring.LuaX
G2L["405"] = Instance.new("ModuleScript", G2L["403"]);
G2L["405"]["Name"] = [[LuaX]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.Execute.Script.Loadstring.LuaY
G2L["406"] = Instance.new("ModuleScript", G2L["403"]);
G2L["406"]["Name"] = [[LuaY]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.Execute.Script.Loadstring.LuaK
G2L["407"] = Instance.new("ModuleScript", G2L["403"]);
G2L["407"]["Name"] = [[LuaK]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.Execute.Script.Loadstring.LuaU
G2L["408"] = Instance.new("ModuleScript", G2L["403"]);
G2L["408"]["Name"] = [[LuaU]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.Execute.Script.Loadstring.LuaP
G2L["409"] = Instance.new("ModuleScript", G2L["403"]);
G2L["409"]["Name"] = [[LuaP]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.Execute.Script.Loadstring.Rerubi
G2L["40a"] = Instance.new("ModuleScript", G2L["403"]);
G2L["40a"]["Name"] = [[Rerubi]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.Execute.LocalScript
G2L["40b"] = Instance.new("LocalScript", G2L["401"]);



-- StarterGui.ScreenGui.cool.Main.BottomRow.Execute.nya
G2L["40c"] = Instance.new("RemoteEvent", G2L["401"]);
G2L["40c"]["Name"] = [[nya]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.Clear
G2L["40d"] = Instance.new("TextButton", G2L["3ff"]);
G2L["40d"]["BorderSizePixel"] = 3;
G2L["40d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["40d"]["TextSize"] = 20;
G2L["40d"]["BackgroundColor3"] = Color3.fromRGB(0, 86, 0);
G2L["40d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["40d"]["Size"] = UDim2.new(0, 75, 1, 0);
G2L["40d"]["Name"] = [[Clear]];
G2L["40d"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["40d"]["Text"] = [[Clear]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.Clear.LocalScript
G2L["40e"] = Instance.new("LocalScript", G2L["40d"]);



-- StarterGui.ScreenGui.cool.Main.BottomRow.Respawn
G2L["40f"] = Instance.new("TextButton", G2L["3ff"]);
G2L["40f"]["BorderSizePixel"] = 3;
G2L["40f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["40f"]["TextSize"] = 20;
G2L["40f"]["BackgroundColor3"] = Color3.fromRGB(0, 86, 0);
G2L["40f"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["40f"]["Size"] = UDim2.new(0, 85, 1, 0);
G2L["40f"]["Name"] = [[Respawn]];
G2L["40f"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["40f"]["Text"] = [[Respawn]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.Respawn.Script
G2L["410"] = Instance.new("Script", G2L["40f"]);



-- StarterGui.ScreenGui.cool.Main.BottomRow.R6
G2L["411"] = Instance.new("TextButton", G2L["3ff"]);
G2L["411"]["BorderSizePixel"] = 3;
G2L["411"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["411"]["TextSize"] = 20;
G2L["411"]["BackgroundColor3"] = Color3.fromRGB(0, 86, 0);
G2L["411"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["411"]["Size"] = UDim2.new(0, 35, 1, 0);
G2L["411"]["Name"] = [[R6]];
G2L["411"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["411"]["Text"] = [[R6]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.LocalScript
G2L["412"] = Instance.new("LocalScript", G2L["411"]);



-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.LocalScript.Script
G2L["413"] = Instance.new("Script", G2L["412"]);



-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.LocalScript.RemoteEvent
G2L["414"] = Instance.new("RemoteEvent", G2L["412"]);



-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6
G2L["415"] = Instance.new("ModuleScript", G2L["411"]);
G2L["415"]["Name"] = [[R6]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter
G2L["416"] = Instance.new("Model", G2L["415"]);
-- [ERROR] cannot convert WorldPivot, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["416"]["Name"] = [[DefaultCharacter]];
-- [ERROR] cannot convert PrimaryPart, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate
G2L["417"] = Instance.new("LocalScript", G2L["416"]);
G2L["417"]["Name"] = [[Animate]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.ScaleDampeningPercent
G2L["418"] = Instance.new("NumberValue", G2L["417"]);
G2L["418"]["Name"] = [[ScaleDampeningPercent]];
G2L["418"]["Value"] = 0.4;


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.sit
G2L["419"] = Instance.new("StringValue", G2L["417"]);
G2L["419"]["Name"] = [[sit]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.sit.SitAnim
G2L["41a"] = Instance.new("Animation", G2L["419"]);
G2L["41a"]["Name"] = [[SitAnim]];
G2L["41a"]["AnimationId"] = [[http://www.roblox.com/asset/?id=178130996]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.fall
G2L["41b"] = Instance.new("StringValue", G2L["417"]);
G2L["41b"]["Name"] = [[fall]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.fall.FallAnim
G2L["41c"] = Instance.new("Animation", G2L["41b"]);
G2L["41c"]["Name"] = [[FallAnim]];
G2L["41c"]["AnimationId"] = [[http://www.roblox.com/asset/?id=180436148]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.toolnone
G2L["41d"] = Instance.new("StringValue", G2L["417"]);
G2L["41d"]["Name"] = [[toolnone]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.toolnone.ToolNoneAnim
G2L["41e"] = Instance.new("Animation", G2L["41d"]);
G2L["41e"]["Name"] = [[ToolNoneAnim]];
G2L["41e"]["AnimationId"] = [[http://www.roblox.com/asset/?id=182393478]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.climb
G2L["41f"] = Instance.new("StringValue", G2L["417"]);
G2L["41f"]["Name"] = [[climb]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.climb.ClimbAnim
G2L["420"] = Instance.new("Animation", G2L["41f"]);
G2L["420"]["Name"] = [[ClimbAnim]];
G2L["420"]["AnimationId"] = [[http://www.roblox.com/asset/?id=180436334]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.jump
G2L["421"] = Instance.new("StringValue", G2L["417"]);
G2L["421"]["Name"] = [[jump]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.jump.JumpAnim
G2L["422"] = Instance.new("Animation", G2L["421"]);
G2L["422"]["Name"] = [[JumpAnim]];
G2L["422"]["AnimationId"] = [[http://www.roblox.com/asset/?id=125750702]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.run
G2L["423"] = Instance.new("StringValue", G2L["417"]);
G2L["423"]["Name"] = [[run]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.run.RunAnim
G2L["424"] = Instance.new("Animation", G2L["423"]);
G2L["424"]["Name"] = [[RunAnim]];
G2L["424"]["AnimationId"] = [[http://www.roblox.com/asset/?id=180426354]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.walk
G2L["425"] = Instance.new("StringValue", G2L["417"]);
G2L["425"]["Name"] = [[walk]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.walk.WalkAnim
G2L["426"] = Instance.new("Animation", G2L["425"]);
G2L["426"]["Name"] = [[WalkAnim]];
G2L["426"]["AnimationId"] = [[http://www.roblox.com/asset/?id=180426354]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.idle
G2L["427"] = Instance.new("StringValue", G2L["417"]);
G2L["427"]["Name"] = [[idle]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.idle.Animation2
G2L["428"] = Instance.new("Animation", G2L["427"]);
G2L["428"]["Name"] = [[Animation2]];
G2L["428"]["AnimationId"] = [[http://www.roblox.com/asset/?id=180435792]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.idle.Animation2.Weight
G2L["429"] = Instance.new("NumberValue", G2L["428"]);
G2L["429"]["Name"] = [[Weight]];
G2L["429"]["Value"] = 1;


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.idle.Animation1
G2L["42a"] = Instance.new("Animation", G2L["427"]);
G2L["42a"]["Name"] = [[Animation1]];
G2L["42a"]["AnimationId"] = [[http://www.roblox.com/asset/?id=180435571]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate.idle.Animation1.Weight
G2L["42b"] = Instance.new("NumberValue", G2L["42a"]);
G2L["42b"]["Name"] = [[Weight]];
G2L["42b"]["Value"] = 9;


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Health
G2L["42c"] = Instance.new("Script", G2L["416"]);
G2L["42c"]["Name"] = [[Health]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.HumanoidRootPart
G2L["42d"] = Instance.new("Part", G2L["416"]);
G2L["42d"]["BottomSurface"] = Enum.SurfaceType.Smooth;
G2L["42d"]["CanCollide"] = false;
G2L["42d"]["Transparency"] = 1;
G2L["42d"]["TopSurface"] = Enum.SurfaceType.Smooth;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["42d"]["Locked"] = true;
G2L["42d"]["Size"] = Vector3.new(2, 2, 1);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["42d"]["Color"] = Color3.fromRGB(174, 174, 174);
G2L["42d"]["Rotation"] = Vector3.new(0, -90, 0);
G2L["42d"]["Name"] = [[HumanoidRootPart]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.HumanoidRootPart.RootJoint
G2L["42e"] = Instance.new("Motor6D", G2L["42d"]);
-- [ERROR] cannot convert Part1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["42e"]["MaxVelocity"] = 0.1;
-- [ERROR] cannot convert C1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert C0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["42e"]["Name"] = [[RootJoint]];
-- [ERROR] cannot convert Part0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.HumanoidRootPart.RootAttachment
G2L["42f"] = Instance.new("Attachment", G2L["42d"]);
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["42f"]["Name"] = [[RootAttachment]];
G2L["42f"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.HumanoidRootPart.CharacterSoundEvent
G2L["430"] = Instance.new("RemoteEvent", G2L["42d"]);
G2L["430"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Humanoid
G2L["431"] = Instance.new("Humanoid", G2L["416"]);



-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Humanoid.Jump
G2L["432"] = Instance.new("LocalScript", G2L["431"]);
G2L["432"]["Name"] = [[Jump]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Humanoid.Respawn
G2L["433"] = Instance.new("Script", G2L["431"]);
G2L["433"]["Name"] = [[Respawn]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Humanoid.Animator
G2L["434"] = Instance.new("Animator", G2L["431"]);



-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Right Leg
G2L["435"] = Instance.new("Part", G2L["416"]);
G2L["435"]["BottomSurface"] = Enum.SurfaceType.Smooth;
G2L["435"]["CanCollide"] = false;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["435"]["Locked"] = true;
G2L["435"]["Size"] = Vector3.new(1, 2, 1);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["435"]["Color"] = Color3.fromRGB(174, 174, 174);
G2L["435"]["Rotation"] = Vector3.new(0, -90, 0);
G2L["435"]["Name"] = [[Right Leg]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Right Leg.RightFootAttachment
G2L["436"] = Instance.new("Attachment", G2L["435"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["436"]["Name"] = [[RightFootAttachment]];
G2L["436"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Right Leg.CharacterSoundEvent
G2L["437"] = Instance.new("RemoteEvent", G2L["435"]);
G2L["437"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Left Leg
G2L["438"] = Instance.new("Part", G2L["416"]);
G2L["438"]["BottomSurface"] = Enum.SurfaceType.Smooth;
G2L["438"]["CanCollide"] = false;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["438"]["Locked"] = true;
G2L["438"]["Size"] = Vector3.new(1, 2, 1);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["438"]["Color"] = Color3.fromRGB(174, 174, 174);
G2L["438"]["Rotation"] = Vector3.new(0, -90, 0);
G2L["438"]["Name"] = [[Left Leg]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Left Leg.LeftFootAttachment
G2L["439"] = Instance.new("Attachment", G2L["438"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["439"]["Name"] = [[LeftFootAttachment]];
G2L["439"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Left Leg.CharacterSoundEvent
G2L["43a"] = Instance.new("RemoteEvent", G2L["438"]);
G2L["43a"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Right Arm
G2L["43b"] = Instance.new("Part", G2L["416"]);
G2L["43b"]["CanCollide"] = false;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["43b"]["Locked"] = true;
G2L["43b"]["Size"] = Vector3.new(1, 2, 1);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["43b"]["Color"] = Color3.fromRGB(174, 174, 174);
G2L["43b"]["Rotation"] = Vector3.new(0, -90, 0);
G2L["43b"]["Name"] = [[Right Arm]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Right Arm.RightGripAttachment
G2L["43c"] = Instance.new("Attachment", G2L["43b"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["43c"]["Name"] = [[RightGripAttachment]];
G2L["43c"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Right Arm.RightShoulderAttachment
G2L["43d"] = Instance.new("Attachment", G2L["43b"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["43d"]["Name"] = [[RightShoulderAttachment]];
G2L["43d"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Right Arm.CharacterSoundEvent
G2L["43e"] = Instance.new("RemoteEvent", G2L["43b"]);
G2L["43e"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Left Arm
G2L["43f"] = Instance.new("Part", G2L["416"]);
G2L["43f"]["CanCollide"] = false;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["43f"]["Locked"] = true;
G2L["43f"]["Size"] = Vector3.new(1, 2, 1);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["43f"]["Color"] = Color3.fromRGB(174, 174, 174);
G2L["43f"]["Rotation"] = Vector3.new(0, -90, 0);
G2L["43f"]["Name"] = [[Left Arm]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Left Arm.LeftGripAttachment
G2L["440"] = Instance.new("Attachment", G2L["43f"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["440"]["Name"] = [[LeftGripAttachment]];
G2L["440"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Left Arm.LeftShoulderAttachment
G2L["441"] = Instance.new("Attachment", G2L["43f"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["441"]["Name"] = [[LeftShoulderAttachment]];
G2L["441"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Left Arm.CharacterSoundEvent
G2L["442"] = Instance.new("RemoteEvent", G2L["43f"]);
G2L["442"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Torso
G2L["443"] = Instance.new("Part", G2L["416"]);
G2L["443"]["RightSurface"] = Enum.SurfaceType.Weld;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["443"]["Locked"] = true;
G2L["443"]["Size"] = Vector3.new(2, 2, 1);
G2L["443"]["LeftSurface"] = Enum.SurfaceType.Weld;
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["443"]["Color"] = Color3.fromRGB(174, 174, 174);
G2L["443"]["Rotation"] = Vector3.new(0, -90, 0);
G2L["443"]["Name"] = [[Torso]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Torso.Neck
G2L["444"] = Instance.new("Motor6D", G2L["443"]);
-- [ERROR] cannot convert Part1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["444"]["MaxVelocity"] = 0.1;
-- [ERROR] cannot convert C1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert C0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["444"]["Name"] = [[Neck]];
-- [ERROR] cannot convert Part0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Torso.Left Hip
G2L["445"] = Instance.new("Motor6D", G2L["443"]);
-- [ERROR] cannot convert Part1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["445"]["MaxVelocity"] = 0.1;
-- [ERROR] cannot convert C1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert C0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["445"]["Name"] = [[Left Hip]];
-- [ERROR] cannot convert Part0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Torso.Right Hip
G2L["446"] = Instance.new("Motor6D", G2L["443"]);
-- [ERROR] cannot convert Part1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["446"]["MaxVelocity"] = 0.1;
-- [ERROR] cannot convert C1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert C0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["446"]["Name"] = [[Right Hip]];
-- [ERROR] cannot convert Part0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Torso.Left Shoulder
G2L["447"] = Instance.new("Motor6D", G2L["443"]);
-- [ERROR] cannot convert Part1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["447"]["MaxVelocity"] = 0.1;
-- [ERROR] cannot convert C1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert C0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["447"]["Name"] = [[Left Shoulder]];
-- [ERROR] cannot convert Part0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Torso.Right Shoulder
G2L["448"] = Instance.new("Motor6D", G2L["443"]);
-- [ERROR] cannot convert Part1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["448"]["MaxVelocity"] = 0.1;
-- [ERROR] cannot convert C1, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert C0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["448"]["Name"] = [[Right Shoulder]];
-- [ERROR] cannot convert Part0, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Torso.WaistBackAttachment
G2L["449"] = Instance.new("Attachment", G2L["443"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["449"]["Name"] = [[WaistBackAttachment]];
G2L["449"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Torso.WaistCenterAttachment
G2L["44a"] = Instance.new("Attachment", G2L["443"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["44a"]["Name"] = [[WaistCenterAttachment]];
G2L["44a"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Torso.WaistFrontAttachment
G2L["44b"] = Instance.new("Attachment", G2L["443"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["44b"]["Name"] = [[WaistFrontAttachment]];
G2L["44b"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Torso.RightCollarAttachment
G2L["44c"] = Instance.new("Attachment", G2L["443"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["44c"]["Name"] = [[RightCollarAttachment]];
G2L["44c"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Torso.LeftCollarAttachment
G2L["44d"] = Instance.new("Attachment", G2L["443"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["44d"]["Name"] = [[LeftCollarAttachment]];
G2L["44d"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Torso.BodyBackAttachment
G2L["44e"] = Instance.new("Attachment", G2L["443"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["44e"]["Name"] = [[BodyBackAttachment]];
G2L["44e"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Torso.BodyFrontAttachment
G2L["44f"] = Instance.new("Attachment", G2L["443"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["44f"]["Name"] = [[BodyFrontAttachment]];
G2L["44f"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Torso.NeckAttachment
G2L["450"] = Instance.new("Attachment", G2L["443"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["450"]["Name"] = [[NeckAttachment]];
G2L["450"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Torso.roblox
G2L["451"] = Instance.new("Decal", G2L["443"]);
G2L["451"]["Name"] = [[roblox]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Torso.CharacterSoundEvent
G2L["452"] = Instance.new("RemoteEvent", G2L["443"]);
G2L["452"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head
G2L["453"] = Instance.new("Part", G2L["416"]);
G2L["453"]["TopSurface"] = Enum.SurfaceType.Smooth;
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["453"]["Locked"] = true;
G2L["453"]["Size"] = Vector3.new(2, 1, 1);
-- [ERROR] cannot convert BrickColor, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["453"]["Color"] = Color3.fromRGB(174, 174, 174);
G2L["453"]["Rotation"] = Vector3.new(0, -90, 0);
G2L["453"]["Name"] = [[Head]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.face
G2L["454"] = Instance.new("Decal", G2L["453"]);
G2L["454"]["Name"] = [[face]];
G2L["454"]["Texture"] = [[rbxassetid://144080495]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Climbing
G2L["455"] = Instance.new("Sound", G2L["453"]);
G2L["455"]["RollOffMaxDistance"] = 150;
G2L["455"]["Volume"] = 0.65;
G2L["455"]["Looped"] = true;
G2L["455"]["Name"] = [[Climbing]];
G2L["455"]["RollOffMinDistance"] = 5;
G2L["455"]["SoundId"] = [[rbxasset://sounds/action_footsteps_plastic.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Climbing.CharacterSoundEvent
G2L["456"] = Instance.new("RemoteEvent", G2L["455"]);
G2L["456"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Swimming
G2L["457"] = Instance.new("Sound", G2L["453"]);
G2L["457"]["PlaybackSpeed"] = 1.6;
G2L["457"]["RollOffMaxDistance"] = 150;
G2L["457"]["Volume"] = 0.65;
G2L["457"]["Looped"] = true;
G2L["457"]["Name"] = [[Swimming]];
G2L["457"]["RollOffMinDistance"] = 5;
G2L["457"]["SoundId"] = [[rbxasset://sounds/action_swim.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Swimming.CharacterSoundEvent
G2L["458"] = Instance.new("RemoteEvent", G2L["457"]);
G2L["458"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Running
G2L["459"] = Instance.new("Sound", G2L["453"]);
G2L["459"]["TimePosition"] = 0.83446;
G2L["459"]["PlaybackSpeed"] = 1.85;
G2L["459"]["RollOffMaxDistance"] = 150;
G2L["459"]["Volume"] = 0.65;
G2L["459"]["Looped"] = true;
G2L["459"]["Name"] = [[Running]];
G2L["459"]["RollOffMinDistance"] = 5;
G2L["459"]["SoundId"] = [[rbxasset://sounds/action_footsteps_plastic.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Running.CharacterSoundEvent
G2L["45a"] = Instance.new("RemoteEvent", G2L["459"]);
G2L["45a"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Splash
G2L["45b"] = Instance.new("Sound", G2L["453"]);
G2L["45b"]["RollOffMaxDistance"] = 150;
G2L["45b"]["Volume"] = 0.65;
G2L["45b"]["Name"] = [[Splash]];
G2L["45b"]["RollOffMinDistance"] = 5;
G2L["45b"]["SoundId"] = [[rbxasset://sounds/impact_water.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Splash.CharacterSoundEvent
G2L["45c"] = Instance.new("RemoteEvent", G2L["45b"]);
G2L["45c"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Landing
G2L["45d"] = Instance.new("Sound", G2L["453"]);
G2L["45d"]["RollOffMaxDistance"] = 150;
G2L["45d"]["Volume"] = 0.65;
G2L["45d"]["Name"] = [[Landing]];
G2L["45d"]["RollOffMinDistance"] = 5;
G2L["45d"]["SoundId"] = [[rbxasset://sounds/action_jump_land.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Landing.CharacterSoundEvent
G2L["45e"] = Instance.new("RemoteEvent", G2L["45d"]);
G2L["45e"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Jumping
G2L["45f"] = Instance.new("Sound", G2L["453"]);
G2L["45f"]["RollOffMaxDistance"] = 150;
G2L["45f"]["Volume"] = 0.65;
G2L["45f"]["Name"] = [[Jumping]];
G2L["45f"]["RollOffMinDistance"] = 5;
G2L["45f"]["SoundId"] = [[rbxasset://sounds/action_jump.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Jumping.CharacterSoundEvent
G2L["460"] = Instance.new("RemoteEvent", G2L["45f"]);
G2L["460"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.FreeFalling
G2L["461"] = Instance.new("Sound", G2L["453"]);
G2L["461"]["TimePosition"] = 0.11429;
G2L["461"]["RollOffMaxDistance"] = 150;
G2L["461"]["Volume"] = 0.65;
G2L["461"]["Looped"] = true;
G2L["461"]["Name"] = [[FreeFalling]];
G2L["461"]["RollOffMinDistance"] = 5;
G2L["461"]["SoundId"] = [[rbxasset://sounds/action_falling.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.FreeFalling.CharacterSoundEvent
G2L["462"] = Instance.new("RemoteEvent", G2L["461"]);
G2L["462"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Died
G2L["463"] = Instance.new("Sound", G2L["453"]);
G2L["463"]["RollOffMaxDistance"] = 150;
G2L["463"]["Volume"] = 0.65;
G2L["463"]["Name"] = [[Died]];
G2L["463"]["RollOffMinDistance"] = 5;
G2L["463"]["SoundId"] = [[rbxasset://sounds/uuhhh.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Died.CharacterSoundEvent
G2L["464"] = Instance.new("RemoteEvent", G2L["463"]);
G2L["464"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.GettingUp
G2L["465"] = Instance.new("Sound", G2L["453"]);
G2L["465"]["RollOffMaxDistance"] = 150;
G2L["465"]["Volume"] = 0.65;
G2L["465"]["Name"] = [[GettingUp]];
G2L["465"]["RollOffMinDistance"] = 5;
G2L["465"]["SoundId"] = [[rbxasset://sounds/action_get_up.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.GettingUp.CharacterSoundEvent
G2L["466"] = Instance.new("RemoteEvent", G2L["465"]);
G2L["466"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.FaceCenterAttachment
G2L["467"] = Instance.new("Attachment", G2L["453"]);
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["467"]["Name"] = [[FaceCenterAttachment]];
G2L["467"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.FaceFrontAttachment
G2L["468"] = Instance.new("Attachment", G2L["453"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["468"]["Name"] = [[FaceFrontAttachment]];
G2L["468"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.HatAttachment
G2L["469"] = Instance.new("Attachment", G2L["453"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["469"]["Name"] = [[HatAttachment]];
G2L["469"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.HairAttachment
G2L["46a"] = Instance.new("Attachment", G2L["453"]);
-- [ERROR] cannot convert CFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
-- [ERROR] cannot convert WorldCFrame, please report to "https://github.com/uniquadev/GuiToLuaConverter/issues"
G2L["46a"]["Name"] = [[HairAttachment]];
G2L["46a"]["WorldAxis"] = Vector3.new(0, 0, 1);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Mesh
G2L["46b"] = Instance.new("SpecialMesh", G2L["453"]);
G2L["46b"]["Scale"] = Vector3.new(1.25, 1.25, 1.25);


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.CharacterSoundEvent
G2L["46c"] = Instance.new("RemoteEvent", G2L["453"]);
G2L["46c"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.GettingUp
G2L["46d"] = Instance.new("Sound", G2L["453"]);
G2L["46d"]["RollOffMaxDistance"] = 150;
G2L["46d"]["Volume"] = 0.65;
G2L["46d"]["Name"] = [[GettingUp]];
G2L["46d"]["RollOffMinDistance"] = 5;
G2L["46d"]["SoundId"] = [[rbxasset://sounds/action_get_up.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.GettingUp.CharacterSoundEvent
G2L["46e"] = Instance.new("RemoteEvent", G2L["46d"]);
G2L["46e"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Died
G2L["46f"] = Instance.new("Sound", G2L["453"]);
G2L["46f"]["RollOffMaxDistance"] = 150;
G2L["46f"]["Volume"] = 0.65;
G2L["46f"]["Name"] = [[Died]];
G2L["46f"]["RollOffMinDistance"] = 5;
G2L["46f"]["SoundId"] = [[rbxasset://sounds/uuhhh.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Died.CharacterSoundEvent
G2L["470"] = Instance.new("RemoteEvent", G2L["46f"]);
G2L["470"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.FreeFalling
G2L["471"] = Instance.new("Sound", G2L["453"]);
G2L["471"]["RollOffMaxDistance"] = 150;
G2L["471"]["Volume"] = 0.65;
G2L["471"]["Looped"] = true;
G2L["471"]["Name"] = [[FreeFalling]];
G2L["471"]["RollOffMinDistance"] = 5;
G2L["471"]["SoundId"] = [[rbxasset://sounds/action_falling.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.FreeFalling.CharacterSoundEvent
G2L["472"] = Instance.new("RemoteEvent", G2L["471"]);
G2L["472"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Jumping
G2L["473"] = Instance.new("Sound", G2L["453"]);
G2L["473"]["RollOffMaxDistance"] = 150;
G2L["473"]["Volume"] = 0.65;
G2L["473"]["Name"] = [[Jumping]];
G2L["473"]["RollOffMinDistance"] = 5;
G2L["473"]["SoundId"] = [[rbxasset://sounds/action_jump.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Jumping.CharacterSoundEvent
G2L["474"] = Instance.new("RemoteEvent", G2L["473"]);
G2L["474"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Landing
G2L["475"] = Instance.new("Sound", G2L["453"]);
G2L["475"]["RollOffMaxDistance"] = 150;
G2L["475"]["Volume"] = 0.65;
G2L["475"]["Name"] = [[Landing]];
G2L["475"]["RollOffMinDistance"] = 5;
G2L["475"]["SoundId"] = [[rbxasset://sounds/action_jump_land.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Landing.CharacterSoundEvent
G2L["476"] = Instance.new("RemoteEvent", G2L["475"]);
G2L["476"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Splash
G2L["477"] = Instance.new("Sound", G2L["453"]);
G2L["477"]["RollOffMaxDistance"] = 150;
G2L["477"]["Volume"] = 0.65;
G2L["477"]["Name"] = [[Splash]];
G2L["477"]["RollOffMinDistance"] = 5;
G2L["477"]["SoundId"] = [[rbxasset://sounds/impact_water.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Splash.CharacterSoundEvent
G2L["478"] = Instance.new("RemoteEvent", G2L["477"]);
G2L["478"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Running
G2L["479"] = Instance.new("Sound", G2L["453"]);
G2L["479"]["PlaybackSpeed"] = 1.85;
G2L["479"]["RollOffMaxDistance"] = 150;
G2L["479"]["Volume"] = 0.65;
G2L["479"]["Looped"] = true;
G2L["479"]["Name"] = [[Running]];
G2L["479"]["RollOffMinDistance"] = 5;
G2L["479"]["SoundId"] = [[rbxasset://sounds/action_footsteps_plastic.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Running.CharacterSoundEvent
G2L["47a"] = Instance.new("RemoteEvent", G2L["479"]);
G2L["47a"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Swimming
G2L["47b"] = Instance.new("Sound", G2L["453"]);
G2L["47b"]["PlaybackSpeed"] = 1.6;
G2L["47b"]["RollOffMaxDistance"] = 150;
G2L["47b"]["Volume"] = 0.65;
G2L["47b"]["Looped"] = true;
G2L["47b"]["Name"] = [[Swimming]];
G2L["47b"]["RollOffMinDistance"] = 5;
G2L["47b"]["SoundId"] = [[rbxasset://sounds/action_swim.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Swimming.CharacterSoundEvent
G2L["47c"] = Instance.new("RemoteEvent", G2L["47b"]);
G2L["47c"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Climbing
G2L["47d"] = Instance.new("Sound", G2L["453"]);
G2L["47d"]["RollOffMaxDistance"] = 150;
G2L["47d"]["Volume"] = 0.65;
G2L["47d"]["Looped"] = true;
G2L["47d"]["Name"] = [[Climbing]];
G2L["47d"]["RollOffMinDistance"] = 5;
G2L["47d"]["SoundId"] = [[rbxasset://sounds/action_footsteps_plastic.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Climbing.CharacterSoundEvent
G2L["47e"] = Instance.new("RemoteEvent", G2L["47d"]);
G2L["47e"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.GettingUp
G2L["47f"] = Instance.new("Sound", G2L["453"]);
G2L["47f"]["RollOffMaxDistance"] = 150;
G2L["47f"]["Volume"] = 0.65;
G2L["47f"]["Name"] = [[GettingUp]];
G2L["47f"]["RollOffMinDistance"] = 5;
G2L["47f"]["SoundId"] = [[rbxasset://sounds/action_get_up.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.GettingUp.CharacterSoundEvent
G2L["480"] = Instance.new("RemoteEvent", G2L["47f"]);
G2L["480"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Died
G2L["481"] = Instance.new("Sound", G2L["453"]);
G2L["481"]["RollOffMaxDistance"] = 150;
G2L["481"]["Volume"] = 0.65;
G2L["481"]["Name"] = [[Died]];
G2L["481"]["RollOffMinDistance"] = 5;
G2L["481"]["SoundId"] = [[rbxasset://sounds/uuhhh.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Died.CharacterSoundEvent
G2L["482"] = Instance.new("RemoteEvent", G2L["481"]);
G2L["482"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.FreeFalling
G2L["483"] = Instance.new("Sound", G2L["453"]);
G2L["483"]["RollOffMaxDistance"] = 150;
G2L["483"]["Volume"] = 0.65;
G2L["483"]["Looped"] = true;
G2L["483"]["Name"] = [[FreeFalling]];
G2L["483"]["RollOffMinDistance"] = 5;
G2L["483"]["SoundId"] = [[rbxasset://sounds/action_falling.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.FreeFalling.CharacterSoundEvent
G2L["484"] = Instance.new("RemoteEvent", G2L["483"]);
G2L["484"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Jumping
G2L["485"] = Instance.new("Sound", G2L["453"]);
G2L["485"]["RollOffMaxDistance"] = 150;
G2L["485"]["Volume"] = 0.65;
G2L["485"]["Name"] = [[Jumping]];
G2L["485"]["RollOffMinDistance"] = 5;
G2L["485"]["SoundId"] = [[rbxasset://sounds/action_jump.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Jumping.CharacterSoundEvent
G2L["486"] = Instance.new("RemoteEvent", G2L["485"]);
G2L["486"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Landing
G2L["487"] = Instance.new("Sound", G2L["453"]);
G2L["487"]["RollOffMaxDistance"] = 150;
G2L["487"]["Volume"] = 0.65;
G2L["487"]["Name"] = [[Landing]];
G2L["487"]["RollOffMinDistance"] = 5;
G2L["487"]["SoundId"] = [[rbxasset://sounds/action_jump_land.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Landing.CharacterSoundEvent
G2L["488"] = Instance.new("RemoteEvent", G2L["487"]);
G2L["488"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Splash
G2L["489"] = Instance.new("Sound", G2L["453"]);
G2L["489"]["RollOffMaxDistance"] = 150;
G2L["489"]["Volume"] = 0.65;
G2L["489"]["Name"] = [[Splash]];
G2L["489"]["RollOffMinDistance"] = 5;
G2L["489"]["SoundId"] = [[rbxasset://sounds/impact_water.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Splash.CharacterSoundEvent
G2L["48a"] = Instance.new("RemoteEvent", G2L["489"]);
G2L["48a"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Running
G2L["48b"] = Instance.new("Sound", G2L["453"]);
G2L["48b"]["PlaybackSpeed"] = 1.85;
G2L["48b"]["RollOffMaxDistance"] = 150;
G2L["48b"]["Volume"] = 0.65;
G2L["48b"]["Looped"] = true;
G2L["48b"]["Name"] = [[Running]];
G2L["48b"]["RollOffMinDistance"] = 5;
G2L["48b"]["SoundId"] = [[rbxasset://sounds/action_footsteps_plastic.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Running.CharacterSoundEvent
G2L["48c"] = Instance.new("RemoteEvent", G2L["48b"]);
G2L["48c"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Swimming
G2L["48d"] = Instance.new("Sound", G2L["453"]);
G2L["48d"]["PlaybackSpeed"] = 1.6;
G2L["48d"]["RollOffMaxDistance"] = 150;
G2L["48d"]["Volume"] = 0.65;
G2L["48d"]["Looped"] = true;
G2L["48d"]["Name"] = [[Swimming]];
G2L["48d"]["RollOffMinDistance"] = 5;
G2L["48d"]["SoundId"] = [[rbxasset://sounds/action_swim.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Swimming.CharacterSoundEvent
G2L["48e"] = Instance.new("RemoteEvent", G2L["48d"]);
G2L["48e"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Climbing
G2L["48f"] = Instance.new("Sound", G2L["453"]);
G2L["48f"]["RollOffMaxDistance"] = 150;
G2L["48f"]["Volume"] = 0.65;
G2L["48f"]["Looped"] = true;
G2L["48f"]["Name"] = [[Climbing]];
G2L["48f"]["RollOffMinDistance"] = 5;
G2L["48f"]["SoundId"] = [[rbxasset://sounds/action_footsteps_plastic.mp3]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Head.Climbing.CharacterSoundEvent
G2L["490"] = Instance.new("RemoteEvent", G2L["48f"]);
G2L["490"]["Name"] = [[CharacterSoundEvent]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.TextHider
G2L["491"] = Instance.new("TextButton", G2L["3ff"]);
G2L["491"]["TextWrapped"] = true;
G2L["491"]["BorderSizePixel"] = 3;
G2L["491"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["491"]["TextSize"] = 20;
G2L["491"]["BackgroundColor3"] = Color3.fromRGB(0, 86, 0);
G2L["491"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["491"]["Size"] = UDim2.new(0, 120, 1, 0);
G2L["491"]["Name"] = [[TextHider]];
G2L["491"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["491"]["Text"] = [[Hide text]];


-- StarterGui.ScreenGui.cool.Main.BottomRow.TextHider.LocalScript
G2L["492"] = Instance.new("LocalScript", G2L["491"]);



-- StarterGui.ScreenGui.cool.Main.SideRow
G2L["493"] = Instance.new("Frame", G2L["3fa"]);
G2L["493"]["BorderSizePixel"] = 0;
G2L["493"]["BackgroundColor3"] = Color3.fromRGB(49, 49, 49);
G2L["493"]["Size"] = UDim2.new(0, 145, 0, 252);
G2L["493"]["Position"] = UDim2.new(1, 0, 0, 0);
G2L["493"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["493"]["Name"] = [[SideRow]];


-- StarterGui.ScreenGui.cool.Main.SideRow.Title
G2L["494"] = Instance.new("TextLabel", G2L["493"]);
G2L["494"]["BorderSizePixel"] = 0;
G2L["494"]["TextSize"] = 20;
G2L["494"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["494"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["494"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["494"]["BackgroundTransparency"] = 1;
G2L["494"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["494"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["494"]["Text"] = [[--scripts--]];
G2L["494"]["Name"] = [[Title]];


-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll
G2L["495"] = Instance.new("ScrollingFrame", G2L["493"]);
G2L["495"]["Active"] = true;
G2L["495"]["BorderSizePixel"] = 0;
G2L["495"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["495"]["Name"] = [[SideRowScroll]];
G2L["495"]["Size"] = UDim2.new(0, 135, 0, 219);
G2L["495"]["Position"] = UDim2.new(0, 0, 0.09921, 0);
G2L["495"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["495"]["ScrollBarThickness"] = 5;
G2L["495"]["BackgroundTransparency"] = 1;


-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.UIListLayout
G2L["496"] = Instance.new("UIListLayout", G2L["495"]);
G2L["496"]["Padding"] = UDim.new(0, 5);
G2L["496"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.GrabKnife
G2L["497"] = Instance.new("TextButton", G2L["495"]);
G2L["497"]["TextWrapped"] = true;
G2L["497"]["BorderSizePixel"] = 0;
G2L["497"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["497"]["TextSize"] = 15;
G2L["497"]["TextScaled"] = true;
G2L["497"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["497"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["497"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["497"]["Name"] = [[GrabKnife]];
G2L["497"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["497"]["Text"] = [[Grab Knife V4 (not new)]];
G2L["497"]["Position"] = UDim2.new(0, 0, -0.04699, 0);


-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.GrabKnife.Script
G2L["498"] = Instance.new("Script", G2L["497"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.Infyield
G2L["499"] = Instance.new("TextButton", G2L["495"]);
G2L["499"]["TextWrapped"] = true;
G2L["499"]["BorderSizePixel"] = 0;
G2L["499"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["499"]["TextSize"] = 15;
G2L["499"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["499"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["499"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["499"]["Name"] = [[Infyield]];
G2L["499"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["499"]["Text"] = [[Infinite Yield]];


-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.Infyield.Script
G2L["49a"] = Instance.new("Script", G2L["499"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.KickButton
G2L["49b"] = Instance.new("TextButton", G2L["495"]);
G2L["49b"]["TextWrapped"] = true;
G2L["49b"]["BorderSizePixel"] = 0;
G2L["49b"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["49b"]["TextSize"] = 15;
G2L["49b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["49b"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["49b"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["49b"]["Name"] = [[KickButton]];
G2L["49b"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["49b"]["Text"] = [[Kick Player]];


-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.KickButton.Script
G2L["49c"] = Instance.new("Script", G2L["49b"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.PlayerGuiClean
G2L["49d"] = Instance.new("TextButton", G2L["495"]);
G2L["49d"]["TextWrapped"] = true;
G2L["49d"]["BorderSizePixel"] = 0;
G2L["49d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["49d"]["TextSize"] = 15;
G2L["49d"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["49d"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["49d"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["49d"]["Name"] = [[PlayerGuiClean]];
G2L["49d"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["49d"]["Text"] = [[Clear PlayerGui (Local)]];


-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.PlayerGuiClean.LocalScript
G2L["49e"] = Instance.new("LocalScript", G2L["49d"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.TH8_2
G2L["49f"] = Instance.new("TextButton", G2L["495"]);
G2L["49f"]["TextWrapped"] = true;
G2L["49f"]["BorderSizePixel"] = 0;
G2L["49f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["49f"]["TextSize"] = 15;
G2L["49f"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["49f"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["49f"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["49f"]["Name"] = [[TH8_2]];
G2L["49f"]["Text"] = [[k00p v10]];


-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.TH8_2.Script
G2L["4a0"] = Instance.new("Script", G2L["49f"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.TH8_2.LocalScript
G2L["4a1"] = Instance.new("LocalScript", G2L["49f"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.TH8_2.RemoteEvent
G2L["4a2"] = Instance.new("RemoteEvent", G2L["49f"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.DexExplorer
G2L["4a3"] = Instance.new("TextButton", G2L["495"]);
G2L["4a3"]["TextWrapped"] = true;
G2L["4a3"]["BorderSizePixel"] = 0;
G2L["4a3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4a3"]["TextSize"] = 15;
G2L["4a3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4a3"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4a3"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["4a3"]["Name"] = [[DexExplorer]];
G2L["4a3"]["Text"] = [[SkidHub]];


-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.DexExplorer.Script
G2L["4a4"] = Instance.new("Script", G2L["4a3"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.DexExplorer.LocalScript
G2L["4a5"] = Instance.new("LocalScript", G2L["4a3"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.DexExplorer.RemoteEvent
G2L["4a6"] = Instance.new("RemoteEvent", G2L["4a3"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.GNv4
G2L["4a7"] = Instance.new("TextButton", G2L["495"]);
G2L["4a7"]["TextWrapped"] = true;
G2L["4a7"]["BorderSizePixel"] = 0;
G2L["4a7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4a7"]["TextSize"] = 15;
G2L["4a7"]["TextScaled"] = true;
G2L["4a7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4a7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4a7"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["4a7"]["Name"] = [[GNv4]];
G2L["4a7"]["Text"] = [[k00pgui backdoor edition]];


-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.GNv4.LocalScript
G2L["4a8"] = Instance.new("LocalScript", G2L["4a7"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.GNv4.RemoteEvent
G2L["4a9"] = Instance.new("RemoteEvent", G2L["4a7"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.GNv4.Script
G2L["4aa"] = Instance.new("Script", G2L["4a7"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.SBGR
G2L["4ab"] = Instance.new("TextButton", G2L["495"]);
G2L["4ab"]["TextWrapped"] = true;
G2L["4ab"]["BorderSizePixel"] = 0;
G2L["4ab"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4ab"]["TextSize"] = 15;
G2L["4ab"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4ab"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4ab"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["4ab"]["Name"] = [[SBGR]];
G2L["4ab"]["Text"] = [[secret hub]];


-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.SBGR.Script
G2L["4ac"] = Instance.new("Script", G2L["4ab"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.SBGR.LocalScript
G2L["4ad"] = Instance.new("LocalScript", G2L["4ab"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.SBGR.RemoteEvent
G2L["4ae"] = Instance.new("RemoteEvent", G2L["4ab"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.BIble
G2L["4af"] = Instance.new("TextButton", G2L["495"]);
G2L["4af"]["TextWrapped"] = true;
G2L["4af"]["BorderSizePixel"] = 0;
G2L["4af"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4af"]["TextSize"] = 15;
G2L["4af"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4af"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4af"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["4af"]["Name"] = [[BIble]];
G2L["4af"]["Text"] = [[cxyzkidd v5]];


-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.BIble.LocalScript
G2L["4b0"] = Instance.new("LocalScript", G2L["4af"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.BIble.RemoteEvent
G2L["4b1"] = Instance.new("RemoteEvent", G2L["4af"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.BIble.Script
G2L["4b2"] = Instance.new("Script", G2L["4af"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.Infyield
G2L["4b3"] = Instance.new("TextButton", G2L["495"]);
G2L["4b3"]["TextWrapped"] = true;
G2L["4b3"]["BorderSizePixel"] = 0;
G2L["4b3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4b3"]["TextSize"] = 15;
G2L["4b3"]["TextScaled"] = true;
G2L["4b3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4b3"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4b3"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["4b3"]["Name"] = [[Infyield]];
G2L["4b3"]["Text"] = [[JO1TAR0 server destroyer]];


-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.Infyield.LocalScript
G2L["4b4"] = Instance.new("LocalScript", G2L["4b3"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.Infyield.RemoteEvent
G2L["4b5"] = Instance.new("RemoteEvent", G2L["4b3"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.Infyield.Script
G2L["4b6"] = Instance.new("Script", G2L["4b3"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.Infyield
G2L["4b7"] = Instance.new("TextButton", G2L["495"]);
G2L["4b7"]["TextWrapped"] = true;
G2L["4b7"]["BorderSizePixel"] = 0;
G2L["4b7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4b7"]["TextSize"] = 15;
G2L["4b7"]["TextScaled"] = true;
G2L["4b7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4b7"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4b7"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["4b7"]["Name"] = [[Infyield]];
G2L["4b7"]["Text"] = [[old JO1TAR0 serv destroyer]];


-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.Infyield.Script
G2L["4b8"] = Instance.new("Script", G2L["4b7"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.Infyield.LocalScript
G2L["4b9"] = Instance.new("LocalScript", G2L["4b7"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.Infyield.RemoteEvent
G2L["4ba"] = Instance.new("RemoteEvent", G2L["4b7"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.Infyield
G2L["4bb"] = Instance.new("TextButton", G2L["495"]);
G2L["4bb"]["TextWrapped"] = true;
G2L["4bb"]["BorderSizePixel"] = 0;
G2L["4bb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4bb"]["TextSize"] = 15;
G2L["4bb"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4bb"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4bb"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["4bb"]["Name"] = [[Infyield]];
G2L["4bb"]["Text"] = [[raining tacos]];


-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.Infyield.Script
G2L["4bc"] = Instance.new("Script", G2L["4bb"]);



-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.Infyield
G2L["4bd"] = Instance.new("TextButton", G2L["495"]);
G2L["4bd"]["TextWrapped"] = true;
G2L["4bd"]["BorderSizePixel"] = 0;
G2L["4bd"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4bd"]["TextSize"] = 15;
G2L["4bd"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4bd"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4bd"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["4bd"]["Name"] = [[Infyield]];
G2L["4bd"]["Text"] = [[music]];


-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.Infyield.Script
G2L["4be"] = Instance.new("Script", G2L["4bd"]);



-- StarterGui.ScreenGui.cool.Main.LocalScript
G2L["4bf"] = Instance.new("LocalScript", G2L["3fa"]);



-- StarterGui.ScreenGui.cool.Main.Middle
G2L["4c0"] = Instance.new("Frame", G2L["3fa"]);
G2L["4c0"]["BorderSizePixel"] = 0;
G2L["4c0"]["BackgroundColor3"] = Color3.fromRGB(49, 49, 49);
G2L["4c0"]["Size"] = UDim2.new(0, 446, 0, 162);
G2L["4c0"]["Position"] = UDim2.new(0, 0, 0.164, 0);
G2L["4c0"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4c0"]["Name"] = [[Middle]];


-- StarterGui.ScreenGui.cool.Main.Middle.ExecuteBox
G2L["4c1"] = Instance.new("TextBox", G2L["4c0"]);
G2L["4c1"]["Name"] = [[ExecuteBox]];
G2L["4c1"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["4c1"]["BorderSizePixel"] = 0;
G2L["4c1"]["TextWrapped"] = true;
G2L["4c1"]["TextSize"] = 20;
G2L["4c1"]["TextColor3"] = Color3.fromRGB(122, 180, 255);
G2L["4c1"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["4c1"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4c1"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4c1"]["ClearTextOnFocus"] = false;
G2L["4c1"]["PlaceholderText"] = [[--script here]];
G2L["4c1"]["Size"] = UDim2.new(0, 446, 0, 162);
G2L["4c1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4c1"]["Text"] = [[]];


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing
G2L["4c2"] = Instance.new("Frame", G2L["4c0"]);
G2L["4c2"]["Visible"] = false;
G2L["4c2"]["BorderSizePixel"] = 0;
G2L["4c2"]["BackgroundColor3"] = Color3.fromRGB(58, 58, 58);
G2L["4c2"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["4c2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4c2"]["Name"] = [[MiddleFrameThing]];


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing.Settings
G2L["4c3"] = Instance.new("Frame", G2L["4c2"]);
G2L["4c3"]["Visible"] = false;
G2L["4c3"]["BorderSizePixel"] = 0;
G2L["4c3"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4c3"]["Size"] = UDim2.new(0, 446, 0, 162);
G2L["4c3"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4c3"]["Name"] = [[Settings]];
G2L["4c3"]["BackgroundTransparency"] = 1;


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing.Settings.Title
G2L["4c4"] = Instance.new("TextLabel", G2L["4c3"]);
G2L["4c4"]["TextSize"] = 20;
G2L["4c4"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4c4"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4c4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4c4"]["BackgroundTransparency"] = 1;
G2L["4c4"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["4c4"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4c4"]["Text"] = [[Settings]];
G2L["4c4"]["Name"] = [[Title]];


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing.Settings.Text
G2L["4c5"] = Instance.new("TextLabel", G2L["4c3"]);
G2L["4c5"]["TextSize"] = 20;
G2L["4c5"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4c5"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4c5"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4c5"]["BackgroundTransparency"] = 1;
G2L["4c5"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["4c5"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4c5"]["Text"] = [[Soon]];
G2L["4c5"]["Name"] = [[Text]];
G2L["4c5"]["Position"] = UDim2.new(0, 0, 0.43827, 0);


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing.Credits
G2L["4c6"] = Instance.new("Frame", G2L["4c2"]);
G2L["4c6"]["Visible"] = false;
G2L["4c6"]["BorderSizePixel"] = 0;
G2L["4c6"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4c6"]["Size"] = UDim2.new(0, 435, 0, 162);
G2L["4c6"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4c6"]["Name"] = [[Credits]];
G2L["4c6"]["BackgroundTransparency"] = 1;


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing.Credits.Scroll
G2L["4c7"] = Instance.new("ScrollingFrame", G2L["4c6"]);
G2L["4c7"]["Active"] = true;
G2L["4c7"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4c7"]["Name"] = [[Scroll]];
G2L["4c7"]["Size"] = UDim2.new(0, 446, 0, 162);
G2L["4c7"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4c7"]["ScrollBarThickness"] = 5;
G2L["4c7"]["BackgroundTransparency"] = 1;


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing.Credits.Scroll.UIListLayout
G2L["4c8"] = Instance.new("UIListLayout", G2L["4c7"]);
G2L["4c8"]["Padding"] = UDim.new(0, 10);
G2L["4c8"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing.Credits.Scroll.Credit
G2L["4c9"] = Instance.new("TextLabel", G2L["4c7"]);
G2L["4c9"]["TextSize"] = 20;
G2L["4c9"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4c9"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4c9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4c9"]["BackgroundTransparency"] = 1;
G2L["4c9"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["4c9"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4c9"]["Text"] = [[Creation/Design: nvhiy]];
G2L["4c9"]["Name"] = [[Credit]];


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing.Credits.Scroll.Credit
G2L["4ca"] = Instance.new("TextLabel", G2L["4c7"]);
G2L["4ca"]["TextSize"] = 20;
G2L["4ca"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4ca"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4ca"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4ca"]["BackgroundTransparency"] = 1;
G2L["4ca"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["4ca"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4ca"]["Text"] = [[Scripting: nvhiy]];
G2L["4ca"]["Name"] = [[Credit]];


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing.Credits.Scroll.Credit
G2L["4cb"] = Instance.new("TextLabel", G2L["4c7"]);
G2L["4cb"]["TextSize"] = 20;
G2L["4cb"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4cb"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4cb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4cb"]["BackgroundTransparency"] = 1;
G2L["4cb"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["4cb"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4cb"]["Text"] = [[Scripts: coming soon]];
G2L["4cb"]["Name"] = [[Credit]];


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing.Credits.Scroll.Title
G2L["4cc"] = Instance.new("TextLabel", G2L["4c7"]);
G2L["4cc"]["TextSize"] = 20;
G2L["4cc"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4cc"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4cc"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4cc"]["BackgroundTransparency"] = 1;
G2L["4cc"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["4cc"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4cc"]["Text"] = [[Credits]];
G2L["4cc"]["Name"] = [[Title]];


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing.ChangeLog
G2L["4cd"] = Instance.new("Frame", G2L["4c2"]);
G2L["4cd"]["BorderSizePixel"] = 0;
G2L["4cd"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4cd"]["Size"] = UDim2.new(0, 435, 0, 162);
G2L["4cd"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4cd"]["Name"] = [[ChangeLog]];
G2L["4cd"]["BackgroundTransparency"] = 1;


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing.ChangeLog.Scroll
G2L["4ce"] = Instance.new("ScrollingFrame", G2L["4cd"]);
G2L["4ce"]["Active"] = true;
G2L["4ce"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4ce"]["Name"] = [[Scroll]];
G2L["4ce"]["Size"] = UDim2.new(0, 446, 0, 162);
G2L["4ce"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4ce"]["ScrollBarThickness"] = 5;
G2L["4ce"]["BackgroundTransparency"] = 1;


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing.ChangeLog.Scroll.Title
G2L["4cf"] = Instance.new("TextLabel", G2L["4ce"]);
G2L["4cf"]["TextSize"] = 20;
G2L["4cf"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4cf"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4cf"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4cf"]["BackgroundTransparency"] = 1;
G2L["4cf"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["4cf"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4cf"]["Text"] = [[Change Log]];
G2L["4cf"]["Name"] = [[Title]];


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing.ChangeLog.Scroll.UIListLayout
G2L["4d0"] = Instance.new("UIListLayout", G2L["4ce"]);
G2L["4d0"]["Padding"] = UDim.new(0, 10);
G2L["4d0"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing.ChangeLog.Scroll.Log
G2L["4d1"] = Instance.new("TextLabel", G2L["4ce"]);
G2L["4d1"]["TextSize"] = 20;
G2L["4d1"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4d1"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4d1"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4d1"]["BackgroundTransparency"] = 1;
G2L["4d1"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["4d1"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4d1"]["Text"] = [[V1: Creation]];
G2L["4d1"]["Name"] = [[Log]];


-- StarterGui.ScreenGui.cool.Main.Middle.MiddleFrameThing.ChangeLog.Scroll.Log
G2L["4d2"] = Instance.new("TextLabel", G2L["4ce"]);
G2L["4d2"]["TextSize"] = 20;
G2L["4d2"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4d2"]["FontFace"] = Font.new([[rbxasset://fonts/families/Inconsolata.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4d2"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4d2"]["BackgroundTransparency"] = 1;
G2L["4d2"]["Size"] = UDim2.new(1, 0, 0, 20);
G2L["4d2"]["BorderColor3"] = Color3.fromRGB(28, 43, 54);
G2L["4d2"]["Text"] = [[V1.1: Updated Grab Knife and added 4 scripts]];
G2L["4d2"]["Name"] = [[Log]];


-- StarterGui.ScreenGui.cool.Main.Smooth GUI Dragging
G2L["4d3"] = Instance.new("LocalScript", G2L["3fa"]);
G2L["4d3"]["Name"] = [[Smooth GUI Dragging]];


-- StarterGui.ScreenGui.cool.Main.TextButton
G2L["4d4"] = Instance.new("TextButton", G2L["3fa"]);
G2L["4d4"]["TextWrapped"] = true;
G2L["4d4"]["BorderSizePixel"] = 3;
G2L["4d4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4d4"]["TextSize"] = 14;
G2L["4d4"]["TextScaled"] = true;
G2L["4d4"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4d4"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4d4"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["4d4"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["4d4"]["Text"] = [[Page 1]];
G2L["4d4"]["Position"] = UDim2.new(0, 0, -0.216, 0);


-- StarterGui.ScreenGui.cool.Main.TextButton.LocalScript
G2L["4d5"] = Instance.new("LocalScript", G2L["4d4"]);



-- StarterGui.ScreenGui.cool.Main.TextButton
G2L["4d6"] = Instance.new("TextButton", G2L["3fa"]);
G2L["4d6"]["TextWrapped"] = true;
G2L["4d6"]["BorderSizePixel"] = 3;
G2L["4d6"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4d6"]["TextSize"] = 14;
G2L["4d6"]["TextScaled"] = true;
G2L["4d6"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4d6"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4d6"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["4d6"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["4d6"]["Text"] = [[Page 2]];
G2L["4d6"]["Position"] = UDim2.new(0.49552, 0, -0.216, 0);


-- StarterGui.ScreenGui.cool.Main.TextButton.LocalScript
G2L["4d7"] = Instance.new("LocalScript", G2L["4d6"]);



-- StarterGui.ScreenGui.cool.Main.TextButton
G2L["4d8"] = Instance.new("TextButton", G2L["3fa"]);
G2L["4d8"]["TextWrapped"] = true;
G2L["4d8"]["BorderSizePixel"] = 3;
G2L["4d8"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4d8"]["TextSize"] = 14;
G2L["4d8"]["TextScaled"] = true;
G2L["4d8"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4d8"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4d8"]["Size"] = UDim2.new(0, 157, 0, 50);
G2L["4d8"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["4d8"]["Text"] = [[Page 4]];
G2L["4d8"]["Position"] = UDim2.new(0.96637, 0, -0.216, 0);


-- StarterGui.ScreenGui.cool.Main.TextButton.LocalScript
G2L["4d9"] = Instance.new("LocalScript", G2L["4d8"]);



-- StarterGui.ScreenGui.cool.Main.TextButton
G2L["4da"] = Instance.new("TextButton", G2L["3fa"]);
G2L["4da"]["TextWrapped"] = true;
G2L["4da"]["BorderSizePixel"] = 3;
G2L["4da"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4da"]["TextSize"] = 14;
G2L["4da"]["TextScaled"] = true;
G2L["4da"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4da"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4da"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["4da"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["4da"]["Text"] = [[Page 5]];
G2L["4da"]["Position"] = UDim2.new(0, 0, -0.456, 0);


-- StarterGui.ScreenGui.cool.Main.TextButton.LocalScript
G2L["4db"] = Instance.new("LocalScript", G2L["4da"]);



-- StarterGui.ScreenGui.cool.Main.TextButton
G2L["4dc"] = Instance.new("TextButton", G2L["3fa"]);
G2L["4dc"]["TextWrapped"] = true;
G2L["4dc"]["BorderSizePixel"] = 3;
G2L["4dc"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4dc"]["TextSize"] = 14;
G2L["4dc"]["TextScaled"] = true;
G2L["4dc"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4dc"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4dc"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["4dc"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["4dc"]["Text"] = [[Page 6]];
G2L["4dc"]["Position"] = UDim2.new(0.49103, 0, -0.456, 0);


-- StarterGui.ScreenGui.cool.Main.TextButton.LocalScript
G2L["4dd"] = Instance.new("LocalScript", G2L["4dc"]);



-- StarterGui.ScreenGui.cool.Main.TextButton
G2L["4de"] = Instance.new("TextButton", G2L["3fa"]);
G2L["4de"]["TextWrapped"] = true;
G2L["4de"]["BorderSizePixel"] = 3;
G2L["4de"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4de"]["TextSize"] = 14;
G2L["4de"]["TextScaled"] = true;
G2L["4de"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4de"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4de"]["Size"] = UDim2.new(0, 157, 0, 50);
G2L["4de"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["4de"]["Text"] = [[Page 7]];
G2L["4de"]["Position"] = UDim2.new(0.96637, 0, -0.456, 0);


-- StarterGui.ScreenGui.cool.Main.TextButton.LocalScript
G2L["4df"] = Instance.new("LocalScript", G2L["4de"]);



-- StarterGui.ScreenGui.cool.Main.TextButton
G2L["4e0"] = Instance.new("TextButton", G2L["3fa"]);
G2L["4e0"]["TextWrapped"] = true;
G2L["4e0"]["BorderSizePixel"] = 3;
G2L["4e0"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4e0"]["TextSize"] = 14;
G2L["4e0"]["TextScaled"] = true;
G2L["4e0"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4e0"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4e0"]["Size"] = UDim2.new(0, 157, 0, 50);
G2L["4e0"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["4e0"]["Text"] = [[Page 8]];
G2L["4e0"]["Position"] = UDim2.new(0.55157, 0, -0.684, 0);


-- StarterGui.ScreenGui.cool.Main.TextButton.LocalScript
G2L["4e1"] = Instance.new("LocalScript", G2L["4e0"]);



-- StarterGui.ScreenGui.cool.Frame
G2L["4e2"] = Instance.new("Frame", G2L["2"]);
G2L["4e2"]["Visible"] = false;
G2L["4e2"]["BorderSizePixel"] = 0;
G2L["4e2"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4e2"]["Size"] = UDim2.new(0, 458, 0, 329);
G2L["4e2"]["Position"] = UDim2.new(1.55321, 0, 4.24377, 0);
G2L["4e2"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.ScreenGui.cool.Frame.TextLabel
G2L["4e3"] = Instance.new("TextLabel", G2L["4e2"]);
G2L["4e3"]["TextWrapped"] = true;
G2L["4e3"]["BorderSizePixel"] = 3;
G2L["4e3"]["TextSize"] = 14;
G2L["4e3"]["TextScaled"] = true;
G2L["4e3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4e3"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4e3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4e3"]["Size"] = UDim2.new(0, 200, 0, 50);
G2L["4e3"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["4e3"]["Text"] = [[K00p  v4 op remake by Zelow]];
G2L["4e3"]["Position"] = UDim2.new(0.27948, 0, 0.02432, 0);


-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton
G2L["4e4"] = Instance.new("TextButton", G2L["4e3"]);
G2L["4e4"]["TextWrapped"] = true;
G2L["4e4"]["BorderSizePixel"] = 3;
G2L["4e4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4e4"]["TextSize"] = 14;
G2L["4e4"]["TextScaled"] = true;
G2L["4e4"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4e4"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4e4"]["Size"] = UDim2.new(0, 137, 0, 43);
G2L["4e4"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["4e4"]["Text"] = [[trollface face all]];
G2L["4e4"]["Position"] = UDim2.new(-0.575, 0, 1.46, 0);


-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.Script
G2L["4e5"] = Instance.new("Script", G2L["4e4"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.Script.Trollface
G2L["4e6"] = Instance.new("Decal", G2L["4e5"]);
G2L["4e6"]["Name"] = [[Trollface]];
G2L["4e6"]["Texture"] = [[http://www.roblox.com/asset/?id=8126977748]];


-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton
G2L["4e7"] = Instance.new("TextButton", G2L["4e3"]);
G2L["4e7"]["TextWrapped"] = true;
G2L["4e7"]["BorderSizePixel"] = 3;
G2L["4e7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4e7"]["TextSize"] = 14;
G2L["4e7"]["TextScaled"] = true;
G2L["4e7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4e7"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4e7"]["Size"] = UDim2.new(0, 137, 0, 43);
G2L["4e7"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["4e7"]["Text"] = [[UTG reborn]];
G2L["4e7"]["Position"] = UDim2.new(0.215, 0, 1.46, 0);


-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.Script
G2L["4e8"] = Instance.new("Script", G2L["4e7"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.LocalScript
G2L["4e9"] = Instance.new("LocalScript", G2L["4e7"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.RemoteEvent
G2L["4ea"] = Instance.new("RemoteEvent", G2L["4e7"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton
G2L["4eb"] = Instance.new("TextButton", G2L["4e3"]);
G2L["4eb"]["TextWrapped"] = true;
G2L["4eb"]["BorderSizePixel"] = 3;
G2L["4eb"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4eb"]["TextSize"] = 14;
G2L["4eb"]["TextScaled"] = true;
G2L["4eb"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4eb"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4eb"]["Size"] = UDim2.new(0, 125, 0, 43);
G2L["4eb"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["4eb"]["Text"] = [[kill all]];
G2L["4eb"]["Position"] = UDim2.new(0.965, 0, 1.46, 0);


-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.Script
G2L["4ec"] = Instance.new("Script", G2L["4eb"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.LocalScript
G2L["4ed"] = Instance.new("LocalScript", G2L["4eb"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.RemoteEvent
G2L["4ee"] = Instance.new("RemoteEvent", G2L["4eb"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton
G2L["4ef"] = Instance.new("TextButton", G2L["4e3"]);
G2L["4ef"]["TextWrapped"] = true;
G2L["4ef"]["BorderSizePixel"] = 3;
G2L["4ef"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4ef"]["TextSize"] = 14;
G2L["4ef"]["TextScaled"] = true;
G2L["4ef"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4ef"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4ef"]["Size"] = UDim2.new(0, 137, 0, 43);
G2L["4ef"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["4ef"]["Text"] = [[low hp all]];
G2L["4ef"]["Position"] = UDim2.new(-0.575, 0, 2.54, 0);


-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.Script
G2L["4f0"] = Instance.new("Script", G2L["4ef"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.LocalScript
G2L["4f1"] = Instance.new("LocalScript", G2L["4ef"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.RemoteEvent
G2L["4f2"] = Instance.new("RemoteEvent", G2L["4ef"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton
G2L["4f3"] = Instance.new("TextButton", G2L["4e3"]);
G2L["4f3"]["TextWrapped"] = true;
G2L["4f3"]["BorderSizePixel"] = 3;
G2L["4f3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4f3"]["TextSize"] = 14;
G2L["4f3"]["TextScaled"] = true;
G2L["4f3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4f3"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4f3"]["Size"] = UDim2.new(0, 137, 0, 43);
G2L["4f3"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["4f3"]["Text"] = [[Shutdown]];
G2L["4f3"]["Position"] = UDim2.new(0.215, 0, 2.54, 0);


-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.Script
G2L["4f4"] = Instance.new("Script", G2L["4f3"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.LocalScript
G2L["4f5"] = Instance.new("LocalScript", G2L["4f3"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.RemoteEvent
G2L["4f6"] = Instance.new("RemoteEvent", G2L["4f3"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton
G2L["4f7"] = Instance.new("TextButton", G2L["4e3"]);
G2L["4f7"]["TextWrapped"] = true;
G2L["4f7"]["BorderSizePixel"] = 3;
G2L["4f7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4f7"]["TextSize"] = 14;
G2L["4f7"]["TextScaled"] = true;
G2L["4f7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4f7"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4f7"]["Size"] = UDim2.new(0, 125, 0, 43);
G2L["4f7"]["BorderColor3"] = Color3.fromRGB(0, 86, 0);
G2L["4f7"]["Text"] = [[Destroy The Game]];
G2L["4f7"]["Position"] = UDim2.new(0.965, 0, 2.54, 0);


-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.Script
G2L["4f8"] = Instance.new("Script", G2L["4f7"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.LocalScript
G2L["4f9"] = Instance.new("LocalScript", G2L["4f7"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.RemoteEvent
G2L["4fa"] = Instance.new("RemoteEvent", G2L["4f7"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.Script
G2L["4fb"] = Instance.new("Script", G2L["4f7"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.Trollface
G2L["4fc"] = Instance.new("Decal", G2L["4f7"]);
G2L["4fc"]["Name"] = [[Trollface]];
G2L["4fc"]["Texture"] = [[http://www.roblox.com/asset/?id=8126977748]];


-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.Script
G2L["4fd"] = Instance.new("Script", G2L["4f7"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.Script.Transparent Trollface
G2L["4fe"] = Instance.new("Decal", G2L["4fd"]);
G2L["4fe"]["Name"] = [[Transparent Trollface]];
G2L["4fe"]["Texture"] = [[http://www.roblox.com/asset/?id=6579035058]];


-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.Script
G2L["4ff"] = Instance.new("Script", G2L["4f7"]);



-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.Trollface
G2L["500"] = Instance.new("Decal", G2L["4f7"]);
G2L["500"]["Name"] = [[Trollface]];
G2L["500"]["Texture"] = [[http://www.roblox.com/asset/?id=8126977748]];


-- StarterGui.ScreenGui.cool.PasswordFrame
G2L["501"] = Instance.new("Frame", G2L["2"]);
G2L["501"]["BorderSizePixel"] = 0;
G2L["501"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["501"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["501"]["Size"] = UDim2.new(0, 594, 0, 471);
G2L["501"]["Position"] = UDim2.new(7.60724, 0, 4.21, 0);
G2L["501"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["501"]["Name"] = [[PasswordFrame]];


-- StarterGui.ScreenGui.cool.PasswordFrame.UICorner
G2L["502"] = Instance.new("UICorner", G2L["501"]);



-- StarterGui.ScreenGui.cool.PasswordFrame.TextBox
G2L["503"] = Instance.new("TextBox", G2L["501"]);
G2L["503"]["BorderSizePixel"] = 0;
G2L["503"]["TextWrapped"] = true;
G2L["503"]["TextSize"] = 24;
G2L["503"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["503"]["TextScaled"] = true;
G2L["503"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["503"]["FontFace"] = Font.new([[rbxasset://fonts/families/HighwayGothic.json]], Enum.FontWeight.Bold, Enum.FontStyle.Italic);
G2L["503"]["Size"] = UDim2.new(0.62175, 0, 0.23944, 0);
G2L["503"]["Position"] = UDim2.new(0.19616, 0, 0.27273, 0);
G2L["503"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["503"]["Text"] = [[]];


-- StarterGui.ScreenGui.cool.PasswordFrame.TextBox.UIStroke
G2L["504"] = Instance.new("UIStroke", G2L["503"]);
G2L["504"]["Thickness"] = 4;
G2L["504"]["Color"] = Color3.fromRGB(0, 86, 0);


-- StarterGui.ScreenGui.cool.PasswordFrame.TextBox.UICorner
G2L["505"] = Instance.new("UICorner", G2L["503"]);



-- StarterGui.ScreenGui.cool.PasswordFrame.TextBox.UIStroke
G2L["506"] = Instance.new("UIStroke", G2L["503"]);
G2L["506"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["506"]["Thickness"] = 7;
G2L["506"]["Color"] = Color3.fromRGB(0, 86, 0);


-- StarterGui.ScreenGui.cool.PasswordFrame.UIStroke
G2L["507"] = Instance.new("UIStroke", G2L["501"]);
G2L["507"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["507"]["Thickness"] = 14.5;
G2L["507"]["Color"] = Color3.fromRGB(0, 86, 0);


-- StarterGui.ScreenGui.cool.PasswordFrame.EnterButton
G2L["508"] = Instance.new("TextButton", G2L["501"]);
G2L["508"]["TextWrapped"] = true;
G2L["508"]["BorderSizePixel"] = 0;
G2L["508"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["508"]["TextSize"] = 24;
G2L["508"]["TextScaled"] = true;
G2L["508"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["508"]["FontFace"] = Font.new([[rbxasset://fonts/families/HighwayGothic.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["508"]["Size"] = UDim2.new(0.38497, 0, 0.19211, 0);
G2L["508"]["Name"] = [[EnterButton]];
G2L["508"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["508"]["Text"] = [[ENTER]];
G2L["508"]["Position"] = UDim2.new(0.31501, 0, 0.72779, 0);


-- StarterGui.ScreenGui.cool.PasswordFrame.EnterButton.UIStroke
G2L["509"] = Instance.new("UIStroke", G2L["508"]);
G2L["509"]["Thickness"] = 4;
G2L["509"]["Color"] = Color3.fromRGB(0, 86, 0);


-- StarterGui.ScreenGui.cool.PasswordFrame.EnterButton.UICorner
G2L["50a"] = Instance.new("UICorner", G2L["508"]);



-- StarterGui.ScreenGui.cool.PasswordFrame.EnterButton.UIStroke
G2L["50b"] = Instance.new("UIStroke", G2L["508"]);
G2L["50b"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["50b"]["Thickness"] = 7;
G2L["50b"]["Color"] = Color3.fromRGB(0, 86, 0);


-- StarterGui.ScreenGui.cool.PasswordFrame.CloseButton
G2L["50c"] = Instance.new("TextButton", G2L["501"]);
G2L["50c"]["TextWrapped"] = true;
G2L["50c"]["BorderSizePixel"] = 0;
G2L["50c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["50c"]["TextSize"] = 24;
G2L["50c"]["TextScaled"] = true;
G2L["50c"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["50c"]["FontFace"] = Font.new([[rbxasset://fonts/families/HighwayGothic.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["50c"]["Size"] = UDim2.new(0.13369, 0, 0.18654, 0);
G2L["50c"]["Name"] = [[CloseButton]];
G2L["50c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["50c"]["Text"] = [[X]];
G2L["50c"]["Position"] = UDim2.new(0.92634, 0, -0.06106, 0);


-- StarterGui.ScreenGui.cool.PasswordFrame.CloseButton.UIStroke
G2L["50d"] = Instance.new("UIStroke", G2L["50c"]);
G2L["50d"]["Thickness"] = 4;
G2L["50d"]["Color"] = Color3.fromRGB(171, 0, 255);


-- StarterGui.ScreenGui.cool.PasswordFrame.CloseButton.UIStroke
G2L["50e"] = Instance.new("UIStroke", G2L["50c"]);
G2L["50e"]["ApplyStrokeMode"] = Enum.ApplyStrokeMode.Border;
G2L["50e"]["Thickness"] = 5;
G2L["50e"]["Color"] = Color3.fromRGB(0, 86, 0);


-- StarterGui.ScreenGui.cool.PasswordFrame.CloseButton.UICorner
G2L["50f"] = Instance.new("UICorner", G2L["50c"]);



-- StarterGui.ScreenGui.cool.PasswordFrame.UIStroke
G2L["510"] = Instance.new("UIStroke", G2L["501"]);
G2L["510"]["Thickness"] = 7;
G2L["510"]["Color"] = Color3.fromRGB(0, 86, 0);


-- StarterGui.ScreenGui.cool.PasswordFrame.TextLabel
G2L["511"] = Instance.new("TextLabel", G2L["501"]);
G2L["511"]["TextWrapped"] = true;
G2L["511"]["BorderSizePixel"] = 0;
G2L["511"]["TextSize"] = 14;
G2L["511"]["TextStrokeColor3"] = Color3.fromRGB(4, 46, 0);
G2L["511"]["TextScaled"] = true;
G2L["511"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["511"]["FontFace"] = Font.new([[rbxasset://fonts/families/LuckiestGuy.json]], Enum.FontWeight.Regular, Enum.FontStyle.Italic);
G2L["511"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["511"]["Size"] = UDim2.new(0, 343, 0, 76);
G2L["511"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["511"]["Text"] = [[K00pgui secret edition v4 : Login page ]];
G2L["511"]["Position"] = UDim2.new(0.19529, 0, 0.01486, 0);


-- StarterGui.ScreenGui.cool.PasswordFrame.ImageLabel
G2L["512"] = Instance.new("ImageLabel", G2L["501"]);
G2L["512"]["BorderSizePixel"] = 0;
G2L["512"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["512"]["Image"] = [[rbxassetid://12168410006]];
G2L["512"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["512"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["512"]["Position"] = UDim2.new(0.08081, 0, 0.70701, 0);


-- StarterGui.ScreenGui.cool.PasswordFrame.ImageLabel
G2L["513"] = Instance.new("ImageLabel", G2L["501"]);
G2L["513"]["BorderSizePixel"] = 0;
G2L["513"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["513"]["Image"] = [[rbxassetid://11426291165]];
G2L["513"]["Size"] = UDim2.new(0, 100, 0, 100);
G2L["513"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["513"]["Position"] = UDim2.new(0.74411, 0, 0.70701, 0);


-- StarterGui.ScreenGui.cool.PasswordFrame.TextLabel
G2L["514"] = Instance.new("TextLabel", G2L["501"]);
G2L["514"]["TextWrapped"] = true;
G2L["514"]["BorderSizePixel"] = 0;
G2L["514"]["TextSize"] = 14;
G2L["514"]["TextStrokeColor3"] = Color3.fromRGB(4, 46, 0);
G2L["514"]["TextScaled"] = true;
G2L["514"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["514"]["FontFace"] = Font.new([[rbxasset://fonts/families/LuckiestGuy.json]], Enum.FontWeight.Regular, Enum.FontStyle.Italic);
G2L["514"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["514"]["Size"] = UDim2.new(0, 360, 0, 46);
G2L["514"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["514"]["Text"] = [[Zelow and dariusalt]];
G2L["514"]["Position"] = UDim2.new(0.19697, 0, 0.55839, 0);


-- StarterGui.ScreenGui.cool.PasswordFrame.Smooth GUI Dragging
G2L["515"] = Instance.new("LocalScript", G2L["501"]);
G2L["515"]["Name"] = [[Smooth GUI Dragging]];


-- StarterGui.ScreenGui.cool.Password Handler
G2L["516"] = Instance.new("LocalScript", G2L["2"]);
G2L["516"]["Name"] = [[Password Handler]];


-- Require G2L wrapper
local G2L_REQUIRE = require;
local G2L_MODULES = {};
local function require(Module:ModuleScript)
	local ModuleState = G2L_MODULES[Module];
	if ModuleState then
		if not ModuleState.Required then
			ModuleState.Required = true;
			ModuleState.Value = ModuleState.Closure();
		end
		return ModuleState.Value;
	end;
	return G2L_REQUIRE(Module);
end

G2L_MODULES[G2L["4d"]] = {
	Closure = function()
		local script = G2L["4d"];--[[

--------------| ABOUT RANKS |--------------

RANK	| DEFAULT NAME	| COMMANDS	| EXTRA DETAILS
-------------------------------------------------------------------------------------------------------------------
5		| Owner			| All		| Is automtically set. The Owner has full access to commands and features.
-------------------------------------------------------------------------------------------------------------------
4 		| HeadAdmin		| 1,2,3,4	| 
3 		| Admin			| 1,2,3		| 
2		| Mod			| 1,2		| Can only use commands on one person at a time. 
1 		| VIP			| 1			| Can only use commands on theirself.
-------------------------------------------------------------------------------------------------------------------
0		| NonAdmin		| 0			| The default rank. Players are limited to basic features.




--------------| SETUP RANKS |--------------																															 ]] return{

			-- RANK, RANK NAMES & SPECIFIC USERS
			Ranks = {
				{5,	"Owner",		};
				{4,	"HeadAdmin",	{"",0},	};
				{3,	"Admin",		{"",0},	};
				{2,	"Mod",			{"",0},	};
				{1,	"VIP",			{"",0},	};
				{0,	"NonAdmin",		};
			};



			-- GAMEPASSES
			Gamepasses = {
				[0] = "VIP";
			};


			-- ASSETS
			Assets = {
				[0] = "VIP";
			};


			-- GROUPS
			Groups = {
				[0] = {
					[254] = "Admin";
					[1] = "VIP";
				};
			};


			-- FRIENDS
			Friends = "NonAdmin";


			-- VIP SERVER OWNER
			VipServerOwner = "NonAdmin";


			-- FREE ADMIN
			FreeAdmin = "NonAdmin";








			--------------| BANLAND |--------------
			Banned = {"",0};








			--------------| SYSTEM SETTINGS |--------------
			Prefix				= ";";			-- The character you use before every command (e.g. ';jump me').
			SplitKey 			= " ";			-- The character inbetween command arguments (e.g. setting it to '/' would change ';jump me' to ';jump/me').
			BatchKey 			= "";			-- The character inbetween batch commands (e.g. setting it to '|' would change ';jump me ;fire me ;smoke me' to ';jump me | ;fire me | ;smoke me'
			QualifierBatchKey 	= ",";			-- The character used to split up qualifiers (e.g. ;jump player1,player2,player3)

			Theme				= "Blue";		-- The default UI theme.
			NoticeSoundId		= 2865227271;	-- The SoundId for notices.
			NoticeVolume		= 0.1;			-- The Volume for notices.
			NoticePitch			= 1;			-- The Pitch/PlaybackSpeed for notices.
			ErrorSoundId		= 2865228021;	-- The SoundId for error notifications.
			ErrorVolume			= 0.1;			-- The Volume for error notifications.
			ErrorPitch			= 1;			-- The Pitch/PlaybackSpeed for error notifications.
			AlertSoundId		= 9161622880;	-- The SoundId for alerts.
			AlertVolume			= 0.5;			-- The Volume for alerts.
			AlertPitch			= 1;			-- The Pitch/PlaybackSpeed for alerts.

			WelcomeBadgeId		= 0;			-- Award new players a badge, such as 'Welcome to the game!'. Set to 0 for no badge.

			CommandDebounce		= true;			-- Wait until the command effect is over to use again. Helps to limit abuse & lag. Set to 'false' to disable.
			SaveRank			= true;			-- Saves a player's rank in the server they received it. (e.g. ;rank plrName rank). Use ';permRank plrName rank' to permanently save a rank. Set to 'false' to disable.
			LoopCommands		= 3;			-- The minimum rank required to use LoopCommands.
			MusicList 			= {};	-- Songs which automatically appear in a user's radio. Type '!radio' to display the radio.

			ThemeColors = {						-- The colours players can set their HD Admin UI (in the 'Settings' menu). | Format: {ThemeName, ThemeColor3Value};
				{"Red", 	Color3.fromRGB(150, 0, 0),		};
				{"Orange", 	Color3.fromRGB(150, 75, 0),		};
				{"Brown", 	Color3.fromRGB(120, 80, 30),	};
				{"Yellow", 	Color3.fromRGB(130, 120, 0),	};
				{"Green", 	Color3.fromRGB(0, 120, 0),		};
				{"Blue", 	Color3.fromRGB(0, 100, 150),	};
				{"Purple", 	Color3.fromRGB(100, 0, 150),	};
				{"Pink",	Color3.fromRGB(150, 0, 100),	};
				{"Black", 	Color3.fromRGB(60, 60, 60),		};
			};

			Colors = {							-- The colours for ChatColors and command arguments. | Format: {"ShortName", "FullName", Color3Value};
				{"r", 		"Red",		 		Color3.fromRGB(255, 0, 0)		};
				{"o", 		"Orange",	 		Color3.fromRGB(250, 100, 0)		};
				{"y", 		"Yellow",			Color3.fromRGB(255, 255, 0)		};
				{"g", 		"Green"	,			Color3.fromRGB(0, 255, 0)		};
				{"dg", 		"DarkGreen"	, 		Color3.fromRGB(0, 125, 0)		};
				{"b", 		"Blue",		 		Color3.fromRGB(0, 255, 255)		};
				{"db", 		"DarkBlue",			Color3.fromRGB(0, 50, 255)		};
				{"p", 		"Purple",	 		Color3.fromRGB(150, 0, 255)		};
				{"pk",		"Pink",		 		Color3.fromRGB(255, 85, 185)	};
				{"bk",		"Black",		 	Color3.fromRGB(0, 0, 0)			};
				{"w",		"White",	 		Color3.fromRGB(255, 255, 255)	};
			};
			ChatColors = {						-- The colour a player's chat will appear depending on their rank. '["Owner"] = "Yellow";' makes the owner's chat yellow.
				[5] 		= "Yellow";
			};

			Cmdbar						= 1;			-- The minimum rank required to use the Cmdbar.
			Cmdbar2						= 3;			-- The minimum rank required to use the Cmdbar2.
			ViewBanland					= 3;			-- The minimum rank required to view the banland.
			OnlyShowUsableCommands		= false;		-- Only display commands equal to or below the user's rank on the Commands page.
			RankRequiredToViewPage		= {				-- || The pages on the main menu ||
				["Commands"]		= 0;
				["Admin"]			= 0;
				["Settings"]		= 0;
			};
			RankRequiredToViewRank		= {				-- || The rank categories on the 'Ranks' subPage under Admin ||
				["Owner"]			= 0;
				["HeadAdmin"]		= 0;
				["Admin"]			= 0;
				["Mod"]				= 0;
				["VIP"]				= 0;
			};
			RankRequiredToViewRankType	= {				-- || The collection of loader-rank-rewarders on the 'Ranks' subPage under Admin ||
				["Owner"]			= 0;
				["SpecificUsers"]	= 5;
				["Gamepasses"] 		= 0;
				["Assets"] 			= 0;
				["Groups"] 			= 0;
				["Friends"] 		= 0;
				["FreeAdmin"] 		= 0;
				["VipServerOwner"] 	= 0;
			};
			RankRequiredToViewIcon		= 0;

			WelcomeRankNotice			= true;			-- The 'You're a [rankName]' notice that appears when you join the game. Set to false to disable.
			WelcomeDonorNotice			= true;			-- The 'You're a Donor' notice that appears when you join the game. Set to false to disable.
			WarnIncorrectPrefix			= true;			-- Warn the user if using the wrong prefix | "Invalid prefix! Try using [correctPrefix][commandName] instead!"
			DisableAllNotices			= false;		-- Set to true to disable all HD Admin notices.

			ScaleLimit					= 4;			-- The maximum size players with a rank lower than 'IgnoreScaleLimit' can scale theirself. For example, players will be limited to ;size me 4 (if limit is 4) - any number above is blocked.
			IgnoreScaleLimit			= 3;			-- Any ranks equal or above this value will ignore 'ScaleLimit'
			CommandLimits				= {				-- Enables you to set limits for commands which have a number argument. Ranks equal to or higher than 'IgnoreLimit' will not be affected by Limit.
				["fly"]	= {
					Limit 				= 10000;
					IgnoreLimit 		= 3;
				};
				["fly2"]	= {
					Limit 				= 10000;
					IgnoreLimit 		= 3;
				};
				["noclip"]	= {
					Limit 				= 10000;
					IgnoreLimit 		= 3;
				};
				["noclip2"]	= {
					Limit 				= 10000;
					IgnoreLimit 		= 3;
				};
				["speed"]	= {
					Limit 				= 10000;
					IgnoreLimit 		= 3;
				};
				["jumpPower"]	= {
					Limit 				= 10000;
					IgnoreLimit 		= 3;
				};
			};

			VIPServerCommandBlacklist	= {"permRank", "permBan", "globalAnnouncement"};	-- Commands players are probihited from using in VIP Servers.
			GearBlacklist				= {67798397};	-- The IDs of gear items to block when using the ;gear command.
			IgnoreGearBlacklist			= 4;			-- The minimum rank required to ignore the gear blacklist.

			PlayerDataStoreVersion		= "V1.0";		-- Data about the player (i.e. permRanks, custom settings, etc). Changing the Version name will reset all PlayerData.
			SystemDataStoreVersion		= "V1.0";		-- Data about the game (i.e. the banland, universal message system, etc). Changing the Version name will reset all SystemData.

			CoreNotices					= {				-- Modify core notices. You can find a table of all CoreNotices under [MainModule > Client > SharedModules > CoreNotices]
				--NoticeName = NoticeDetails;
			};




			--------------| MODIFY COMMANDS |--------------
			SetCommandRankByName = {
				--["jump"] = "VIP";
			};	
			SetCommandRankByTag = {
				--["abusive"] = "Admin";
			};








		};
	end;
};
G2L_MODULES[G2L["52"]] = {
	Closure = function()
		local script = G2L["52"];-- << RETRIEVE FRAMEWORK >>
		local main = _G.HDAdminMain
		local settings = main.settings



		-- << COMMANDS >>
		local module = {

			-----------------------------------
			{
				Name = "";
				Aliases	= {};
				Prefixes = {settings.Prefix};
				Rank = 1;
				RankLock = false;
				Loopable = false;
				Tags = {};
				Description = "";
				Contributors = {};
				--
				Args = {};
				Function = function(speaker, args)

				end;
				UnFunction = function(speaker, args)

				end;
				--
			};




			-----------------------------------
			{
				Name = "";
				Aliases	= {};
				Prefixes = {settings.Prefix};
				Rank = 1;
				RankLock = false;
				Loopable = false;
				Tags = {};
				Description = "";
				Contributors = {};
				--
				Args = {};
	--[[
	ClientCommand = true;
	FireAllClients = true;
	BlockWhenPunished = true;
	PreFunction = function(speaker, args)
		
	end;
	Function = function(speaker, args)
		wait(1)
	end;
	--]]
				--
			};




			-----------------------------------

		};



		return module

	end;
};
G2L_MODULES[G2L["5a"]] = {
	Closure = function()
		local script = G2L["5a"];-- << RETRIEVE FRAMEWORK >>
		local main = _G.HDAdminMain



		-- << CLIENT COMMANDS >>
		local module = {

			----------------------------------------------------------------------
			["commandName1"] = {
				Function = function(speaker, args)

				end;
			};




			----------------------------------------------------------------------
			["commandName2"] = {
				Function = function(speaker, args)

				end;
			};




			----------------------------------------------------------------------

		};



		-- << SETUP >>
		for commandName, command in pairs(module) do
			command.Name = commandName
		end



		return module
	end;
};
G2L_MODULES[G2L["5c"]] = {
	Closure = function()
		local script = G2L["5c"];-- << RETRIEVE FRAMEWORK >>
		local main = _G.HDAdminMain



		-- << EVENTS >>
		local module = {

			----------------------------------------------------------------------
			["EventName"] = function(bindable, parent, ...)

			end;




			----------------------------------------------------------------------
			["EventName"] = function(bindable, parent, ...)

			end;




			----------------------------------------------------------------------

		};



		return module
	end;
};
G2L_MODULES[G2L["10b"]] = {
	Closure = function()
		local script = G2L["10b"];local t = {}

		local function ScopedConnect(parentInstance, instance, event, signalFunc, syncFunc, removeFunc)
			local eventConnection = nil

			--Connection on parentInstance is scoped by parentInstance (when destroyed, it goes away)
			local tryConnect = function()
				if game:IsAncestorOf(parentInstance) then
					--Entering the world, make sure we are connected/synced
					if not eventConnection then
						eventConnection = instance[event]:connect(signalFunc)
						if syncFunc then syncFunc() end
					end
				else
					--Probably leaving the world, so disconnect for now
					if eventConnection then
						eventConnection:disconnect()
						if removeFunc then removeFunc() end
					end
				end
			end

			--Hook it up to ancestryChanged signal
			local connection = parentInstance.AncestryChanged:connect(tryConnect)

			--Now connect us if we're already in the world
			tryConnect()

			return connection
		end

		local function getLayerCollectorAncestor(instance)
			local localInstance = instance
			while localInstance and not localInstance:IsA("LayerCollector") do
				localInstance = localInstance.Parent
			end
			return localInstance
		end

		local function CreateButtons(frame, buttons, yPos, ySize)
			local buttonNum = 1
			local buttonObjs = {}
			for i, obj in ipairs(buttons) do 
				local button = Instance.new("TextButton")
				button.Name = "Button" .. buttonNum
				button.Font = Enum.Font.Arial
				button.FontSize = Enum.FontSize.Size18
				button.AutoButtonColor = true
				button.Modal = true
				if obj["Style"] then
					button.Style = obj.Style
				else
					button.Style = Enum.ButtonStyle.RobloxButton
				end
				if obj["ZIndex"] then
					button.ZIndex = obj.ZIndex
				end
				button.Text = obj.Text
				button.TextColor3 = Color3.new(1,1,1)
				button.MouseButton1Click:connect(obj.Function)
				button.Parent = frame
				buttonObjs[buttonNum] = button

				buttonNum = buttonNum + 1
			end
			local numButtons = buttonNum-1

			if numButtons == 1 then
				frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
				frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
			elseif numButtons == 2 then
				frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
				frame.Button1.Size = UDim2.new(.8/3,0, ySize.Scale, ySize.Offset)

				frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
				frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
			elseif numButtons >= 3 then
				local spacing = .1 / numButtons
				local buttonSize = .9 / numButtons

				buttonNum = 1
				while buttonNum <= numButtons do
					buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
					buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
					buttonNum = buttonNum + 1
				end
			end
		end

		local function setSliderPos(newAbsPosX,slider,sliderPosition,bar,steps)

			local newStep = steps - 1 --otherwise we really get one more step than we want
			local relativePosX = math.min(1, math.max(0, (newAbsPosX - bar.AbsolutePosition.X) / bar.AbsoluteSize.X ))
			local wholeNum, remainder = math.modf(relativePosX * newStep)
			if remainder > 0.5 then
				wholeNum = wholeNum + 1
			end
			relativePosX = wholeNum/newStep

			local result = math.ceil(relativePosX * newStep)
			if sliderPosition.Value ~= (result + 1) then --only update if we moved a step
				sliderPosition.Value = result + 1
				slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
			end

		end

		local function cancelSlide(areaSoak)
			areaSoak.Visible = false
		end

		t.CreateStyledMessageDialog = function(title, message, style, buttons)
			local frame = Instance.new("Frame")
			frame.Size = UDim2.new(0.5, 0, 0, 165)
			frame.Position = UDim2.new(0.25, 0, 0.5, -72.5)
			frame.Name = "MessageDialog"
			frame.Active = true
			frame.Style = Enum.FrameStyle.RobloxRound	

			local styleImage = Instance.new("ImageLabel")
			styleImage.Name = "StyleImage"
			styleImage.BackgroundTransparency = 1
			styleImage.Position = UDim2.new(0,5,0,15)
			if style == "error" or style == "Error" then
				styleImage.Size = UDim2.new(0, 71, 0, 71)
				styleImage.Image = "https://www.roblox.com/asset/?id=42565285"
			elseif style == "notify" or style == "Notify" then
				styleImage.Size = UDim2.new(0, 71, 0, 71)
				styleImage.Image = "https://www.roblox.com/asset/?id=42604978"
			elseif style == "confirm" or style == "Confirm" then
				styleImage.Size = UDim2.new(0, 74, 0, 76)
				styleImage.Image = "https://www.roblox.com/asset/?id=42557901"
			else
				return t.CreateMessageDialog(title,message,buttons)
			end
			styleImage.Parent = frame

			local titleLabel = Instance.new("TextLabel")
			titleLabel.Name = "Title"
			titleLabel.Text = title
			titleLabel.TextStrokeTransparency = 0
			titleLabel.BackgroundTransparency = 1
			titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
			titleLabel.Position = UDim2.new(0, 80, 0, 0)
			titleLabel.Size = UDim2.new(1, -80, 0, 40)
			titleLabel.Font = Enum.Font.ArialBold
			titleLabel.FontSize = Enum.FontSize.Size36
			titleLabel.TextXAlignment = Enum.TextXAlignment.Center
			titleLabel.TextYAlignment = Enum.TextYAlignment.Center
			titleLabel.Parent = frame

			local messageLabel = Instance.new("TextLabel")
			messageLabel.Name = "Message"
			messageLabel.Text = message
			messageLabel.TextStrokeTransparency = 0
			messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
			messageLabel.Position = UDim2.new(0.025, 80, 0, 45)
			messageLabel.Size = UDim2.new(0.95, -80, 0, 55)
			messageLabel.BackgroundTransparency = 1
			messageLabel.Font = Enum.Font.Arial
			messageLabel.FontSize = Enum.FontSize.Size18
			messageLabel.TextWrap = true
			messageLabel.TextXAlignment = Enum.TextXAlignment.Left
			messageLabel.TextYAlignment = Enum.TextYAlignment.Top
			messageLabel.Parent = frame

			CreateButtons(frame, buttons, UDim.new(0, 105), UDim.new(0, 40) )

			return frame
		end

		t.CreateMessageDialog = function(title, message, buttons)
			local frame = Instance.new("Frame")
			frame.Size = UDim2.new(0.5, 0, 0.5, 0)
			frame.Position = UDim2.new(0.25, 0, 0.25, 0)
			frame.Name = "MessageDialog"
			frame.Active = true
			frame.Style = Enum.FrameStyle.RobloxRound

			local titleLabel = Instance.new("TextLabel")
			titleLabel.Name = "Title"
			titleLabel.Text = title
			titleLabel.BackgroundTransparency = 1
			titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
			titleLabel.Position = UDim2.new(0, 0, 0, 0)
			titleLabel.Size = UDim2.new(1, 0, 0.15, 0)
			titleLabel.Font = Enum.Font.ArialBold
			titleLabel.FontSize = Enum.FontSize.Size36
			titleLabel.TextXAlignment = Enum.TextXAlignment.Center
			titleLabel.TextYAlignment = Enum.TextYAlignment.Center
			titleLabel.Parent = frame

			local messageLabel = Instance.new("TextLabel")
			messageLabel.Name = "Message"
			messageLabel.Text = message
			messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
			messageLabel.Position = UDim2.new(0.025, 0, 0.175, 0)
			messageLabel.Size = UDim2.new(0.95, 0, .55, 0)
			messageLabel.BackgroundTransparency = 1
			messageLabel.Font = Enum.Font.Arial
			messageLabel.FontSize = Enum.FontSize.Size18
			messageLabel.TextWrap = true
			messageLabel.TextXAlignment = Enum.TextXAlignment.Left
			messageLabel.TextYAlignment = Enum.TextYAlignment.Top
			messageLabel.Parent = frame

			CreateButtons(frame, buttons, UDim.new(0.8,0), UDim.new(0.15, 0))

			return frame
		end

		-- written by jmargh
		-- to be used for the new settings menu
		t.CreateScrollingDropDownMenu = function(onSelectedCallback, size, position, baseZ)
			local maxVisibleList = 6
			local baseZIndex = 0
			if type(baseZ) == 'number' then
				baseZIndex = baseZ
			end

			local dropDownMenu = {}
			local currentList = nil

			local updateFunc = nil
			local frame = Instance.new('Frame')
			frame.Name = "DropDownMenuFrame"
			frame.Size = size
			frame.Position = position
			frame.BackgroundTransparency = 1
			dropDownMenu.Frame = frame

			local currentSelectionName = Instance.new('TextButton')
			currentSelectionName.Name = "CurrentSelectionName"
			currentSelectionName.Size = UDim2.new(1, 0, 1, 0)
			currentSelectionName.BackgroundTransparency = 1
			currentSelectionName.Font = Enum.Font.SourceSansBold
			currentSelectionName.FontSize = Enum.FontSize.Size18
			currentSelectionName.TextXAlignment = Enum.TextXAlignment.Left
			currentSelectionName.TextYAlignment = Enum.TextYAlignment.Center
			currentSelectionName.TextColor3 = Color3.new(0.5, 0.5, 0.5)
			currentSelectionName.TextWrap = true
			currentSelectionName.ZIndex = baseZIndex
			currentSelectionName.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
			currentSelectionName.Text = "Choose One"
			currentSelectionName.Parent = frame
			dropDownMenu.CurrentSelectionButton = currentSelectionName

			local icon = Instance.new('ImageLabel')
			icon.Name = "DropDownIcon"
			icon.Size = UDim2.new(0, 16, 0, 12)
			icon.Position = UDim2.new(1, -17, 0.5, -6)
			icon.Image = 'rbxasset://textures/ui/dropdown_arrow.png'
			icon.BackgroundTransparency = 1
			icon.ZIndex = baseZIndex
			icon.Parent = currentSelectionName

			local listMenu = nil
			local scrollingBackground = nil
			local visibleCount = 0
			local isOpen = false

			local function onEntrySelected()
				icon.Rotation = 0
				scrollingBackground:TweenSize(UDim2.new(1, 0, 0, currentSelectionName.AbsoluteSize.y), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.15, true)
				--
				listMenu.ScrollBarThickness = 0
				listMenu:TweenSize(UDim2.new(1, -16, 0, 24), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.15, true, function()
					if not isOpen then
						listMenu.Visible = false
						scrollingBackground.Visible = false
					end
				end)
				isOpen = false
			end

			currentSelectionName.MouseButton1Click:connect(function()
				if not currentSelectionName.Active or #currentList == 0 then return end
				if isOpen then
					onEntrySelected()
					return
				end
				--
				isOpen = true
				icon.Rotation = 180
				if listMenu then listMenu.Visible = true end
				if scrollingBackground then scrollingBackground.Visible = true end
				--
				if scrollingBackground then
					scrollingBackground:TweenSize(UDim2.new(1, 0, 0, visibleCount * 24 + 8), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.15, true)
				end
				if listMenu then
					listMenu:TweenSize(UDim2.new(1, -16, 0, visibleCount * 24), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.15, true, function()
						listMenu.ScrollBarThickness = 6
					end)
				end
			end)

			--[[ Public API ]]--
			dropDownMenu.IsOpen = function()
				return isOpen
			end

			dropDownMenu.Close = function()
				onEntrySelected()
			end

			dropDownMenu.Reset = function()
				isOpen = false
				icon.Rotation = 0
				listMenu.ScrollBarThickness = 0
				listMenu.Size = UDim2.new(1, -16, 0, 24)
				listMenu.Visible = false
				scrollingBackground.Visible = false
			end

			dropDownMenu.SetVisible = function(isVisible)
				if frame then
					frame.Visible = isVisible
				end
			end

			dropDownMenu.UpdateZIndex = function(newZIndexBase)
				currentSelectionName.ZIndex = newZIndexBase
				icon.ZIndex = newZIndexBase
				if scrollingBackground then scrollingBackground.ZIndex = newZIndexBase + 1 end
				if listMenu then
					listMenu.ZIndex = newZIndexBase + 2
					for _,child in pairs(listMenu:GetChildren()) do
						child.ZIndex = newZIndexBase + 4
					end
				end
			end

			dropDownMenu.SetActive = function(isActive)
				currentSelectionName.Active = isActive
			end

			dropDownMenu.SetSelectionText = function(text)
				currentSelectionName.Text = text
			end

			dropDownMenu.CreateList = function(list)
				currentSelectionName.Text = "Choose One"
				if listMenu then listMenu:Destroy() end
				if scrollingBackground then scrollingBackground:Destroy() end
				--
				currentList = list
				local length = #list
				visibleCount = math.min(maxVisibleList, length)
				local listMenuOffset = visibleCount * 24

				listMenu = Instance.new('ScrollingFrame')
				listMenu.Name = "ListMenu"
				listMenu.Size = UDim2.new(1, -16, 0, 24)
				listMenu.Position = UDim2.new(0, 12, 0, 32)
				listMenu.CanvasSize = UDim2.new(0, 0, 0, length * 24)
				listMenu.BackgroundTransparency = 1
				listMenu.BorderSizePixel = 0
				listMenu.ZIndex = baseZIndex + 2
				listMenu.Visible = false
				listMenu.Active = true
				listMenu.BottomImage = 'rbxasset://textures/ui/scroll-bottom.png'
				listMenu.MidImage = 'rbxasset://textures/ui/scroll-middle.png'
				listMenu.TopImage = 'rbxasset://textures/ui/scroll-top.png'
				listMenu.ScrollBarThickness = 0
				listMenu.Parent = frame

				scrollingBackground = Instance.new('TextButton')
				scrollingBackground.Name = "ScrollingBackground"
				scrollingBackground.Size = UDim2.new(1, 0, 0, currentSelectionName.AbsoluteSize.y)
				scrollingBackground.Position = UDim2.new(0, 0, 0, 28)
				scrollingBackground.BackgroundColor3 = Color3.new(1, 1, 1)
				scrollingBackground.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
				scrollingBackground.ZIndex = baseZIndex + 1
				scrollingBackground.Text = ""
				scrollingBackground.Visible = false
				scrollingBackground.AutoButtonColor = false
				scrollingBackground.Parent = frame

				for i = 1, length do
					local entry = list[i]
					local btn = Instance.new('TextButton')
					btn.Name = entry
					btn.Size = UDim2.new(1, 0, 0, 24)
					btn.Position = UDim2.new(0, 0, 0, (i - 1) * 24)
					btn.BackgroundTransparency = 0
					btn.BackgroundColor3 = Color3.new(1, 1, 1)
					btn.BorderSizePixel = 0
					btn.Font = Enum.Font.SourceSans
					btn.FontSize = Enum.FontSize.Size18
					btn.TextColor3 = Color3.new(0.5, 0.5, 0.5)
					btn.TextXAlignment = Enum.TextXAlignment.Left
					btn.TextYAlignment = Enum.TextYAlignment.Center
					btn.Text = entry
					btn.ZIndex = baseZIndex + 4
					btn.AutoButtonColor = false
					btn.Parent = listMenu

					btn.MouseButton1Click:connect(function()
						currentSelectionName.Text = btn.Text
						onEntrySelected()
						btn.Font = Enum.Font.SourceSans
						btn.TextColor3 = Color3.new(0.5, 0.5, 0.5)
						btn.BackgroundColor3 = Color3.new(1, 1, 1)
						onSelectedCallback(btn.Text)
					end)

					btn.MouseEnter:connect(function()
						btn.TextColor3 = Color3.new(1, 1, 1)
						btn.BackgroundColor3 = Color3.new(0.75, 0.75, 0.75)
					end)
					btn.MouseLeave:connect(function()
						btn.TextColor3 = Color3.new(0.5, 0.5, 0.5)
						btn.BackgroundColor3 = Color3.new(1, 1, 1)
					end)
				end
			end

			return dropDownMenu
		end

		t.CreateDropDownMenu = function(items, onSelect, forRoblox, whiteSkin, baseZ)
			local baseZIndex = 0
			if (type(baseZ) == "number") then
				baseZIndex = baseZ
			end
			local width = UDim.new(0, 100)
			local height = UDim.new(0, 32)

			local xPos = 0.055
			local frame = Instance.new("Frame")
			local textColor = Color3.new(1,1,1)
			if (whiteSkin) then
				textColor = Color3.new(0.5, 0.5, 0.5)
			end
			frame.Name = "DropDownMenu"
			frame.BackgroundTransparency = 1
			frame.Size = UDim2.new(width, height)

			local dropDownMenu = Instance.new("TextButton")
			dropDownMenu.Name = "DropDownMenuButton"
			dropDownMenu.TextWrap = true
			dropDownMenu.TextColor3 = textColor
			dropDownMenu.Text = "Choose One"
			dropDownMenu.Font = Enum.Font.ArialBold
			dropDownMenu.FontSize = Enum.FontSize.Size18
			dropDownMenu.TextXAlignment = Enum.TextXAlignment.Left
			dropDownMenu.TextYAlignment = Enum.TextYAlignment.Center
			dropDownMenu.BackgroundTransparency = 1
			dropDownMenu.AutoButtonColor = true
			if (whiteSkin) then
				dropDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
			else
				dropDownMenu.Style = Enum.ButtonStyle.RobloxButton
			end
			dropDownMenu.Size = UDim2.new(1,0,1,0)
			dropDownMenu.Parent = frame
			dropDownMenu.ZIndex = 2 + baseZIndex

			local dropDownIcon = Instance.new("ImageLabel")
			dropDownIcon.Name = "Icon"
			dropDownIcon.Active = false
			if (whiteSkin) then
				dropDownIcon.Image = "rbxasset://textures/ui/dropdown_arrow.png"
				dropDownIcon.Size = UDim2.new(0,16,0,12)
				dropDownIcon.Position = UDim2.new(1,-17,0.5, -6)
			else
				dropDownIcon.Image = "https://www.roblox.com/asset/?id=45732894"
				dropDownIcon.Size = UDim2.new(0,11,0,6)
				dropDownIcon.Position = UDim2.new(1,-11,0.5, -2)
			end
			dropDownIcon.BackgroundTransparency = 1
			dropDownIcon.Parent = dropDownMenu
			dropDownIcon.ZIndex = 2 + baseZIndex

			local itemCount = #items
			local dropDownItemCount = #items
			local useScrollButtons = false
			if dropDownItemCount > 6 then
				useScrollButtons = true
				dropDownItemCount = 6
			end

			local droppedDownMenu = Instance.new("TextButton")
			droppedDownMenu.Name = "List"
			droppedDownMenu.Text = ""
			droppedDownMenu.BackgroundTransparency = 1
			--droppedDownMenu.AutoButtonColor = true
			if (whiteSkin) then
				droppedDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
			else
				droppedDownMenu.Style = Enum.ButtonStyle.RobloxButton
			end
			droppedDownMenu.Visible = false
			droppedDownMenu.Active = true	--Blocks clicks
			droppedDownMenu.Position = UDim2.new(0,0,0,0)
			droppedDownMenu.Size = UDim2.new(1,0, (1 + dropDownItemCount)*.8, 0)
			droppedDownMenu.Parent = frame
			droppedDownMenu.ZIndex = 2 + baseZIndex

			local choiceButton = Instance.new("TextButton")
			choiceButton.Name = "ChoiceButton"
			choiceButton.BackgroundTransparency = 1
			choiceButton.BorderSizePixel = 0
			choiceButton.Text = "ReplaceMe"
			choiceButton.TextColor3 = textColor
			choiceButton.TextXAlignment = Enum.TextXAlignment.Left
			choiceButton.TextYAlignment = Enum.TextYAlignment.Center
			choiceButton.BackgroundColor3 = Color3.new(1, 1, 1)
			choiceButton.Font = Enum.Font.Arial
			choiceButton.FontSize = Enum.FontSize.Size18
			if useScrollButtons then
				choiceButton.Size = UDim2.new(1,-13, .8/((dropDownItemCount + 1)*.8),0) 
			else
				choiceButton.Size = UDim2.new(1, 0, .8/((dropDownItemCount + 1)*.8),0) 
			end
			choiceButton.TextWrap = true
			choiceButton.ZIndex = 2 + baseZIndex

			local areaSoak = Instance.new("TextButton")
			areaSoak.Name = "AreaSoak"
			areaSoak.Text = ""
			areaSoak.BackgroundTransparency = 1
			areaSoak.Active = true
			areaSoak.Size = UDim2.new(1,0,1,0)
			areaSoak.Visible = false
			areaSoak.ZIndex = 3 + baseZIndex

			local dropDownSelected = false

			local scrollUpButton 
			local scrollDownButton
			local scrollMouseCount = 0

			local setZIndex = function(baseZIndex)
				droppedDownMenu.ZIndex = baseZIndex +1
				if scrollUpButton then
					scrollUpButton.ZIndex = baseZIndex + 3
				end
				if scrollDownButton then
					scrollDownButton.ZIndex = baseZIndex + 3
				end

				local children = droppedDownMenu:GetChildren()
				if children then
					for i, child in ipairs(children) do
						if child.Name == "ChoiceButton" then
							child.ZIndex = baseZIndex + 2
						elseif child.Name == "ClickCaptureButton" then
							child.ZIndex = baseZIndex
						end
					end
				end
			end

			local scrollBarPosition = 1
			local updateScroll = function()
				if scrollUpButton then
					scrollUpButton.Active = scrollBarPosition > 1 
				end
				if scrollDownButton then
					scrollDownButton.Active = scrollBarPosition + dropDownItemCount <= itemCount 
				end

				local children = droppedDownMenu:GetChildren()
				if not children then return end

				local childNum = 1			
				for i, obj in ipairs(children) do
					if obj.Name == "ChoiceButton" then
						if childNum < scrollBarPosition or childNum >= scrollBarPosition + dropDownItemCount then
							obj.Visible = false
						else
							obj.Position = UDim2.new(0,0,((childNum-scrollBarPosition+1)*.8)/((dropDownItemCount+1)*.8),0)
							obj.Visible = true
						end
						obj.TextColor3 = textColor
						obj.BackgroundTransparency = 1

						childNum = childNum + 1
					end
				end
			end
			local toggleVisibility = function()
				dropDownSelected = not dropDownSelected

				areaSoak.Visible = not areaSoak.Visible
				dropDownMenu.Visible = not dropDownSelected
				droppedDownMenu.Visible = dropDownSelected
				if dropDownSelected then
					setZIndex(4 + baseZIndex)
				else
					setZIndex(2 + baseZIndex)
				end
				if useScrollButtons then
					updateScroll()
				end
			end
			droppedDownMenu.MouseButton1Click:connect(toggleVisibility)

			local updateSelection = function(text)
				local foundItem = false
				local children = droppedDownMenu:GetChildren()
				local childNum = 1
				if children then
					for i, obj in ipairs(children) do
						if obj.Name == "ChoiceButton" then
							if obj.Text == text then
								obj.Font = Enum.Font.ArialBold
								foundItem = true			
								scrollBarPosition = childNum						
								if (whiteSkin) then
									obj.TextColor3 = Color3.new(90/255,142/255,233/255)
								end
							else
								obj.Font = Enum.Font.Arial
								if (whiteSkin) then
									obj.TextColor3 = textColor
								end
							end
							childNum = childNum + 1
						end
					end
				end
				if not text then
					dropDownMenu.Text = "Choose One"
					scrollBarPosition = 1
				else
					if not foundItem then
						error("Invalid Selection Update -- " .. text)
					end

					if scrollBarPosition + dropDownItemCount > itemCount + 1 then
						scrollBarPosition = itemCount - dropDownItemCount + 1
					end

					dropDownMenu.Text = text
				end
			end

			local function scrollDown()
				if scrollBarPosition + dropDownItemCount <= itemCount then
					scrollBarPosition = scrollBarPosition + 1
					updateScroll()
					return true
				end
				return false
			end
			local function scrollUp()
				if scrollBarPosition > 1 then
					scrollBarPosition = scrollBarPosition - 1
					updateScroll()
					return true
				end
				return false
			end

			if useScrollButtons then
				--Make some scroll buttons
				scrollUpButton = Instance.new("ImageButton")
				scrollUpButton.Name = "ScrollUpButton"
				scrollUpButton.BackgroundTransparency = 1
				scrollUpButton.Image = "rbxasset://textures/ui/scrollbuttonUp.png"
				scrollUpButton.Size = UDim2.new(0,17,0,17) 
				scrollUpButton.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),0)
				scrollUpButton.MouseButton1Click:connect(
					function()
						scrollMouseCount = scrollMouseCount + 1
					end)
				scrollUpButton.MouseLeave:connect(
					function()
						scrollMouseCount = scrollMouseCount + 1
					end)
				scrollUpButton.MouseButton1Down:connect(
					function()
						scrollMouseCount = scrollMouseCount + 1

						scrollUp()
						local val = scrollMouseCount
						wait(0.5)
						while val == scrollMouseCount do
							if scrollUp() == false then
								break
							end
							wait(0.1)
						end				
					end)

				scrollUpButton.Parent = droppedDownMenu

				scrollDownButton = Instance.new("ImageButton")
				scrollDownButton.Name = "ScrollDownButton"
				scrollDownButton.BackgroundTransparency = 1
				scrollDownButton.Image = "rbxasset://textures/ui/scrollbuttonDown.png"
				scrollDownButton.Size = UDim2.new(0,17,0,17) 
				scrollDownButton.Position = UDim2.new(1,-11,1,-11)
				scrollDownButton.Parent = droppedDownMenu
				scrollDownButton.MouseButton1Click:connect(
					function()
						scrollMouseCount = scrollMouseCount + 1
					end)
				scrollDownButton.MouseLeave:connect(
					function()
						scrollMouseCount = scrollMouseCount + 1
					end)
				scrollDownButton.MouseButton1Down:connect(
					function()
						scrollMouseCount = scrollMouseCount + 1

						scrollDown()
						local val = scrollMouseCount
						wait(0.5)
						while val == scrollMouseCount do
							if scrollDown() == false then
								break
							end
							wait(0.1)
						end				
					end)	

				local scrollbar = Instance.new("ImageLabel")
				scrollbar.Name = "ScrollBar"
				scrollbar.Image = "rbxasset://textures/ui/scrollbar.png"
				scrollbar.BackgroundTransparency = 1
				scrollbar.Size = UDim2.new(0, 18, (dropDownItemCount*.8)/((dropDownItemCount+1)*.8), -(17) - 11 - 4)
				scrollbar.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),17+2)
				scrollbar.Parent = droppedDownMenu
			end

			for i,item in ipairs(items) do
				-- needed to maintain local scope for items in event listeners below
				local button = choiceButton:clone()
				if forRoblox then
					button.RobloxLocked = true
				end		
				button.Text = item
				button.Parent = droppedDownMenu
				if (whiteSkin) then
					button.TextColor3 = textColor
				end

				button.MouseButton1Click:connect(function()
					--Remove Highlight
					if (not whiteSkin) then
						button.TextColor3 = Color3.new(1,1,1)
					end
					button.BackgroundTransparency = 1

					updateSelection(item)
					onSelect(item)

					toggleVisibility()
				end)
				button.MouseEnter:connect(function()
					--Add Highlight	
					if (not whiteSkin) then
						button.TextColor3 = Color3.new(0,0,0)
					end
					button.BackgroundTransparency = 0
				end)

				button.MouseLeave:connect(function()
					--Remove Highlight
					if (not whiteSkin) then
						button.TextColor3 = Color3.new(1,1,1)
					end
					button.BackgroundTransparency = 1
				end)
			end

			--This does the initial layout of the buttons	
			updateScroll()

			frame.AncestryChanged:connect(function(child,parent)
				if parent == nil then
					areaSoak.Parent = nil
				else
					areaSoak.Parent = getLayerCollectorAncestor(frame)
				end
			end)

			dropDownMenu.MouseButton1Click:connect(toggleVisibility)
			areaSoak.MouseButton1Click:connect(toggleVisibility)
			return frame, updateSelection
		end

		t.CreatePropertyDropDownMenu = function(instance, property, enum)

			local items = enum:GetEnumItems()
			local names = {}
			local nameToItem = {}
			for i,obj in ipairs(items) do
				names[i] = obj.Name
				nameToItem[obj.Name] = obj
			end

			local frame
			local updateSelection
			frame, updateSelection = t.CreateDropDownMenu(names, function(text) instance[property] = nameToItem[text] end)

			ScopedConnect(frame, instance, "Changed", 
				function(prop)
					if prop == property then
						updateSelection(instance[property].Name)
					end
				end,
				function()
					updateSelection(instance[property].Name)
				end)

			return frame
		end

		t.GetFontHeight = function(font, fontSize)
			if font == nil or fontSize == nil then
				error("Font and FontSize must be non-nil")
			end

			local fontSizeInt = tonumber(fontSize.Name:match("%d+")) -- Clever hack to extract the size from the enum itself.

			if font == Enum.Font.Legacy then -- Legacy has a 50% bigger size.
				return math.ceil(fontSizeInt*1.5)
			else -- Size is literally just the fontSizeInt
				return fontSizeInt
			end
		end

		local function layoutGuiObjectsHelper(frame, guiObjects, settingsTable)
			local totalPixels = frame.AbsoluteSize.Y
			local pixelsRemaining = frame.AbsoluteSize.Y
			for i, child in ipairs(guiObjects) do
				if child:IsA("TextLabel") or child:IsA("TextButton") then
					local isLabel = child:IsA("TextLabel")
					if isLabel then
						pixelsRemaining = pixelsRemaining - settingsTable["TextLabelPositionPadY"]
					else
						pixelsRemaining = pixelsRemaining - settingsTable["TextButtonPositionPadY"]
					end
					child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
					child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, pixelsRemaining)

					if child.TextFits and child.TextBounds.Y < pixelsRemaining then
						child.Visible = true
						if isLabel then
							child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable["TextLabelSizePadY"])
						else 
							child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable["TextButtonSizePadY"])
						end

						while not child.TextFits do
							child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.AbsoluteSize.Y + 1)
						end
						pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y		

						if isLabel then
							pixelsRemaining = pixelsRemaining - settingsTable["TextLabelPositionPadY"]
						else
							pixelsRemaining = pixelsRemaining - settingsTable["TextButtonPositionPadY"]
						end
					else
						child.Visible = false
						pixelsRemaining = -1
					end			

				else
					--GuiObject
					child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
					pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
					child.Visible = (pixelsRemaining >= 0)
				end
			end
		end

		t.LayoutGuiObjects = function(frame, guiObjects, settingsTable)
			if not frame:IsA("GuiObject") then
				error("Frame must be a GuiObject")
			end
			for i, child in ipairs(guiObjects) do
				if not child:IsA("GuiObject") then
					error("All elements that are layed out must be of type GuiObject")
				end
			end

			if not settingsTable then
				settingsTable = {}
			end

			if not settingsTable["TextLabelSizePadY"] then
				settingsTable["TextLabelSizePadY"] = 0
			end
			if not settingsTable["TextLabelPositionPadY"] then
				settingsTable["TextLabelPositionPadY"] = 0
			end
			if not settingsTable["TextButtonSizePadY"] then
				settingsTable["TextButtonSizePadY"] = 12
			end
			if not settingsTable["TextButtonPositionPadY"] then
				settingsTable["TextButtonPositionPadY"] = 2
			end

			--Wrapper frame takes care of styled objects
			local wrapperFrame = Instance.new("Frame")
			wrapperFrame.Name = "WrapperFrame"
			wrapperFrame.BackgroundTransparency = 1
			wrapperFrame.Size = UDim2.new(1,0,1,0)
			wrapperFrame.Parent = frame

			for i, child in ipairs(guiObjects) do
				child.Parent = wrapperFrame
			end

			local recalculate = function()
				wait()
				layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
			end

			frame.Changed:connect(
				function(prop)
					if prop == "AbsoluteSize" then
						--Wait a heartbeat for it to sync in
						recalculate(nil)
					end
				end)
			frame.AncestryChanged:connect(recalculate)

			layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
		end


		t.CreateSlider = function(steps,width,position)
			local sliderGui = Instance.new("Frame")
			sliderGui.Size = UDim2.new(1,0,1,0)
			sliderGui.BackgroundTransparency = 1
			sliderGui.Name = "SliderGui"

			local sliderSteps = Instance.new("IntValue")
			sliderSteps.Name = "SliderSteps"
			sliderSteps.Value = steps
			sliderSteps.Parent = sliderGui

			local areaSoak = Instance.new("TextButton")
			areaSoak.Name = "AreaSoak"
			areaSoak.Text = ""
			areaSoak.BackgroundTransparency = 1
			areaSoak.Active = false
			areaSoak.Size = UDim2.new(1,0,1,0)
			areaSoak.Visible = false
			areaSoak.ZIndex = 4

			sliderGui.AncestryChanged:connect(function(child,parent)
				if parent == nil then
					areaSoak.Parent = nil
				else
					areaSoak.Parent = getLayerCollectorAncestor(sliderGui)
				end
			end)

			local sliderPosition = Instance.new("IntValue")
			sliderPosition.Name = "SliderPosition"
			sliderPosition.Value = 0
			sliderPosition.Parent = sliderGui

			local id = math.random(1,100)

			local bar = Instance.new("TextButton")
			bar.Text = ""
			bar.AutoButtonColor = false
			bar.Name = "Bar"
			bar.BackgroundColor3 = Color3.new(0,0,0)
			if type(width) == "number" then
				bar.Size = UDim2.new(0,width,0,5)
			else
				bar.Size = UDim2.new(0,200,0,5)
			end
			bar.BorderColor3 = Color3.new(95/255,95/255,95/255)
			bar.ZIndex = 2
			bar.Parent = sliderGui

			if position["X"] and position["X"]["Scale"] and position["X"]["Offset"] and position["Y"] and position["Y"]["Scale"] and position["Y"]["Offset"] then
				bar.Position = position
			end

			local slider = Instance.new("ImageButton")
			slider.Name = "Slider"
			slider.BackgroundTransparency = 1
			slider.Image = "rbxasset://textures/ui/Slider.png"
			slider.Position = UDim2.new(0,0,0.5,-10)
			slider.Size = UDim2.new(0,20,0,20)
			slider.ZIndex = 3
			slider.Parent = bar

			local areaSoakMouseMoveCon = nil

			areaSoak.MouseLeave:connect(function()
				if areaSoak.Visible then
					cancelSlide(areaSoak)
				end
			end)
			areaSoak.MouseButton1Up:connect(function()
				if areaSoak.Visible then
					cancelSlide(areaSoak)
				end
			end)

			slider.MouseButton1Down:connect(function()
				areaSoak.Visible = true
				if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
				areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
					setSliderPos(x,slider,sliderPosition,bar,steps)
				end)
			end)

			slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)

			sliderPosition.Changed:connect(function(prop)
				sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
				local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
				slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
			end)

			bar.MouseButton1Down:connect(function(x,y)
				setSliderPos(x,slider,sliderPosition,bar,steps)
			end)

			return sliderGui, sliderPosition, sliderSteps

		end



		t.CreateSliderNew = function(steps,width,position)
			local sliderGui = Instance.new("Frame")
			sliderGui.Size = UDim2.new(1,0,1,0)
			sliderGui.BackgroundTransparency = 1
			sliderGui.Name = "SliderGui"

			local sliderSteps = Instance.new("IntValue")
			sliderSteps.Name = "SliderSteps"
			sliderSteps.Value = steps
			sliderSteps.Parent = sliderGui

			local areaSoak = Instance.new("TextButton")
			areaSoak.Name = "AreaSoak"
			areaSoak.Text = ""
			areaSoak.BackgroundTransparency = 1
			areaSoak.Active = false
			areaSoak.Size = UDim2.new(1,0,1,0)
			areaSoak.Visible = false
			areaSoak.ZIndex = 6

			sliderGui.AncestryChanged:connect(function(child,parent)
				if parent == nil then
					areaSoak.Parent = nil
				else
					areaSoak.Parent = getLayerCollectorAncestor(sliderGui)
				end
			end)

			local sliderPosition = Instance.new("IntValue")
			sliderPosition.Name = "SliderPosition"
			sliderPosition.Value = 0
			sliderPosition.Parent = sliderGui

			local id = math.random(1,100)

			local sliderBarImgHeight = 7
			local sliderBarCapImgWidth = 4

			local bar = Instance.new("ImageButton")
			bar.BackgroundTransparency = 1
			bar.Image = "rbxasset://textures/ui/Slider-BKG-Center.png"
			bar.Name = "Bar"
			local displayWidth = 200
			if type(width) == "number" then
				bar.Size = UDim2.new(0,width - (sliderBarCapImgWidth * 2),0,sliderBarImgHeight)
				displayWidth = width - (sliderBarCapImgWidth * 2)
			else
				bar.Size = UDim2.new(0,200,0,sliderBarImgHeight)
			end
			bar.ZIndex = 3
			bar.Parent = sliderGui	
			if position["X"] and position["X"]["Scale"] and position["X"]["Offset"] and position["Y"] and position["Y"]["Scale"] and position["Y"]["Offset"] then
				bar.Position = position
			end

			local barLeft = bar:clone()
			barLeft.Name = "BarLeft"
			barLeft.Image = "rbxasset://textures/ui/Slider-BKG-Left-Cap.png"
			barLeft.Size = UDim2.new(0, sliderBarCapImgWidth, 0, sliderBarImgHeight)
			barLeft.Position = UDim2.new(position.X.Scale, position.X.Offset - sliderBarCapImgWidth, position.Y.Scale, position.Y.Offset)
			barLeft.Parent = sliderGui	
			barLeft.ZIndex = 3

			local barRight = barLeft:clone()
			barRight.Name = "BarRight"
			barRight.Image = "rbxasset://textures/ui/Slider-BKG-Right-Cap.png"
			barRight.Position = UDim2.new(position.X.Scale, position.X.Offset + displayWidth, position.Y.Scale, position.Y.Offset)
			barRight.Parent = sliderGui	

			local fillLeft = barLeft:clone()
			fillLeft.Name = "FillLeft"
			fillLeft.Image = "rbxasset://textures/ui/Slider-Fill-Left-Cap.png"
			fillLeft.Parent = sliderGui	
			fillLeft.ZIndex = 4

			local fill = fillLeft:clone()
			fill.Name = "Fill"
			fill.Image = "rbxasset://textures/ui/Slider-Fill-Center.png"
			fill.Parent = bar	
			fill.ZIndex = 4
			fill.Position = UDim2.new(0, 0, 0, 0)
			fill.Size = UDim2.new(0.5, 0, 1, 0)


			--	bar.Visible = false

			local slider = Instance.new("ImageButton")
			slider.Name = "Slider"
			slider.BackgroundTransparency = 1
			slider.Image = "rbxasset://textures/ui/slider_new_tab.png"
			slider.Position = UDim2.new(0,0,0.5,-14)
			slider.Size = UDim2.new(0,28,0,28)
			slider.ZIndex = 5
			slider.Parent = bar

			local areaSoakMouseMoveCon = nil

			areaSoak.MouseLeave:connect(function()
				if areaSoak.Visible then
					cancelSlide(areaSoak)
				end
			end)
			areaSoak.MouseButton1Up:connect(function()
				if areaSoak.Visible then
					cancelSlide(areaSoak)
				end
			end)

			slider.MouseButton1Down:connect(function()
				areaSoak.Visible = true
				if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
				areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
					setSliderPos(x,slider,sliderPosition,bar,steps)
				end)
			end)

			slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)

			sliderPosition.Changed:connect(function(prop)
				sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
				local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
				slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
				fill.Size = UDim2.new(relativePosX, 0, 1, 0)
			end)

			bar.MouseButton1Down:connect(function(x,y)
				setSliderPos(x,slider,sliderPosition,bar,steps)
			end)

			fill.MouseButton1Down:connect(function(x,y)
				setSliderPos(x,slider,sliderPosition,bar,steps)
			end)

			fillLeft.MouseButton1Down:connect(function(x,y)
				setSliderPos(x,slider,sliderPosition,bar,steps)
			end)


			return sliderGui, sliderPosition, sliderSteps

		end





		t.CreateTrueScrollingFrame = function()
			local lowY = nil
			local highY = nil

			local dragCon = nil
			local upCon = nil

			local internalChange = false

			local descendantsChangeConMap = {}

			local scrollingFrame = Instance.new("Frame")
			scrollingFrame.Name = "ScrollingFrame"
			scrollingFrame.Active = true
			scrollingFrame.Size = UDim2.new(1,0,1,0)
			scrollingFrame.ClipsDescendants = true

			local controlFrame = Instance.new("Frame")
			controlFrame.Name = "ControlFrame"
			controlFrame.BackgroundTransparency = 1
			controlFrame.Size = UDim2.new(0,18,1,0)
			controlFrame.Position = UDim2.new(1,-20,0,0)
			controlFrame.Parent = scrollingFrame

			local scrollBottom = Instance.new("BoolValue")
			scrollBottom.Value = false
			scrollBottom.Name = "ScrollBottom"
			scrollBottom.Parent = controlFrame

			local scrollUp = Instance.new("BoolValue")
			scrollUp.Value = false
			scrollUp.Name = "scrollUp"
			scrollUp.Parent = controlFrame

			local scrollUpButton = Instance.new("TextButton")
			scrollUpButton.Name = "ScrollUpButton"
			scrollUpButton.Text = ""
			scrollUpButton.AutoButtonColor = false
			scrollUpButton.BackgroundColor3 = Color3.new(0,0,0)
			scrollUpButton.BorderColor3 = Color3.new(1,1,1)
			scrollUpButton.BackgroundTransparency = 0.5
			scrollUpButton.Size = UDim2.new(0,18,0,18)
			scrollUpButton.ZIndex = 2
			scrollUpButton.Parent = controlFrame
			for i = 1, 6 do
				local triFrame = Instance.new("Frame")
				triFrame.BorderColor3 = Color3.new(1,1,1)
				triFrame.Name = "tri" .. tostring(i)
				triFrame.ZIndex = 3
				triFrame.BackgroundTransparency = 0.5
				triFrame.Size = UDim2.new(0,12 - ((i -1) * 2),0,0)
				triFrame.Position = UDim2.new(0,3 + (i -1),0.5,2 - (i -1))
				triFrame.Parent = scrollUpButton
			end
			scrollUpButton.MouseEnter:connect(function()
				scrollUpButton.BackgroundTransparency = 0.1
				local upChildren = scrollUpButton:GetChildren()
				for i = 1, #upChildren do
					upChildren[i].BackgroundTransparency = 0.1
				end
			end)
			scrollUpButton.MouseLeave:connect(function()
				scrollUpButton.BackgroundTransparency = 0.5
				local upChildren = scrollUpButton:GetChildren()
				for i = 1, #upChildren do
					upChildren[i].BackgroundTransparency = 0.5
				end
			end)

			local scrollDownButton = scrollUpButton:clone()
			scrollDownButton.Name = "ScrollDownButton"
			scrollDownButton.Position = UDim2.new(0,0,1,-18)
			local downChildren = scrollDownButton:GetChildren()
			for i = 1, #downChildren do
				downChildren[i].Position = UDim2.new(0,3 + (i -1),0.5,-2 + (i - 1))
			end
			scrollDownButton.MouseEnter:connect(function()
				scrollDownButton.BackgroundTransparency = 0.1
				local downChildren = scrollDownButton:GetChildren()
				for i = 1, #downChildren do
					downChildren[i].BackgroundTransparency = 0.1
				end
			end)
			scrollDownButton.MouseLeave:connect(function()
				scrollDownButton.BackgroundTransparency = 0.5
				local downChildren = scrollDownButton:GetChildren()
				for i = 1, #downChildren do
					downChildren[i].BackgroundTransparency = 0.5
				end
			end)
			scrollDownButton.Parent = controlFrame

			local scrollTrack = Instance.new("Frame")
			scrollTrack.Name = "ScrollTrack"
			scrollTrack.BackgroundTransparency = 1
			scrollTrack.Size = UDim2.new(0,18,1,-38)
			scrollTrack.Position = UDim2.new(0,0,0,19)
			scrollTrack.Parent = controlFrame

			local scrollbar = Instance.new("TextButton")
			scrollbar.BackgroundColor3 = Color3.new(0,0,0)
			scrollbar.BorderColor3 = Color3.new(1,1,1)
			scrollbar.BackgroundTransparency = 0.5
			scrollbar.AutoButtonColor = false
			scrollbar.Text = ""
			scrollbar.Active = true
			scrollbar.Name = "ScrollBar"
			scrollbar.ZIndex = 2
			scrollbar.BackgroundTransparency = 0.5
			scrollbar.Size = UDim2.new(0, 18, 0.1, 0)
			scrollbar.Position = UDim2.new(0,0,0,0)
			scrollbar.Parent = scrollTrack

			local scrollNub = Instance.new("Frame")
			scrollNub.Name = "ScrollNub"
			scrollNub.BorderColor3 = Color3.new(1,1,1)
			scrollNub.Size = UDim2.new(0,10,0,0)
			scrollNub.Position = UDim2.new(0.5,-5,0.5,0)
			scrollNub.ZIndex = 2
			scrollNub.BackgroundTransparency = 0.5
			scrollNub.Parent = scrollbar

			local newNub = scrollNub:clone()
			newNub.Position = UDim2.new(0.5,-5,0.5,-2)
			newNub.Parent = scrollbar

			local lastNub = scrollNub:clone()
			lastNub.Position = UDim2.new(0.5,-5,0.5,2)
			lastNub.Parent = scrollbar

			scrollbar.MouseEnter:connect(function()
				scrollbar.BackgroundTransparency = 0.1
				scrollNub.BackgroundTransparency = 0.1
				newNub.BackgroundTransparency = 0.1
				lastNub.BackgroundTransparency = 0.1
			end)
			scrollbar.MouseLeave:connect(function()
				scrollbar.BackgroundTransparency = 0.5
				scrollNub.BackgroundTransparency = 0.5
				newNub.BackgroundTransparency = 0.5
				lastNub.BackgroundTransparency = 0.5
			end)

			local mouseDrag = Instance.new("ImageButton")
			mouseDrag.Active = false
			mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
			mouseDrag.AutoButtonColor = false
			mouseDrag.BackgroundTransparency = 1
			mouseDrag.Name = "mouseDrag"
			mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
			mouseDrag.ZIndex = 10

			local function positionScrollBar(x,y,offset)
				local oldPos = scrollbar.Position

				if y < scrollTrack.AbsolutePosition.y then
					scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
					return (oldPos ~= scrollbar.Position)
				end

				local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y

				if y > (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
					scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
					return (oldPos ~= scrollbar.Position)
				end
				local newScaleYPos = (y - scrollTrack.AbsolutePosition.y - offset)/scrollTrack.AbsoluteSize.y
				if newScaleYPos + relativeSize > 1 then
					newScaleYPos = 1 - relativeSize
					scrollBottom.Value = true
					scrollUp.Value = false
				elseif newScaleYPos <= 0 then
					newScaleYPos = 0
					scrollUp.Value = true
					scrollBottom.Value = false
				else
					scrollUp.Value = false
					scrollBottom.Value = false
				end
				scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,newScaleYPos,0)

				return (oldPos ~= scrollbar.Position)
			end

			local function drillDownSetHighLow(instance)
				if not instance or not instance:IsA("GuiObject") then return end
				if instance == controlFrame then return end
				if instance:IsDescendantOf(controlFrame) then return end
				if not instance.Visible then return end

				if lowY and lowY > instance.AbsolutePosition.Y then
					lowY = instance.AbsolutePosition.Y
				elseif not lowY then
					lowY = instance.AbsolutePosition.Y
				end
				if highY and highY < (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) then
					highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
				elseif not highY then
					highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
				end
				local children = instance:GetChildren()
				for i = 1, #children do
					drillDownSetHighLow(children[i])
				end
			end

			local function resetHighLow()
				local firstChildren = scrollingFrame:GetChildren()

				for i = 1, #firstChildren do
					drillDownSetHighLow(firstChildren[i])
				end
			end

			local function recalculate()
				internalChange = true

				local percentFrame = 0
				if scrollbar.Position.Y.Scale > 0 then
					if scrollbar.Visible then
						percentFrame = scrollbar.Position.Y.Scale/((scrollTrack.AbsoluteSize.Y - scrollbar.AbsoluteSize.Y)/scrollTrack.AbsoluteSize.Y)
					else
						percentFrame = 0
					end
				end
				if percentFrame > 0.99 then percentFrame = 1 end

				local hiddenYAmount = (scrollingFrame.AbsoluteSize.Y - (highY - lowY)) * percentFrame

				local guiChildren = scrollingFrame:GetChildren()
				for i = 1, #guiChildren do
					if guiChildren[i] ~= controlFrame then
						guiChildren[i].Position = UDim2.new(guiChildren[i].Position.X.Scale,guiChildren[i].Position.X.Offset,
							0, math.ceil(guiChildren[i].AbsolutePosition.Y) - math.ceil(lowY) + hiddenYAmount)
					end
				end

				lowY = nil
				highY = nil
				resetHighLow()
				internalChange = false
			end

			local function setSliderSizeAndPosition()
				if not highY or not lowY then return end

				local totalYSpan = math.abs(highY - lowY)
				if totalYSpan == 0 then
					scrollbar.Visible = false
					scrollDownButton.Visible = false
					scrollUpButton.Visible = false

					if dragCon then dragCon:disconnect() dragCon = nil end
					if upCon then upCon:disconnect() upCon = nil end
					return
				end

				local percentShown = scrollingFrame.AbsoluteSize.Y/totalYSpan
				if percentShown >= 1 then
					scrollbar.Visible = false
					scrollDownButton.Visible = false
					scrollUpButton.Visible = false
					recalculate()
				else
					scrollbar.Visible = true
					scrollDownButton.Visible = true
					scrollUpButton.Visible = true

					scrollbar.Size = UDim2.new(scrollbar.Size.X.Scale,scrollbar.Size.X.Offset,percentShown,0)
				end

				local percentPosition = (scrollingFrame.AbsolutePosition.Y - lowY)/totalYSpan
				scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,percentPosition,-scrollbar.AbsoluteSize.X/2)

				if scrollbar.AbsolutePosition.y < scrollTrack.AbsolutePosition.y then
					scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
				end

				if (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.Y) > (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
					local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
					scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
				end
			end

			local buttonScrollAmountPixels = 7
			local reentrancyGuardScrollUp = false
			local function doScrollUp()
				if reentrancyGuardScrollUp then return end

				reentrancyGuardScrollUp = true
				if positionScrollBar(0,scrollbar.AbsolutePosition.Y - buttonScrollAmountPixels,0) then
					recalculate()
				end
				reentrancyGuardScrollUp = false
			end

			local reentrancyGuardScrollDown = false
			local function doScrollDown()
				if reentrancyGuardScrollDown then return end

				reentrancyGuardScrollDown = true
				if positionScrollBar(0,scrollbar.AbsolutePosition.Y + buttonScrollAmountPixels,0) then
					recalculate()
				end
				reentrancyGuardScrollDown = false
			end

			local function scrollUp(mouseYPos)
				if scrollUpButton.Active then
					scrollStamp = tick()
					local current = scrollStamp
					local upCon
					upCon = mouseDrag.MouseButton1Up:connect(function()
						scrollStamp = tick()
						mouseDrag.Parent = nil
						upCon:disconnect()
					end)
					mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
					doScrollUp()
					wait(0.2)
					local t = tick()
					local w = 0.1
					while scrollStamp == current do
						doScrollUp()
						if mouseYPos and mouseYPos > scrollbar.AbsolutePosition.y then
							break
						end
						if not scrollUpButton.Active then break end
						if tick()-t > 5 then
							w = 0
						elseif tick()-t > 2 then
							w = 0.06
						end
						wait(w)
					end
				end
			end

			local function scrollDown(mouseYPos)
				if scrollDownButton.Active then
					scrollStamp = tick()
					local current = scrollStamp
					local downCon
					downCon = mouseDrag.MouseButton1Up:connect(function()
						scrollStamp = tick()
						mouseDrag.Parent = nil
						downCon:disconnect()
					end)
					mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
					doScrollDown()
					wait(0.2)
					local t = tick()
					local w = 0.1
					while scrollStamp == current do
						doScrollDown()
						if mouseYPos and mouseYPos < (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.x) then
							break
						end
						if not scrollDownButton.Active then break end
						if tick()-t > 5 then
							w = 0
						elseif tick()-t > 2 then
							w = 0.06
						end
						wait(w)
					end
				end
			end

			scrollbar.MouseButton1Down:connect(function(x,y)
				if scrollbar.Active then
					scrollStamp = tick()
					local mouseOffset = y - scrollbar.AbsolutePosition.y
					if dragCon then dragCon:disconnect() dragCon = nil end
					if upCon then upCon:disconnect() upCon = nil end
					local prevY = y
					local reentrancyGuardMouseScroll = false
					dragCon = mouseDrag.MouseMoved:connect(function(x,y)
						if reentrancyGuardMouseScroll then return end

						reentrancyGuardMouseScroll = true
						if positionScrollBar(x,y,mouseOffset) then
							recalculate()
						end
						reentrancyGuardMouseScroll = false

					end)
					upCon = mouseDrag.MouseButton1Up:connect(function()
						scrollStamp = tick()
						mouseDrag.Parent = nil
						dragCon:disconnect(); dragCon = nil
						upCon:disconnect(); drag = nil
					end)
					mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
				end
			end)

			local scrollMouseCount = 0

			scrollUpButton.MouseButton1Down:connect(function()
				scrollUp()
			end)
			scrollUpButton.MouseButton1Up:connect(function()
				scrollStamp = tick()
			end)

			scrollDownButton.MouseButton1Up:connect(function()
				scrollStamp = tick()
			end)
			scrollDownButton.MouseButton1Down:connect(function()
				scrollDown()
			end)

			scrollbar.MouseButton1Up:connect(function()
				scrollStamp = tick()
			end)

			local function heightCheck(instance)
				if highY and (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) > highY then
					highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
				elseif not highY then
					highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
				end
				setSliderSizeAndPosition()
			end

			local function highLowRecheck()
				local oldLowY = lowY
				local oldHighY = highY
				lowY = nil
				highY = nil
				resetHighLow()

				if (lowY ~= oldLowY) or (highY ~= oldHighY) then
					setSliderSizeAndPosition()
				end
			end

			local function descendantChanged(this, prop)
				if internalChange then return end
				if not this.Visible then return end

				if prop == "Size" or prop == "Position" then
					wait()
					highLowRecheck()
				end
			end

			scrollingFrame.DescendantAdded:connect(function(instance)
				if not instance:IsA("GuiObject") then return end

				if instance.Visible then
					wait() -- wait a heartbeat for sizes to reconfig
					highLowRecheck()
				end

				descendantsChangeConMap[instance] = instance.Changed:connect(function(prop) descendantChanged(instance, prop) end)
			end)

			scrollingFrame.DescendantRemoving:connect(function(instance)
				if not instance:IsA("GuiObject") then return end
				if descendantsChangeConMap[instance] then
					descendantsChangeConMap[instance]:disconnect()
					descendantsChangeConMap[instance] = nil
				end
				wait() -- wait a heartbeat for sizes to reconfig
				highLowRecheck()
			end)

			scrollingFrame.Changed:connect(function(prop)
				if prop == "AbsoluteSize" then
					if not highY or not lowY then return end

					highLowRecheck()
					setSliderSizeAndPosition()
				end
			end)

			return scrollingFrame, controlFrame
		end

		t.CreateScrollingFrame = function(orderList,scrollStyle)
			local frame = Instance.new("Frame")
			frame.Name = "ScrollingFrame"
			frame.BackgroundTransparency = 1
			frame.Size = UDim2.new(1,0,1,0)

			local scrollUpButton = Instance.new("ImageButton")
			scrollUpButton.Name = "ScrollUpButton"
			scrollUpButton.BackgroundTransparency = 1
			scrollUpButton.Image = "rbxasset://textures/ui/scrollbuttonUp.png"
			scrollUpButton.Size = UDim2.new(0,17,0,17) 


			local scrollDownButton = Instance.new("ImageButton")
			scrollDownButton.Name = "ScrollDownButton"
			scrollDownButton.BackgroundTransparency = 1
			scrollDownButton.Image = "rbxasset://textures/ui/scrollbuttonDown.png"
			scrollDownButton.Size = UDim2.new(0,17,0,17) 

			local scrollbar = Instance.new("ImageButton")
			scrollbar.Name = "ScrollBar"
			scrollbar.Image = "rbxasset://textures/ui/scrollbar.png"
			scrollbar.BackgroundTransparency = 1
			scrollbar.Size = UDim2.new(0, 18, 0, 150)

			local scrollStamp = 0

			local scrollDrag = Instance.new("ImageButton")
			scrollDrag.Image = "https://www.roblox.com/asset/?id=61367186"
			scrollDrag.Size = UDim2.new(1, 0, 0, 16)
			scrollDrag.BackgroundTransparency = 1
			scrollDrag.Name = "ScrollDrag"
			scrollDrag.Active = true
			scrollDrag.Parent = scrollbar

			local mouseDrag = Instance.new("ImageButton")
			mouseDrag.Active = false
			mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
			mouseDrag.AutoButtonColor = false
			mouseDrag.BackgroundTransparency = 1
			mouseDrag.Name = "mouseDrag"
			mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
			mouseDrag.ZIndex = 10

			local style = "simple"
			if scrollStyle and tostring(scrollStyle) then
				style = scrollStyle
			end

			local scrollPosition = 1
			local rowSize = 0
			local howManyDisplayed = 0

			local layoutGridScrollBar = function()
				howManyDisplayed = 0
				local guiObjects = {}
				if orderList then
					for i, child in ipairs(orderList) do
						if child.Parent == frame then
							table.insert(guiObjects, child)
						end
					end
				else
					local children = frame:GetChildren()
					if children then
						for i, child in ipairs(children) do 
							if child:IsA("GuiObject") then
								table.insert(guiObjects, child)
							end
						end
					end
				end
				if #guiObjects == 0 then
					scrollUpButton.Active = false
					scrollDownButton.Active = false
					scrollDrag.Active = false
					scrollPosition = 1
					return
				end

				if scrollPosition > #guiObjects then
					scrollPosition = #guiObjects
				end

				if scrollPosition < 1 then scrollPosition = 1 end

				local totalPixelsY = frame.AbsoluteSize.Y
				local pixelsRemainingY = frame.AbsoluteSize.Y

				local totalPixelsX  = frame.AbsoluteSize.X

				local xCounter = 0
				local rowSizeCounter = 0
				local setRowSize = true

				local pixelsBelowScrollbar = 0
				local pos = #guiObjects

				local currentRowY = 0

				pos = scrollPosition
				--count up from current scroll position to fill out grid
				while pos <= #guiObjects and pixelsBelowScrollbar < totalPixelsY do
					xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
					--previous pos was the end of a row
					if xCounter >= totalPixelsX then
						pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
						currentRowY = 0
						xCounter = guiObjects[pos].AbsoluteSize.X
					end
					if guiObjects[pos].AbsoluteSize.Y > currentRowY then
						currentRowY = guiObjects[pos].AbsoluteSize.Y
					end
					pos = pos + 1
				end
				--Count wherever current row left off
				pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
				currentRowY = 0

				pos = scrollPosition - 1
				xCounter = 0

				--objects with varying X,Y dimensions can rarely cause minor errors
				--rechecking every new scrollPosition is necessary to avoid 100% of errors

				--count backwards from current scrollPosition to see if we can add more rows
				while pixelsBelowScrollbar + currentRowY < totalPixelsY and pos >= 1 do
					xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
					rowSizeCounter = rowSizeCounter + 1
					if xCounter >= totalPixelsX then
						rowSize = rowSizeCounter - 1
						rowSizeCounter = 0
						xCounter = guiObjects[pos].AbsoluteSize.X
						if pixelsBelowScrollbar + currentRowY <= totalPixelsY then
							--It fits, so back up our scroll position
							pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
							if scrollPosition <= rowSize then
								scrollPosition = 1 
								break
							else
								scrollPosition = scrollPosition - rowSize
							end
							currentRowY = 0
						else
							break
						end
					end

					if guiObjects[pos].AbsoluteSize.Y > currentRowY then
						currentRowY = guiObjects[pos].AbsoluteSize.Y
					end

					pos = pos - 1
				end

				--Do check last time if pos = 0
				if (pos == 0) and (pixelsBelowScrollbar + currentRowY <= totalPixelsY) then
					scrollPosition = 1
				end

				xCounter = 0
				--pos = scrollPosition
				rowSizeCounter = 0
				setRowSize = true
				local lastChildSize = 0

				local xOffset,yOffset = 0
				if guiObjects[1] then
					yOffset = math.ceil(math.floor(math.fmod(totalPixelsY,guiObjects[1].AbsoluteSize.X))/2)
					xOffset = math.ceil(math.floor(math.fmod(totalPixelsX,guiObjects[1].AbsoluteSize.Y))/2)
				end

				for i, child in ipairs(guiObjects) do
					if i < scrollPosition then
						--print("Hiding " .. child.Name)
						child.Visible = false
					else
						if pixelsRemainingY < 0 then
							--print("Out of Space " .. child.Name)
							child.Visible = false
						else
							--print("Laying out " .. child.Name)
							--GuiObject
							if setRowSize then rowSizeCounter = rowSizeCounter + 1 end
							if xCounter + child.AbsoluteSize.X >= totalPixelsX then
								if setRowSize then
									rowSize = rowSizeCounter - 1
									setRowSize = false
								end
								xCounter = 0
								pixelsRemainingY = pixelsRemainingY - child.AbsoluteSize.Y
							end
							child.Position = UDim2.new(child.Position.X.Scale,xCounter + xOffset, 0, totalPixelsY - pixelsRemainingY + yOffset)
							xCounter = xCounter + child.AbsoluteSize.X
							child.Visible = ((pixelsRemainingY - child.AbsoluteSize.Y) >= 0)
							if child.Visible then
								howManyDisplayed = howManyDisplayed + 1
							end
							lastChildSize = child.AbsoluteSize				
						end
					end
				end

				scrollUpButton.Active = (scrollPosition > 1)
				if lastChildSize == 0 then 
					scrollDownButton.Active = false
				else
					scrollDownButton.Active = ((pixelsRemainingY - lastChildSize.Y) < 0)
				end
				scrollDrag.Active = #guiObjects > howManyDisplayed
				scrollDrag.Visible = scrollDrag.Active
			end



			local layoutSimpleScrollBar = function()
				local guiObjects = {}	
				howManyDisplayed = 0

				if orderList then
					for i, child in ipairs(orderList) do
						if child.Parent == frame then
							table.insert(guiObjects, child)
						end
					end
				else
					local children = frame:GetChildren()
					if children then
						for i, child in ipairs(children) do 
							if child:IsA("GuiObject") then
								table.insert(guiObjects, child)
							end
						end
					end
				end
				if #guiObjects == 0 then
					scrollUpButton.Active = false
					scrollDownButton.Active = false
					scrollDrag.Active = false
					scrollPosition = 1
					return
				end

				if scrollPosition > #guiObjects then
					scrollPosition = #guiObjects
				end

				local totalPixels = frame.AbsoluteSize.Y
				local pixelsRemaining = frame.AbsoluteSize.Y

				local pixelsBelowScrollbar = 0
				local pos = #guiObjects
				while pixelsBelowScrollbar < totalPixels and pos >= 1 do
					if pos >= scrollPosition then
						pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
					else
						if pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y <= totalPixels then
							--It fits, so back up our scroll position
							pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
							if scrollPosition <= 1 then
								scrollPosition = 1
								break
							else
								--local ("Backing up ScrollPosition from -- " ..scrollPosition)
								scrollPosition = scrollPosition - 1
							end
						else
							break
						end
					end
					pos = pos - 1
				end

				pos = scrollPosition
				for i, child in ipairs(guiObjects) do
					if i < scrollPosition then
						--print("Hiding " .. child.Name)
						child.Visible = false
					else
						if pixelsRemaining < 0 then
							--print("Out of Space " .. child.Name)
							child.Visible = false
						else
							--print("Laying out " .. child.Name)
							--GuiObject
							child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
							pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
							if  (pixelsRemaining >= 0) then
								child.Visible = true
								howManyDisplayed = howManyDisplayed + 1
							else
								child.Visible = false
							end		
						end
					end
				end
				scrollUpButton.Active = (scrollPosition > 1)
				scrollDownButton.Active = (pixelsRemaining < 0)
				scrollDrag.Active = #guiObjects > howManyDisplayed
				scrollDrag.Visible = scrollDrag.Active
			end


			local moveDragger = function()	
				local guiObjects = 0
				local children = frame:GetChildren()
				if children then
					for i, child in ipairs(children) do 
						if child:IsA("GuiObject") then
							guiObjects = guiObjects + 1
						end
					end
				end

				if not scrollDrag.Parent then return end

				local dragSizeY = scrollDrag.Parent.AbsoluteSize.y * (1/(guiObjects - howManyDisplayed + 1))
				if dragSizeY < 16 then dragSizeY = 16 end
				scrollDrag.Size = UDim2.new(scrollDrag.Size.X.Scale,scrollDrag.Size.X.Offset,scrollDrag.Size.Y.Scale,dragSizeY)

				local relativeYPos = (scrollPosition - 1)/(guiObjects - (howManyDisplayed))
				if relativeYPos > 1 then relativeYPos = 1
				elseif relativeYPos < 0 then relativeYPos = 0 end
				local absYPos = 0

				if relativeYPos ~= 0 then
					absYPos = (relativeYPos * scrollbar.AbsoluteSize.y) - (relativeYPos * scrollDrag.AbsoluteSize.y)
				end

				scrollDrag.Position = UDim2.new(scrollDrag.Position.X.Scale,scrollDrag.Position.X.Offset,scrollDrag.Position.Y.Scale,absYPos)
			end

			local reentrancyGuard = false
			local recalculate = function()
				if reentrancyGuard then
					return
				end
				reentrancyGuard = true
				wait()
				local success, err = nil
				if style == "grid" then
					success, err = pcall(function() layoutGridScrollBar() end)
				elseif style == "simple" then
					success, err = pcall(function() layoutSimpleScrollBar() end)
				end
				if not success then print(err) end
				moveDragger()
				reentrancyGuard = false
			end

			local doScrollUp = function()
				scrollPosition = (scrollPosition) - rowSize
				if scrollPosition < 1 then scrollPosition = 1 end
				recalculate(nil)
			end

			local doScrollDown = function()
				scrollPosition = (scrollPosition) + rowSize
				recalculate(nil)
			end

			local scrollUp = function(mouseYPos)
				if scrollUpButton.Active then
					scrollStamp = tick()
					local current = scrollStamp
					local upCon
					upCon = mouseDrag.MouseButton1Up:connect(function()
						scrollStamp = tick()
						mouseDrag.Parent = nil
						upCon:disconnect()
					end)
					mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
					doScrollUp()
					wait(0.2)
					local t = tick()
					local w = 0.1
					while scrollStamp == current do
						doScrollUp()
						if mouseYPos and mouseYPos > scrollDrag.AbsolutePosition.y then
							break
						end
						if not scrollUpButton.Active then break end
						if tick()-t > 5 then
							w = 0
						elseif tick()-t > 2 then
							w = 0.06
						end
						wait(w)
					end
				end
			end

			local scrollDown = function(mouseYPos)
				if scrollDownButton.Active then
					scrollStamp = tick()
					local current = scrollStamp
					local downCon
					downCon = mouseDrag.MouseButton1Up:connect(function()
						scrollStamp = tick()
						mouseDrag.Parent = nil
						downCon:disconnect()
					end)
					mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
					doScrollDown()
					wait(0.2)
					local t = tick()
					local w = 0.1
					while scrollStamp == current do
						doScrollDown()
						if mouseYPos and mouseYPos < (scrollDrag.AbsolutePosition.y + scrollDrag.AbsoluteSize.x) then
							break
						end
						if not scrollDownButton.Active then break end
						if tick()-t > 5 then
							w = 0
						elseif tick()-t > 2 then
							w = 0.06
						end
						wait(w)
					end
				end
			end

			local y = 0
			scrollDrag.MouseButton1Down:connect(function(x,y)
				if scrollDrag.Active then
					scrollStamp = tick()
					local mouseOffset = y - scrollDrag.AbsolutePosition.y
					local dragCon
					local upCon
					dragCon = mouseDrag.MouseMoved:connect(function(x,y)
						local barAbsPos = scrollbar.AbsolutePosition.y
						local barAbsSize = scrollbar.AbsoluteSize.y

						local dragAbsSize = scrollDrag.AbsoluteSize.y
						local barAbsOne = barAbsPos + barAbsSize - dragAbsSize
						y = y - mouseOffset
						y = y < barAbsPos and barAbsPos or y > barAbsOne and barAbsOne or y
						y = y - barAbsPos

						local guiObjects = 0
						local children = frame:GetChildren()
						if children then
							for i, child in ipairs(children) do 
								if child:IsA("GuiObject") then
									guiObjects = guiObjects + 1
								end
							end
						end

						local doublePercent = y/(barAbsSize-dragAbsSize)
						local rowDiff = rowSize
						local totalScrollCount = guiObjects - (howManyDisplayed - 1)
						local newScrollPosition = math.floor((doublePercent * totalScrollCount) + 0.5) + rowDiff
						if newScrollPosition < scrollPosition then
							rowDiff = -rowDiff
						end

						if newScrollPosition < 1 then
							newScrollPosition = 1
						end

						scrollPosition = newScrollPosition
						recalculate(nil)
					end)
					upCon = mouseDrag.MouseButton1Up:connect(function()
						scrollStamp = tick()
						mouseDrag.Parent = nil
						dragCon:disconnect(); dragCon = nil
						upCon:disconnect(); drag = nil
					end)
					mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
				end
			end)

			local scrollMouseCount = 0

			scrollUpButton.MouseButton1Down:connect(
				function()
					scrollUp()
				end)
			scrollUpButton.MouseButton1Up:connect(function()
				scrollStamp = tick()
			end)


			scrollDownButton.MouseButton1Up:connect(function()
				scrollStamp = tick()
			end)
			scrollDownButton.MouseButton1Down:connect(
				function()
					scrollDown()	
				end)

			scrollbar.MouseButton1Up:connect(function()
				scrollStamp = tick()
			end)
			scrollbar.MouseButton1Down:connect(
				function(x,y)
					if y > (scrollDrag.AbsoluteSize.y + scrollDrag.AbsolutePosition.y) then
						scrollDown(y)
					elseif y < (scrollDrag.AbsolutePosition.y) then
						scrollUp(y)
					end
				end)


			frame.ChildAdded:connect(function()
				recalculate(nil)
			end)

			frame.ChildRemoved:connect(function()
				recalculate(nil)
			end)

			frame.Changed:connect(
				function(prop)
					if prop == "AbsoluteSize" then
						--Wait a heartbeat for it to sync in
						recalculate(nil)
					end
				end)
			frame.AncestryChanged:connect(function() recalculate(nil) end)

			return frame, scrollUpButton, scrollDownButton, recalculate, scrollbar
		end
		local function binaryGrow(min, max, fits)
			if min > max then
				return min
			end
			local biggestLegal = min

			while min <= max do
				local mid = min + math.floor((max - min) / 2)
				if fits(mid) and (biggestLegal == nil or biggestLegal < mid) then
					biggestLegal = mid

					--Try growing
					min = mid + 1
				else
					--Doesn't fit, shrink
					max = mid - 1
				end
			end
			return biggestLegal
		end


		local function binaryShrink(min, max, fits)
			if min > max then
				return min
			end
			local smallestLegal = max

			while min <= max do
				local mid = min + math.floor((max - min) / 2)
				if fits(mid) and (smallestLegal == nil or smallestLegal > mid) then
					smallestLegal = mid

					--It fits, shrink
					max = mid - 1			
				else
					--Doesn't fit, grow
					min = mid + 1
				end
			end
			return smallestLegal
		end


		local function getGuiOwner(instance)
			while instance ~= nil do
				if instance:IsA("ScreenGui") or instance:IsA("BillboardGui")  then
					return instance
				end
				instance = instance.Parent
			end
			return nil
		end

		t.AutoTruncateTextObject = function(textLabel)
			local text = textLabel.Text

			local fullLabel = textLabel:Clone()
			fullLabel.Name = "Full" .. textLabel.Name 
			fullLabel.BorderSizePixel = 0
			fullLabel.BackgroundTransparency = 0
			fullLabel.Text = text
			fullLabel.TextXAlignment = Enum.TextXAlignment.Center
			fullLabel.Position = UDim2.new(0,-3,0,0)
			fullLabel.Size = UDim2.new(0,100,1,0)
			fullLabel.Visible = false
			fullLabel.Parent = textLabel

			local shortText = nil
			local mouseEnterConnection = nil
			local mouseLeaveConnection= nil

			local checkForResize = function()
				if getGuiOwner(textLabel) == nil then
					return
				end
				textLabel.Text = text
				if textLabel.TextFits then 
					--Tear down the rollover if it is active
					if mouseEnterConnection then
						mouseEnterConnection:disconnect()
						mouseEnterConnection = nil
					end
					if mouseLeaveConnection then
						mouseLeaveConnection:disconnect()
						mouseLeaveConnection = nil
					end
				else
					local len = string.len(text)
					textLabel.Text = text .. "~"

					--Shrink the text
					local textSize = binaryGrow(0, len, 
						function(pos)
							if pos == 0 then
								textLabel.Text = "~"
							else
								textLabel.Text = string.sub(text, 1, pos) .. "~"
							end
							return textLabel.TextFits
						end)
					shortText = string.sub(text, 1, textSize) .. "~"
					textLabel.Text = shortText

					--Make sure the fullLabel fits
					if not fullLabel.TextFits then
						--Already too small, grow it really bit to start
						fullLabel.Size = UDim2.new(0, 10000, 1, 0)
					end

					--Okay, now try to binary shrink it back down
					local fullLabelSize = binaryShrink(textLabel.AbsoluteSize.X,fullLabel.AbsoluteSize.X, 
						function(size)
							fullLabel.Size = UDim2.new(0, size, 1, 0)
							return fullLabel.TextFits
						end)
					fullLabel.Size = UDim2.new(0,fullLabelSize+6,1,0)

					--Now setup the rollover effects, if they are currently off
					if mouseEnterConnection == nil then
						mouseEnterConnection = textLabel.MouseEnter:connect(
							function()
								fullLabel.ZIndex = textLabel.ZIndex + 1
								fullLabel.Visible = true
								--textLabel.Text = ""
							end)
					end
					if mouseLeaveConnection == nil then
						mouseLeaveConnection = textLabel.MouseLeave:connect(
							function()
								fullLabel.Visible = false
								--textLabel.Text = shortText
							end)
					end
				end
			end
			textLabel.AncestryChanged:connect(checkForResize)
			textLabel.Changed:connect(
				function(prop) 
					if prop == "AbsoluteSize" then 
						checkForResize() 	
					end 
				end)

			checkForResize()

			local function changeText(newText)
				text = newText
				fullLabel.Text = text
				checkForResize()
			end

			return textLabel, changeText
		end

		local function TransitionTutorialPages(fromPage, toPage, transitionFrame, currentPageValue)	
			if fromPage then
				fromPage.Visible = false
				if transitionFrame.Visible == false then
					transitionFrame.Size = fromPage.Size
					transitionFrame.Position = fromPage.Position
				end
			else
				if transitionFrame.Visible == false then
					transitionFrame.Size = UDim2.new(0.0,50,0.0,50)
					transitionFrame.Position = UDim2.new(0.5,-25,0.5,-25)
				end
			end
			transitionFrame.Visible = true
			currentPageValue.Value = nil

			local newSize, newPosition
			if toPage then
				--Make it visible so it resizes
				toPage.Visible = true

				newSize = toPage.Size
				newPosition = toPage.Position

				toPage.Visible = false
			else
				newSize = UDim2.new(0.0,50,0.0,50)
				newPosition = UDim2.new(0.5,-25,0.5,-25)
			end
			transitionFrame:TweenSizeAndPosition(newSize, newPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.3, true,
				function(state)
					if state == Enum.TweenStatus.Completed then
						transitionFrame.Visible = false
						if toPage then
							toPage.Visible = true
							currentPageValue.Value = toPage
						end
					end
				end)
		end

		t.CreateTutorial = function(name, tutorialKey, createButtons)
			local frame = Instance.new("Frame")
			frame.Name = "Tutorial-" .. name
			frame.BackgroundTransparency = 1
			frame.Size = UDim2.new(0.6, 0, 0.6, 0)
			frame.Position = UDim2.new(0.2, 0, 0.2, 0)

			local transitionFrame = Instance.new("Frame")
			transitionFrame.Name = "TransitionFrame"
			transitionFrame.Style = Enum.FrameStyle.RobloxRound
			transitionFrame.Size = UDim2.new(0.6, 0, 0.6, 0)
			transitionFrame.Position = UDim2.new(0.2, 0, 0.2, 0)
			transitionFrame.Visible = false
			transitionFrame.Parent = frame

			local currentPageValue = Instance.new("ObjectValue")
			currentPageValue.Name = "CurrentTutorialPage"
			currentPageValue.Value = nil
			currentPageValue.Parent = frame

			local boolValue = Instance.new("BoolValue")
			boolValue.Name = "Buttons"
			boolValue.Value = createButtons
			boolValue.Parent = frame

			local pages = Instance.new("Frame")
			pages.Name = "Pages"
			pages.BackgroundTransparency = 1
			pages.Size = UDim2.new(1,0,1,0)
			pages.Parent = frame

			local function getVisiblePageAndHideOthers()
				local visiblePage = nil
				local children = pages:GetChildren()
				if children then
					for i,child in ipairs(children) do
						if child.Visible then
							if visiblePage then
								child.Visible = false
							else
								visiblePage = child
							end
						end
					end
				end
				return visiblePage
			end

			local showTutorial = function(alwaysShow)
				if alwaysShow or UserSettings().GameSettings:GetTutorialState(tutorialKey) == false then
					print("Showing tutorial-",tutorialKey)
					local currentTutorialPage = getVisiblePageAndHideOthers()

					local firstPage = pages:FindFirstChild("TutorialPage1")
					if firstPage then
						TransitionTutorialPages(currentTutorialPage, firstPage, transitionFrame, currentPageValue)	
					else
						error("Could not find TutorialPage1")
					end
				end
			end

			local dismissTutorial = function()
				local currentTutorialPage = getVisiblePageAndHideOthers()

				if currentTutorialPage then
					TransitionTutorialPages(currentTutorialPage, nil, transitionFrame, currentPageValue)
				end

				UserSettings().GameSettings:SetTutorialState(tutorialKey, true)
			end

			local gotoPage = function(pageNum)
				local page = pages:FindFirstChild("TutorialPage" .. pageNum)
				local currentTutorialPage = getVisiblePageAndHideOthers()
				TransitionTutorialPages(currentTutorialPage, page, transitionFrame, currentPageValue)
			end

			return frame, showTutorial, dismissTutorial, gotoPage
		end 

		local function CreateBasicTutorialPage(name, handleResize, skipTutorial, giveDoneButton)
			local frame = Instance.new("Frame")
			frame.Name = "TutorialPage"
			frame.Style = Enum.FrameStyle.RobloxRound
			frame.Size = UDim2.new(0.6, 0, 0.6, 0)
			frame.Position = UDim2.new(0.2, 0, 0.2, 0)
			frame.Visible = false

			local frameHeader = Instance.new("TextLabel")
			frameHeader.Name = "Header"
			frameHeader.Text = name
			frameHeader.BackgroundTransparency = 1
			frameHeader.FontSize = Enum.FontSize.Size24
			frameHeader.Font = Enum.Font.ArialBold
			frameHeader.TextColor3 = Color3.new(1,1,1)
			frameHeader.TextXAlignment = Enum.TextXAlignment.Center
			frameHeader.TextWrap = true
			frameHeader.Size = UDim2.new(1,-55, 0, 22)
			frameHeader.Position = UDim2.new(0,0,0,0)
			frameHeader.Parent = frame

			local skipButton = Instance.new("ImageButton")
			skipButton.Name = "SkipButton"
			skipButton.AutoButtonColor = false
			skipButton.BackgroundTransparency = 1
			skipButton.Image = "rbxasset://textures/ui/closeButton.png"
			skipButton.MouseButton1Click:connect(function()
				skipTutorial()
			end)
			skipButton.MouseEnter:connect(function()
				skipButton.Image = "rbxasset://textures/ui/closeButton_dn.png"
			end)
			skipButton.MouseLeave:connect(function()
				skipButton.Image = "rbxasset://textures/ui/closeButton.png"
			end)
			skipButton.Size = UDim2.new(0, 25, 0, 25)
			skipButton.Position = UDim2.new(1, -25, 0, 0)
			skipButton.Parent = frame


			if giveDoneButton then
				local doneButton = Instance.new("TextButton")
				doneButton.Name = "DoneButton"
				doneButton.Style = Enum.ButtonStyle.RobloxButtonDefault
				doneButton.Text = "Done"
				doneButton.TextColor3 = Color3.new(1,1,1)
				doneButton.Font = Enum.Font.ArialBold
				doneButton.FontSize = Enum.FontSize.Size18
				doneButton.Size = UDim2.new(0,100,0,50)
				doneButton.Position = UDim2.new(0.5,-50,1,-50)

				if skipTutorial then
					doneButton.MouseButton1Click:connect(function() skipTutorial() end)
				end

				doneButton.Parent = frame
			end

			local innerFrame = Instance.new("Frame")
			innerFrame.Name = "ContentFrame"
			innerFrame.BackgroundTransparency = 1
			innerFrame.Position = UDim2.new(0,0,0,25)
			innerFrame.Parent = frame

			local nextButton = Instance.new("TextButton")
			nextButton.Name = "NextButton"
			nextButton.Text = "Next"
			nextButton.TextColor3 = Color3.new(1,1,1)
			nextButton.Font = Enum.Font.Arial
			nextButton.FontSize = Enum.FontSize.Size18
			nextButton.Style = Enum.ButtonStyle.RobloxButtonDefault
			nextButton.Size = UDim2.new(0,80, 0, 32)
			nextButton.Position = UDim2.new(0.5, 5, 1, -32)
			nextButton.Active = false
			nextButton.Visible = false
			nextButton.Parent = frame

			local prevButton = Instance.new("TextButton")
			prevButton.Name = "PrevButton"
			prevButton.Text = "Previous"
			prevButton.TextColor3 = Color3.new(1,1,1)
			prevButton.Font = Enum.Font.Arial
			prevButton.FontSize = Enum.FontSize.Size18
			prevButton.Style = Enum.ButtonStyle.RobloxButton
			prevButton.Size = UDim2.new(0,80, 0, 32)
			prevButton.Position = UDim2.new(0.5, -85, 1, -32)
			prevButton.Active = false
			prevButton.Visible = false
			prevButton.Parent = frame

			if giveDoneButton then
				innerFrame.Size = UDim2.new(1,0,1,-75)
			else
				innerFrame.Size = UDim2.new(1,0,1,-22)
			end

			local parentConnection = nil

			local function basicHandleResize()
				if frame.Visible and frame.Parent then
					local maxSize = math.min(frame.Parent.AbsoluteSize.X, frame.Parent.AbsoluteSize.Y)
					handleResize(200,maxSize)
				end
			end

			frame.Changed:connect(
				function(prop)
					if prop == "Parent" then
						if parentConnection ~= nil then
							parentConnection:disconnect()
							parentConnection = nil
						end
						if frame.Parent and frame.Parent:IsA("GuiObject") then
							parentConnection = frame.Parent.Changed:connect(
								function(parentProp)
									if parentProp == "AbsoluteSize" then
										wait()
										basicHandleResize()
									end
								end)
							basicHandleResize()
						end
					end

					if prop == "Visible" then 
						basicHandleResize()
					end
				end)

			return frame, innerFrame
		end

		t.CreateTextTutorialPage = function(name, text, skipTutorialFunc)
			local frame = nil
			local contentFrame = nil

			local textLabel = Instance.new("TextLabel")
			textLabel.BackgroundTransparency = 1
			textLabel.TextColor3 = Color3.new(1,1,1)
			textLabel.Text = text
			textLabel.TextWrap = true
			textLabel.TextXAlignment = Enum.TextXAlignment.Left
			textLabel.TextYAlignment = Enum.TextYAlignment.Center
			textLabel.Font = Enum.Font.Arial
			textLabel.FontSize = Enum.FontSize.Size14
			textLabel.Size = UDim2.new(1,0,1,0)

			local function handleResize(minSize, maxSize)
				size = binaryShrink(minSize, maxSize,
					function(size)
						frame.Size = UDim2.new(0, size, 0, size)
						return textLabel.TextFits
					end)
				frame.Size = UDim2.new(0, size, 0, size)
				frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
			end

			frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc)
			textLabel.Parent = contentFrame

			return frame
		end

		t.CreateImageTutorialPage = function(name, imageAsset, x, y, skipTutorialFunc, giveDoneButton)
			local frame = nil
			local contentFrame = nil

			local imageLabel = Instance.new("ImageLabel")
			imageLabel.BackgroundTransparency = 1
			imageLabel.Image = imageAsset
			imageLabel.Size = UDim2.new(0,x,0,y)
			imageLabel.Position = UDim2.new(0.5,-x/2,0.5,-y/2)

			local function handleResize(minSize, maxSize)
				size = binaryShrink(minSize, maxSize,
					function(size)
						return size >= x and size >= y
					end)
				if size >= x and size >= y then
					imageLabel.Size = UDim2.new(0,x, 0,y)
					imageLabel.Position = UDim2.new(0.5,-x/2, 0.5, -y/2)
				else
					if x > y then
						--X is limiter, so 
						imageLabel.Size = UDim2.new(1,0,y/x,0)
						imageLabel.Position = UDim2.new(0,0, 0.5 - (y/x)/2, 0)
					else
						--Y is limiter
						imageLabel.Size = UDim2.new(x/y,0,1, 0)
						imageLabel.Position = UDim2.new(0.5-(x/y)/2, 0, 0, 0)
					end
				end
				size = size + 50
				frame.Size = UDim2.new(0, size, 0, size)
				frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
			end

			frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc, giveDoneButton)
			imageLabel.Parent = contentFrame

			return frame
		end

		t.AddTutorialPage = function(tutorial, tutorialPage)
			local transitionFrame = tutorial.TransitionFrame
			local currentPageValue = tutorial.CurrentTutorialPage

			if not tutorial.Buttons.Value then
				tutorialPage.NextButton.Parent = nil
				tutorialPage.PrevButton.Parent = nil
			end

			local children = tutorial.Pages:GetChildren()
			if children and #children > 0 then
				tutorialPage.Name = "TutorialPage" .. (#children+1)
				local previousPage = children[#children]
				if not previousPage:IsA("GuiObject") then
					error("All elements under Pages must be GuiObjects")
				end

				if tutorial.Buttons.Value then
					if previousPage.NextButton.Active then
						error("NextButton already Active on previousPage, please only add pages with RbxGui.AddTutorialPage function")
					end
					previousPage.NextButton.MouseButton1Click:connect(
						function()
							TransitionTutorialPages(previousPage, tutorialPage, transitionFrame, currentPageValue)
						end)
					previousPage.NextButton.Active = true
					previousPage.NextButton.Visible = true

					if tutorialPage.PrevButton.Active then
						error("PrevButton already Active on tutorialPage, please only add pages with RbxGui.AddTutorialPage function")
					end
					tutorialPage.PrevButton.MouseButton1Click:connect(
						function()
							TransitionTutorialPages(tutorialPage, previousPage, transitionFrame, currentPageValue)
						end)
					tutorialPage.PrevButton.Active = true
					tutorialPage.PrevButton.Visible = true
				end

				tutorialPage.Parent = tutorial.Pages
			else
				--First child
				tutorialPage.Name = "TutorialPage1"
				tutorialPage.Parent = tutorial.Pages
			end
		end 

		t.CreateSetPanel = function(userIdsForSets, objectSelected, dialogClosed, size, position, showAdminCategories, useAssetVersionId)

			if not userIdsForSets then
				error("CreateSetPanel: userIdsForSets (first arg) is nil, should be a table of number ids")
			end
			if type(userIdsForSets) ~= "table" and type(userIdsForSets) ~= "userdata" then
				error("CreateSetPanel: userIdsForSets (first arg) is of type " ..type(userIdsForSets) .. ", should be of type table or userdata")
			end
			if not objectSelected then
				error("CreateSetPanel: objectSelected (second arg) is nil, should be a callback function!")
			end
			if type(objectSelected) ~= "function" then
				error("CreateSetPanel: objectSelected (second arg) is of type " .. type(objectSelected) .. ", should be of type function!")
			end
			if dialogClosed and type(dialogClosed) ~= "function" then
				error("CreateSetPanel: dialogClosed (third arg) is of type " .. type(dialogClosed) .. ", should be of type function!")
			end

			if showAdminCategories == nil then -- by default, don't show beta sets
				showAdminCategories = false
			end

			local arrayPosition = 1
			local insertButtons = {}
			local insertButtonCons = {}
			local contents = nil
			local setGui = nil

			-- used for water selections
			local waterForceDirection = "NegX"
			local waterForce = "None"
			local waterGui, waterTypeChangedEvent = nil

			local Data = {}
			Data.CurrentCategory = nil
			Data.Category = {}
			local SetCache = {}

			local userCategoryButtons = nil

			local buttonWidth = 64
			local buttonHeight = buttonWidth

			local SmallThumbnailUrl = nil
			local LargeThumbnailUrl = nil
			local BaseUrl = game:GetService("ContentProvider").BaseUrl:lower()
			local AssetGameUrl = string.gsub(BaseUrl, "www", "assetgame")

			if useAssetVersionId then
				LargeThumbnailUrl = AssetGameUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&wd=420&ht=420&assetversionid="
				SmallThumbnailUrl = AssetGameUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&wd=75&ht=75&assetversionid="
			else
				LargeThumbnailUrl = AssetGameUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&wd=420&ht=420&aid="
				SmallThumbnailUrl = AssetGameUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&wd=75&ht=75&aid="
			end

			local function drillDownSetZIndex(parent, index)
				local children = parent:GetChildren()
				for i = 1, #children do
					if children[i]:IsA("GuiObject") then
						children[i].ZIndex = index
					end
					drillDownSetZIndex(children[i], index)
				end
			end

			-- for terrain stamping
			local currTerrainDropDownFrame = nil
			local terrainShapes = {"Block","Vertical Ramp","Corner Wedge","Inverse Corner Wedge","Horizontal Ramp","Auto-Wedge"}
			local terrainShapeMap = {}
			for i = 1, #terrainShapes do
				terrainShapeMap[terrainShapes[i]] = i - 1
			end	
			terrainShapeMap[terrainShapes[#terrainShapes]] = 6

			local function createWaterGui()
				local waterForceDirections = {"NegX","X","NegY","Y","NegZ","Z"}
				local waterForces = {"None", "Small", "Medium", "Strong", "Max"}

				local waterFrame = Instance.new("Frame")
				waterFrame.Name = "WaterFrame"
				waterFrame.Style = Enum.FrameStyle.RobloxSquare
				waterFrame.Size = UDim2.new(0,150,0,110)
				waterFrame.Visible = false

				local waterForceLabel = Instance.new("TextLabel")
				waterForceLabel.Name = "WaterForceLabel"
				waterForceLabel.BackgroundTransparency = 1
				waterForceLabel.Size = UDim2.new(1,0,0,12)
				waterForceLabel.Font = Enum.Font.ArialBold
				waterForceLabel.FontSize = Enum.FontSize.Size12
				waterForceLabel.TextColor3 = Color3.new(1,1,1)
				waterForceLabel.TextXAlignment = Enum.TextXAlignment.Left
				waterForceLabel.Text = "Water Force"
				waterForceLabel.Parent = waterFrame

				local waterForceDirLabel = waterForceLabel:Clone()
				waterForceDirLabel.Name = "WaterForceDirectionLabel"
				waterForceDirLabel.Text = "Water Force Direction"
				waterForceDirLabel.Position = UDim2.new(0,0,0,50)
				waterForceDirLabel.Parent = waterFrame

				local waterTypeChangedEvent = Instance.new("BindableEvent",waterFrame)
				waterTypeChangedEvent.Name = "WaterTypeChangedEvent"

				local waterForceDirectionSelectedFunc = function(newForceDirection)
					waterForceDirection = newForceDirection
					waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
				end
				local waterForceSelectedFunc = function(newForce)
					waterForce = newForce
					waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
				end

				local waterForceDirectionDropDown, forceWaterDirectionSelection = t.CreateDropDownMenu(waterForceDirections, waterForceDirectionSelectedFunc)
				waterForceDirectionDropDown.Size = UDim2.new(1,0,0,25)
				waterForceDirectionDropDown.Position = UDim2.new(0,0,1,3)
				forceWaterDirectionSelection("NegX")
				waterForceDirectionDropDown.Parent = waterForceDirLabel

				local waterForceDropDown, forceWaterForceSelection = t.CreateDropDownMenu(waterForces, waterForceSelectedFunc)
				forceWaterForceSelection("None")
				waterForceDropDown.Size = UDim2.new(1,0,0,25)
				waterForceDropDown.Position = UDim2.new(0,0,1,3)
				waterForceDropDown.Parent = waterForceLabel

				return waterFrame, waterTypeChangedEvent
			end

			-- Helper Function that contructs gui elements
			local function createSetGui()

				local setGui = Instance.new("ScreenGui")
				setGui.Name = "SetGui"

				local setPanel = Instance.new("Frame")
				setPanel.Name = "SetPanel"
				setPanel.Active = true
				setPanel.BackgroundTransparency = 1
				if position then
					setPanel.Position = position
				else
					setPanel.Position = UDim2.new(0.2, 29, 0.1, 24)
				end
				if size then
					setPanel.Size = size
				else
					setPanel.Size = UDim2.new(0.6, -58, 0.64, 0)
				end
				setPanel.Style = Enum.FrameStyle.RobloxRound
				setPanel.ZIndex = 6
				setPanel.Parent = setGui

				-- Children of SetPanel
				local itemPreview = Instance.new("Frame")
				itemPreview.Name = "ItemPreview"
				itemPreview.BackgroundTransparency = 1
				itemPreview.Position = UDim2.new(0.8,5,0.085,0)
				itemPreview.Size = UDim2.new(0.21,0,0.9,0)
				itemPreview.ZIndex = 6
				itemPreview.Parent = setPanel

				-- Children of ItemPreview
				local textPanel = Instance.new("Frame")
				textPanel.Name = "TextPanel"
				textPanel.BackgroundTransparency = 1
				textPanel.Position = UDim2.new(0,0,0.45,0)
				textPanel.Size = UDim2.new(1,0,0.55,0)
				textPanel.ZIndex = 6
				textPanel.Parent = itemPreview

				-- Children of TextPanel
				local rolloverText = Instance.new("TextLabel")
				rolloverText.Name = "RolloverText"
				rolloverText.BackgroundTransparency = 1
				rolloverText.Size = UDim2.new(1,0,0,48)
				rolloverText.ZIndex = 6
				rolloverText.Font = Enum.Font.ArialBold
				rolloverText.FontSize = Enum.FontSize.Size24
				rolloverText.Text = ""
				rolloverText.TextColor3 = Color3.new(1,1,1)
				rolloverText.TextWrap = true
				rolloverText.TextXAlignment = Enum.TextXAlignment.Left
				rolloverText.TextYAlignment = Enum.TextYAlignment.Top
				rolloverText.Parent = textPanel

				local largePreview = Instance.new("ImageLabel")
				largePreview.Name = "LargePreview"
				largePreview.BackgroundTransparency = 1
				largePreview.Image = ""
				largePreview.Size = UDim2.new(1,0,0,170)
				largePreview.ZIndex = 6
				largePreview.Parent = itemPreview

				local sets = Instance.new("Frame")
				sets.Name = "Sets"
				sets.BackgroundTransparency = 1
				sets.Position = UDim2.new(0,0,0,5)
				sets.Size = UDim2.new(0.23,0,1,-5)
				sets.ZIndex = 6
				sets.Parent = setPanel

				-- Children of Sets
				local line = Instance.new("Frame")
				line.Name = "Line"
				line.BackgroundColor3 = Color3.new(1,1,1)
				line.BackgroundTransparency = 0.7
				line.BorderSizePixel = 0
				line.Position = UDim2.new(1,-3,0.06,0)
				line.Size = UDim2.new(0,3,0.9,0)
				line.ZIndex = 6
				line.Parent = sets

				local setsLists, controlFrame = t.CreateTrueScrollingFrame()
				setsLists.Size = UDim2.new(1,-6,0.94,0)
				setsLists.Position = UDim2.new(0,0,0.06,0)
				setsLists.BackgroundTransparency = 1
				setsLists.Name = "SetsLists"
				setsLists.ZIndex = 6
				setsLists.Parent = sets
				drillDownSetZIndex(controlFrame, 7)

				local setsHeader = Instance.new("TextLabel")
				setsHeader.Name = "SetsHeader"
				setsHeader.BackgroundTransparency = 1
				setsHeader.Size = UDim2.new(0,47,0,24)
				setsHeader.ZIndex = 6
				setsHeader.Font = Enum.Font.ArialBold
				setsHeader.FontSize = Enum.FontSize.Size24
				setsHeader.Text = "Sets"
				setsHeader.TextColor3 = Color3.new(1,1,1)
				setsHeader.TextXAlignment = Enum.TextXAlignment.Left
				setsHeader.TextYAlignment = Enum.TextYAlignment.Top
				setsHeader.Parent = sets

				local cancelButton = Instance.new("TextButton")
				cancelButton.Name = "CancelButton"
				cancelButton.Position = UDim2.new(1,-32,0,-2)
				cancelButton.Size = UDim2.new(0,34,0,34)
				cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault
				cancelButton.ZIndex = 6
				cancelButton.Text = ""
				cancelButton.Modal = true
				cancelButton.Parent = setPanel

				-- Children of Cancel Button
				local cancelImage = Instance.new("ImageLabel")
				cancelImage.Name = "CancelImage"
				cancelImage.BackgroundTransparency = 1
				cancelImage.Image = "https://www.roblox.com/asset/?id=54135717"
				cancelImage.Position = UDim2.new(0,-2,0,-2)
				cancelImage.Size = UDim2.new(0,16,0,16)
				cancelImage.ZIndex = 6
				cancelImage.Parent = cancelButton

				return setGui
			end

			local function createSetButton(text)
				local setButton = Instance.new("TextButton")

				if text then setButton.Text = text
				else setButton.Text = "" end

				setButton.AutoButtonColor = false
				setButton.BackgroundTransparency = 1
				setButton.BackgroundColor3 = Color3.new(1,1,1)
				setButton.BorderSizePixel = 0
				setButton.Size = UDim2.new(1,-5,0,18)
				setButton.ZIndex = 6
				setButton.Visible = false
				setButton.Font = Enum.Font.Arial
				setButton.FontSize = Enum.FontSize.Size18
				setButton.TextColor3 = Color3.new(1,1,1)
				setButton.TextXAlignment = Enum.TextXAlignment.Left

				return setButton
			end

			local function buildSetButton(name, setId, setImageId, i,  count)
				local button = createSetButton(name)
				button.Text = name
				button.Name = "SetButton"
				button.Visible = true

				local setValue = Instance.new("IntValue")
				setValue.Name = "SetId"
				setValue.Value = setId
				setValue.Parent = button

				local setName = Instance.new("StringValue")
				setName.Name = "SetName"
				setName.Value = name
				setName.Parent = button

				return button
			end

			local function processCategory(sets)
				local setButtons = {}
				local numSkipped = 0
				for i = 1, #sets do
					if not showAdminCategories and sets[i].Name == "Beta" then
						numSkipped = numSkipped + 1
					else
						setButtons[i - numSkipped] = buildSetButton(sets[i].Name, sets[i].CategoryId, sets[i].ImageAssetId, i - numSkipped, #sets)
					end
				end
				return setButtons
			end

			local function handleResize()
				wait() -- neccessary to insure heartbeat happened

				local itemPreview = setGui.SetPanel.ItemPreview

				itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
				itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
				itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
				itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
			end

			local function makeInsertAssetButton()
				local insertAssetButtonExample = Instance.new("Frame")
				insertAssetButtonExample.Name = "InsertAssetButtonExample"
				insertAssetButtonExample.Position = UDim2.new(0,128,0,64)
				insertAssetButtonExample.Size = UDim2.new(0,64,0,64)
				insertAssetButtonExample.BackgroundTransparency = 1
				insertAssetButtonExample.ZIndex = 6
				insertAssetButtonExample.Visible = false

				local assetId = Instance.new("IntValue")
				assetId.Name = "AssetId"
				assetId.Value = 0
				assetId.Parent = insertAssetButtonExample

				local assetName = Instance.new("StringValue")
				assetName.Name = "AssetName"
				assetName.Value = ""
				assetName.Parent = insertAssetButtonExample

				local button = Instance.new("TextButton")
				button.Name = "Button"
				button.Text = ""
				button.Style = Enum.ButtonStyle.RobloxButton
				button.Position = UDim2.new(0.025,0,0.025,0)
				button.Size = UDim2.new(0.95,0,0.95,0)
				button.ZIndex = 6
				button.Parent = insertAssetButtonExample

				local buttonImage = Instance.new("ImageLabel")
				buttonImage.Name = "ButtonImage"
				buttonImage.Image = ""
				buttonImage.Position = UDim2.new(0,-7,0,-7)
				buttonImage.Size = UDim2.new(1,14,1,14)
				buttonImage.BackgroundTransparency = 1
				buttonImage.ZIndex = 7
				buttonImage.Parent = button

				local configIcon = buttonImage:clone()
				configIcon.Name = "ConfigIcon"
				configIcon.Visible = false
				configIcon.Position = UDim2.new(1,-23,1,-24)
				configIcon.Size = UDim2.new(0,16,0,16)
				configIcon.Image = ""
				configIcon.ZIndex = 6
				configIcon.Parent = insertAssetButtonExample

				return insertAssetButtonExample
			end

			local function showLargePreview(insertButton)
				if insertButton:FindFirstChild("AssetId") then
					delay(0,function()
						game:GetService("ContentProvider"):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
						setGui.SetPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
					end)
				end
				if insertButton:FindFirstChild("AssetName") then
					setGui.SetPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
				end
			end

			local function selectTerrainShape(shape)
				if currTerrainDropDownFrame then
					objectSelected(tostring(currTerrainDropDownFrame.AssetName.Value), tonumber(currTerrainDropDownFrame.AssetId.Value), shape)
				end
			end

			local function createTerrainTypeButton(name, parent)
				local dropDownTextButton = Instance.new("TextButton")
				dropDownTextButton.Name = name .. "Button"
				dropDownTextButton.Font = Enum.Font.ArialBold
				dropDownTextButton.FontSize = Enum.FontSize.Size14
				dropDownTextButton.BorderSizePixel = 0
				dropDownTextButton.TextColor3 = Color3.new(1,1,1)
				dropDownTextButton.Text = name
				dropDownTextButton.TextXAlignment = Enum.TextXAlignment.Left
				dropDownTextButton.BackgroundTransparency = 1
				dropDownTextButton.ZIndex = parent.ZIndex + 1
				dropDownTextButton.Size = UDim2.new(0,parent.Size.X.Offset - 2,0,16)
				dropDownTextButton.Position = UDim2.new(0,1,0,0)

				dropDownTextButton.MouseEnter:connect(function()
					dropDownTextButton.BackgroundTransparency = 0
					dropDownTextButton.TextColor3 = Color3.new(0,0,0)
				end)

				dropDownTextButton.MouseLeave:connect(function()
					dropDownTextButton.BackgroundTransparency = 1
					dropDownTextButton.TextColor3 = Color3.new(1,1,1)
				end)

				dropDownTextButton.MouseButton1Click:connect(function()
					dropDownTextButton.BackgroundTransparency = 1
					dropDownTextButton.TextColor3 = Color3.new(1,1,1)
					if dropDownTextButton.Parent and dropDownTextButton.Parent:IsA("GuiObject") then
						dropDownTextButton.Parent.Visible = false
					end
					selectTerrainShape(terrainShapeMap[dropDownTextButton.Text])
				end)

				return dropDownTextButton
			end

			local function createTerrainDropDownMenu(zIndex)
				local dropDown = Instance.new("Frame")
				dropDown.Name = "TerrainDropDown"
				dropDown.BackgroundColor3 = Color3.new(0,0,0)
				dropDown.BorderColor3 = Color3.new(1,0,0)
				dropDown.Size = UDim2.new(0,200,0,0)
				dropDown.Visible = false
				dropDown.ZIndex = zIndex
				dropDown.Parent = setGui

				for i = 1, #terrainShapes do
					local shapeButton = createTerrainTypeButton(terrainShapes[i],dropDown)
					shapeButton.Position = UDim2.new(0,1,0,(i - 1) * (shapeButton.Size.Y.Offset))
					shapeButton.Parent = dropDown
					dropDown.Size = UDim2.new(0,200,0,dropDown.Size.Y.Offset + (shapeButton.Size.Y.Offset))
				end

				dropDown.MouseLeave:connect(function()
					dropDown.Visible = false
				end)
			end


			local function createDropDownMenuButton(parent)
				local dropDownButton = Instance.new("ImageButton")
				dropDownButton.Name = "DropDownButton"
				dropDownButton.Image = "https://www.roblox.com/asset/?id=67581509"
				dropDownButton.BackgroundTransparency = 1
				dropDownButton.Size = UDim2.new(0,16,0,16)
				dropDownButton.Position = UDim2.new(1,-24,0,6)
				dropDownButton.ZIndex = parent.ZIndex + 2
				dropDownButton.Parent = parent

				if not setGui:FindFirstChild("TerrainDropDown") then
					createTerrainDropDownMenu(8)
				end

				dropDownButton.MouseButton1Click:connect(function()
					setGui.TerrainDropDown.Visible = true
					setGui.TerrainDropDown.Position = UDim2.new(0,parent.AbsolutePosition.X,0,parent.AbsolutePosition.Y)
					currTerrainDropDownFrame = parent
				end)
			end

			local function buildInsertButton()
				local insertButton = makeInsertAssetButton()
				insertButton.Name = "InsertAssetButton"
				insertButton.Visible = true

				if Data.Category[Data.CurrentCategory].SetName == "High Scalability" then
					createDropDownMenuButton(insertButton)
				end

				local lastEnter = nil
				local mouseEnterCon = insertButton.MouseEnter:connect(function()
					lastEnter = insertButton
					delay(0.1,function()
						if lastEnter == insertButton then
							showLargePreview(insertButton)
						end
					end)
				end)
				return insertButton, mouseEnterCon
			end

			local function realignButtonGrid(columns)
				local x = 0
				local y = 0 
				for i = 1, #insertButtons do
					insertButtons[i].Position = UDim2.new(0, buttonWidth * x, 0, buttonHeight * y)
					x = x + 1
					if x >= columns then
						x = 0
						y = y + 1
					end
				end
			end

			local function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
				if visible then
					insertFrame.AssetName.Value = name
					insertFrame.AssetId.Value = assetId
					local newImageUrl = SmallThumbnailUrl  .. assetId
					if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
						delay(0,function()
							game:GetService("ContentProvider"):Preload(SmallThumbnailUrl  .. assetId)
							if insertFrame:findFirstChild("Button") then
								insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
							end
						end)
					end
					table.insert(insertButtonCons,
						insertFrame.Button.MouseButton1Click:connect(function()
							-- special case for water, show water selection gui
							local isWaterSelected = (name == "Water") and (Data.Category[Data.CurrentCategory].SetName == "High Scalability")
							waterGui.Visible = isWaterSelected
							if isWaterSelected then
								objectSelected(name, tonumber(assetId), nil)
							else
								objectSelected(name, tonumber(assetId))
							end
						end)
					)
					insertFrame.Visible = true
				else
					insertFrame.Visible = false
				end
			end

			local function loadSectionOfItems(setGui, rows, columns)
				local pageSize = rows * columns

				if arrayPosition > #contents then return end

				local origArrayPos = arrayPosition

				local yCopy = 0
				for i = 1, pageSize + 1 do 
					if arrayPosition >= #contents + 1 then
						break
					end

					local buttonCon
					insertButtons[arrayPosition], buttonCon = buildInsertButton()
					table.insert(insertButtonCons,buttonCon)
					insertButtons[arrayPosition].Parent = setGui.SetPanel.ItemsFrame
					arrayPosition = arrayPosition + 1
				end
				realignButtonGrid(columns)

				local indexCopy = origArrayPos
				for index = origArrayPos, arrayPosition do
					if insertButtons[index] then
						if contents[index] then

							-- we don't want water to have a drop down button
							if contents[index].Name == "Water" then
								if Data.Category[Data.CurrentCategory].SetName == "High Scalability" then
									insertButtons[index]:FindFirstChild("DropDownButton",true):Destroy()
								end
							end

							local assetId
							if useAssetVersionId then
								assetId = contents[index].AssetVersionId
							else
								assetId = contents[index].AssetId
							end
							setInsertButtonImageBehavior(insertButtons[index], true, contents[index].Name, assetId)
						else
							break
						end
					else
						break
					end
					indexCopy = index
				end
			end

			local function setSetIndex()
				Data.Category[Data.CurrentCategory].Index = 0

				rows = 7
				columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

				contents = Data.Category[Data.CurrentCategory].Contents
				if contents then
					-- remove our buttons and their connections
					for i = 1, #insertButtons do
						insertButtons[i]:remove()
					end
					for i = 1, #insertButtonCons do
						if insertButtonCons[i] then insertButtonCons[i]:disconnect() end
					end
					insertButtonCons = {}
					insertButtons = {}

					arrayPosition = 1
					loadSectionOfItems(setGui, rows, columns)
				end
			end

			local function selectSet(button, setName, setId, setIndex)
				if button and Data.Category[Data.CurrentCategory] ~= nil then
					if button ~= Data.Category[Data.CurrentCategory].Button then
						Data.Category[Data.CurrentCategory].Button = button

						if SetCache[setId] == nil then
							SetCache[setId] = game:GetService("InsertService"):GetCollection(setId)
						end
						Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

						Data.Category[Data.CurrentCategory].SetName = setName
						Data.Category[Data.CurrentCategory].SetId = setId
					end
					setSetIndex()
				end
			end

			local function selectCategoryPage(buttons, page)
				if buttons ~= Data.CurrentCategory then
					if Data.CurrentCategory then
						for key, button in pairs(Data.CurrentCategory) do
							button.Visible = false
						end
					end

					Data.CurrentCategory = buttons
					if Data.Category[Data.CurrentCategory] == nil then
						Data.Category[Data.CurrentCategory] = {}
						if #buttons > 0 then
							selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
						end
					else
						Data.Category[Data.CurrentCategory].Button = nil
						selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
					end
				end
			end

			local function selectCategory(category)
				selectCategoryPage(category, 0)
			end

			local function resetAllSetButtonSelection()
				local setButtons = setGui.SetPanel.Sets.SetsLists:GetChildren()
				for i = 1, #setButtons do
					if setButtons[i]:IsA("TextButton") then
						setButtons[i].Selected = false
						setButtons[i].BackgroundTransparency = 1
						setButtons[i].TextColor3 = Color3.new(1,1,1)
						setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
					end
				end
			end

			local function populateSetsFrame()
				local currRow = 0
				for i = 1, #userCategoryButtons do
					local button = userCategoryButtons[i]
					button.Visible = true
					button.Position = UDim2.new(0,5,0,currRow * button.Size.Y.Offset)
					button.Parent = setGui.SetPanel.Sets.SetsLists

					if i == 1 then -- we will have this selected by default, so show it
						button.Selected = true
						button.BackgroundColor3 = Color3.new(0,204/255,0)
						button.TextColor3 = Color3.new(0,0,0)
						button.BackgroundTransparency = 0
					end

					button.MouseEnter:connect(function()
						if not button.Selected then
							button.BackgroundTransparency = 0
							button.TextColor3 = Color3.new(0,0,0)
						end
					end)
					button.MouseLeave:connect(function()
						if not button.Selected then
							button.BackgroundTransparency = 1
							button.TextColor3 = Color3.new(1,1,1)
						end
					end)
					button.MouseButton1Click:connect(function()
						resetAllSetButtonSelection()
						button.Selected = not button.Selected
						button.BackgroundColor3 = Color3.new(0,204/255,0)
						button.TextColor3 = Color3.new(0,0,0)
						button.BackgroundTransparency = 0
						selectSet(button, button.Text, userCategoryButtons[i].SetId.Value, 0)
					end)

					currRow = currRow + 1
				end

				local buttons =  setGui.SetPanel.Sets.SetsLists:GetChildren()

				-- set first category as loaded for default
				if buttons then
					for i = 1, #buttons do
						if buttons[i]:IsA("TextButton") then
							selectSet(buttons[i], buttons[i].Text, userCategoryButtons[i].SetId.Value, 0)
							selectCategory(userCategoryButtons)
							break
						end
					end
				end
			end

			setGui = createSetGui()
			waterGui, waterTypeChangedEvent = createWaterGui()
			waterGui.Position = UDim2.new(0,55,0,0)
			waterGui.Parent = setGui
			setGui.Changed:connect(function(prop) -- this resizes the preview image to always be the right size
				if prop == "AbsoluteSize" then
					handleResize()
					setSetIndex()
				end
			end)

			local scrollFrame, controlFrame = t.CreateTrueScrollingFrame()
			scrollFrame.Size = UDim2.new(0.54,0,0.85,0)
			scrollFrame.Position = UDim2.new(0.24,0,0.085,0)
			scrollFrame.Name = "ItemsFrame"
			scrollFrame.ZIndex = 6
			scrollFrame.Parent = setGui.SetPanel
			scrollFrame.BackgroundTransparency = 1

			drillDownSetZIndex(controlFrame,7)

			controlFrame.Parent = setGui.SetPanel
			controlFrame.Position = UDim2.new(0.76, 5, 0, 0)

			local debounce = false
			controlFrame.ScrollBottom.Changed:connect(function(prop)
				if controlFrame.ScrollBottom.Value == true then
					if debounce then return end
					debounce = true
					loadSectionOfItems(setGui, rows, columns)
					debounce = false
				end
			end)

			local userData = {}
			for id = 1, #userIdsForSets do
				local newUserData = game:GetService("InsertService"):GetUserSets(userIdsForSets[id])
				if newUserData and #newUserData > 2 then
					-- start at #3 to skip over My Decals and My Models for each account
					for category = 3, #newUserData do
						if newUserData[category].Name == "High Scalability" then -- we want high scalability parts to show first
							table.insert(userData,1,newUserData[category])
						else
							table.insert(userData, newUserData[category])
						end
					end
				end

			end
			if userData then
				userCategoryButtons = processCategory(userData)
			end

			rows = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
			columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

			populateSetsFrame()

			setGui.SetPanel.CancelButton.MouseButton1Click:connect(function()
				setGui.SetPanel.Visible = false
				if dialogClosed then dialogClosed() end
			end)

			local setVisibilityFunction = function(visible)
				if visible then
					setGui.SetPanel.Visible = true
				else
					setGui.SetPanel.Visible = false
				end
			end

			local getVisibilityFunction = function()
				if setGui then
					if setGui:FindFirstChild("SetPanel") then
						return setGui.SetPanel.Visible
					end
				end

				return false
			end

			return setGui, setVisibilityFunction, getVisibilityFunction, waterTypeChangedEvent
		end

		t.CreateTerrainMaterialSelector = function(size,position)
			local terrainMaterialSelectionChanged = Instance.new("BindableEvent")
			terrainMaterialSelectionChanged.Name = "TerrainMaterialSelectionChanged"

			local selectedButton = nil

			local frame = Instance.new("Frame")
			frame.Name = "TerrainMaterialSelector"
			if size then
				frame.Size = size
			else
				frame.Size = UDim2.new(0, 245, 0, 230)
			end
			if position then
				frame.Position = position
			end
			frame.BorderSizePixel = 0
			frame.BackgroundColor3 = Color3.new(0,0,0)
			frame.Active = true

			terrainMaterialSelectionChanged.Parent = frame

			local waterEnabled = true -- todo: turn this on when water is ready

			local materialToImageMap = {}
			local materialNames = {"Grass", "Sand", "Brick", "Granite", "Asphalt", "Iron", "Aluminum", "Gold", "Plank", "Log", "Gravel", "Cinder Block", "Stone Wall", "Concrete", "Plastic (red)", "Plastic (blue)"}
			if waterEnabled then
				table.insert(materialNames,"Water")
			end
			local currentMaterial = 1

			function getEnumFromName(choice)
				if choice == "Grass" then return 1 end
				if choice == "Sand" then return 2 end 
				if choice == "Erase" then return 0 end
				if choice == "Brick" then return 3 end
				if choice == "Granite" then return 4 end
				if choice == "Asphalt" then return 5 end
				if choice == "Iron" then return 6 end
				if choice == "Aluminum" then return 7 end
				if choice == "Gold" then return 8 end
				if choice == "Plank" then return 9 end
				if choice == "Log" then return 10 end
				if choice == "Gravel" then return 11 end
				if choice == "Cinder Block" then return 12 end
				if choice == "Stone Wall" then return 13 end
				if choice == "Concrete" then return 14 end
				if choice == "Plastic (red)" then return 15 end
				if choice == "Plastic (blue)" then return 16 end
				if choice == "Water" then return 17 end
			end

			function getNameFromEnum(choice)
				if choice == Enum.CellMaterial.Grass or choice == 1 then return "Grass"end
				if choice == Enum.CellMaterial.Sand or choice == 2 then return "Sand" end 
				if choice == Enum.CellMaterial.Empty or choice == 0 then return "Erase" end
				if choice == Enum.CellMaterial.Brick or choice == 3 then return "Brick" end
				if choice == Enum.CellMaterial.Granite or choice == 4 then return "Granite" end
				if choice == Enum.CellMaterial.Asphalt or choice == 5 then return "Asphalt" end
				if choice == Enum.CellMaterial.Iron or choice == 6 then return "Iron" end
				if choice == Enum.CellMaterial.Aluminum or choice == 7 then return "Aluminum" end
				if choice == Enum.CellMaterial.Gold or choice == 8 then return "Gold" end
				if choice == Enum.CellMaterial.WoodPlank or choice == 9 then return "Plank" end
				if choice == Enum.CellMaterial.WoodLog or choice == 10 then return "Log" end
				if choice == Enum.CellMaterial.Gravel or choice == 11 then return "Gravel" end
				if choice == Enum.CellMaterial.CinderBlock or choice == 12 then return "Cinder Block" end
				if choice == Enum.CellMaterial.MossyStone or choice == 13 then return "Stone Wall" end
				if choice == Enum.CellMaterial.Cement or choice == 14 then return "Concrete" end
				if choice == Enum.CellMaterial.RedPlastic or choice == 15 then return "Plastic (red)" end
				if choice == Enum.CellMaterial.BluePlastic or choice == 16 then return "Plastic (blue)" end

				if waterEnabled then
					if choice == Enum.CellMaterial.Water or choice == 17 then return "Water" end
				end
			end


			local function updateMaterialChoice(choice)
				currentMaterial = getEnumFromName(choice)
				terrainMaterialSelectionChanged:Fire(currentMaterial)
			end

			-- we so need a better way to do this
			for i,v in pairs(materialNames) do
				materialToImageMap[v] = {}
				if v == "Grass" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=56563112"
				elseif v == "Sand" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=62356652"
				elseif v == "Brick" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=65961537"
				elseif v == "Granite" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532153"
				elseif v == "Asphalt" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532038"
				elseif v == "Iron" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532093"
				elseif v == "Aluminum" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67531995"
				elseif v == "Gold" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532118"
				elseif v == "Plastic (red)" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67531848"
				elseif v == "Plastic (blue)" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67531924"
				elseif v == "Plank" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532015"
				elseif v == "Log" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532051"
				elseif v == "Gravel" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532206"
				elseif v == "Cinder Block" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532103"
				elseif v == "Stone Wall" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67531804"
				elseif v == "Concrete" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532059"
				elseif v == "Water" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=81407474"
				else materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=66887593" -- fill in the rest here!!
				end
			end

			local scrollFrame, scrollUp, scrollDown, recalculateScroll = t.CreateScrollingFrame(nil,"grid")
			scrollFrame.Size = UDim2.new(0.85,0,1,0)
			scrollFrame.Position = UDim2.new(0,0,0,0)
			scrollFrame.Parent = frame

			scrollUp.Parent = frame
			scrollUp.Visible = true
			scrollUp.Position = UDim2.new(1,-19,0,0)

			scrollDown.Parent = frame
			scrollDown.Visible = true
			scrollDown.Position = UDim2.new(1,-19,1,-17)

			local function goToNewMaterial(buttonWrap, materialName)
				updateMaterialChoice(materialName)
				buttonWrap.BackgroundTransparency = 0
				selectedButton.BackgroundTransparency = 1
				selectedButton = buttonWrap
			end

			local function createMaterialButton(name)	
				local buttonWrap = Instance.new("TextButton")
				buttonWrap.Text = ""
				buttonWrap.Size = UDim2.new(0,32,0,32)
				buttonWrap.BackgroundColor3 = Color3.new(1,1,1)
				buttonWrap.BorderSizePixel = 0
				buttonWrap.BackgroundTransparency = 1
				buttonWrap.AutoButtonColor = false
				buttonWrap.Name = tostring(name)

				local imageButton = Instance.new("ImageButton")
				imageButton.AutoButtonColor = false
				imageButton.BackgroundTransparency = 1
				imageButton.Size = UDim2.new(0,30,0,30)
				imageButton.Position = UDim2.new(0,1,0,1)
				imageButton.Name = tostring(name)
				imageButton.Parent = buttonWrap
				imageButton.Image = materialToImageMap[name].Regular

				local enumType = Instance.new("NumberValue")
				enumType.Name = "EnumType"
				enumType.Parent = buttonWrap
				enumType.Value = 0

				imageButton.MouseEnter:connect(function()
					buttonWrap.BackgroundTransparency = 0
				end)
				imageButton.MouseLeave:connect(function()
					if selectedButton ~= buttonWrap then
						buttonWrap.BackgroundTransparency = 1
					end
				end)
				imageButton.MouseButton1Click:connect(function()
					if selectedButton ~= buttonWrap then
						goToNewMaterial(buttonWrap, tostring(name))
					end
				end)

				return buttonWrap 
			end

			for i = 1, #materialNames do
				local imageButton = createMaterialButton(materialNames[i])

				if materialNames[i] == "Grass" then -- always start with grass as the default
					selectedButton = imageButton
					imageButton.BackgroundTransparency = 0
				end

				imageButton.Parent = scrollFrame
			end

			local forceTerrainMaterialSelection = function(newMaterialType)
				if not newMaterialType then return end
				if currentMaterial == newMaterialType then return end

				local matName = getNameFromEnum(newMaterialType)
				local buttons = scrollFrame:GetChildren()
				for i = 1, #buttons do
					if buttons[i].Name == "Plastic (blue)" and matName == "Plastic (blue)" then goToNewMaterial(buttons[i],matName) return end
					if buttons[i].Name == "Plastic (red)" and matName == "Plastic (red)" then goToNewMaterial(buttons[i],matName) return end
					if string.find(buttons[i].Name, matName) then
						goToNewMaterial(buttons[i],matName)
						return
					end
				end
			end

			frame.Changed:connect(function ( prop )
				if prop == "AbsoluteSize" then
					recalculateScroll()
				end
			end)

			recalculateScroll()
			return frame, terrainMaterialSelectionChanged, forceTerrainMaterialSelection
		end

		t.CreateLoadingFrame = function(name,size,position)
			game:GetService("ContentProvider"):Preload("https://www.roblox.com/asset/?id=35238053")

			local loadingFrame = Instance.new("Frame")
			loadingFrame.Name = "LoadingFrame"
			loadingFrame.Style = Enum.FrameStyle.RobloxRound

			if size then loadingFrame.Size = size
			else loadingFrame.Size = UDim2.new(0,300,0,160) end
			if position then loadingFrame.Position = position 
			else loadingFrame.Position = UDim2.new(0.5, -150, 0.5,-80) end

			local loadingBar = Instance.new("Frame")
			loadingBar.Name = "LoadingBar"
			loadingBar.BackgroundColor3 = Color3.new(0,0,0)
			loadingBar.BorderColor3 = Color3.new(79/255,79/255,79/255)
			loadingBar.Position = UDim2.new(0,0,0,41)
			loadingBar.Size = UDim2.new(1,0,0,30)
			loadingBar.Parent = loadingFrame

			local loadingGreenBar = Instance.new("ImageLabel")
			loadingGreenBar.Name = "LoadingGreenBar"
			loadingGreenBar.Image = "https://www.roblox.com/asset/?id=35238053"
			loadingGreenBar.Position = UDim2.new(0,0,0,0)
			loadingGreenBar.Size = UDim2.new(0,0,1,0)
			loadingGreenBar.Visible = false
			loadingGreenBar.Parent = loadingBar

			local loadingPercent = Instance.new("TextLabel")
			loadingPercent.Name = "LoadingPercent"
			loadingPercent.BackgroundTransparency = 1
			loadingPercent.Position = UDim2.new(0,0,1,0)
			loadingPercent.Size = UDim2.new(1,0,0,14)
			loadingPercent.Font = Enum.Font.Arial
			loadingPercent.Text = "0%"
			loadingPercent.FontSize = Enum.FontSize.Size14
			loadingPercent.TextColor3 = Color3.new(1,1,1)
			loadingPercent.Parent = loadingBar

			local cancelButton = Instance.new("TextButton")
			cancelButton.Name = "CancelButton"
			cancelButton.Position = UDim2.new(0.5,-60,1,-40)
			cancelButton.Size = UDim2.new(0,120,0,40)
			cancelButton.Font = Enum.Font.Arial
			cancelButton.FontSize = Enum.FontSize.Size18
			cancelButton.TextColor3 = Color3.new(1,1,1)
			cancelButton.Text = "Cancel"
			cancelButton.Style = Enum.ButtonStyle.RobloxButton
			cancelButton.Parent = loadingFrame

			local loadingName = Instance.new("TextLabel")
			loadingName.Name = "loadingName"
			loadingName.BackgroundTransparency = 1
			loadingName.Size = UDim2.new(1,0,0,18)
			loadingName.Position = UDim2.new(0,0,0,2)
			loadingName.Font = Enum.Font.Arial
			loadingName.Text = name
			loadingName.TextColor3 = Color3.new(1,1,1)
			loadingName.TextStrokeTransparency = 1
			loadingName.FontSize = Enum.FontSize.Size18
			loadingName.Parent = loadingFrame

			local cancelButtonClicked = Instance.new("BindableEvent")
			cancelButtonClicked.Name = "CancelButtonClicked"
			cancelButtonClicked.Parent = cancelButton
			cancelButton.MouseButton1Click:connect(function()
				cancelButtonClicked:Fire()
			end)

			local updateLoadingGuiPercent = function(percent, tweenAction, tweenLength)
				if percent and type(percent) ~= "number" then
					error("updateLoadingGuiPercent expects number as argument, got",type(percent),"instead")
				end

				local newSize = nil
				if percent < 0 then
					newSize = UDim2.new(0,0,1,0)
				elseif percent > 1 then
					newSize = UDim2.new(1,0,1,0)
				else
					newSize = UDim2.new(percent,0,1,0)
				end

				if tweenAction then
					if not tweenLength then
						error("updateLoadingGuiPercent is set to tween new percentage, but got no tween time length! Please pass this in as third argument")
					end

					if (newSize.X.Scale > 0) then
						loadingGreenBar.Visible = true
						loadingGreenBar:TweenSize(	newSize,
							Enum.EasingDirection.Out,
							Enum.EasingStyle.Quad,
							tweenLength,
							true)
					else
						loadingGreenBar:TweenSize(	newSize,
							Enum.EasingDirection.Out,
							Enum.EasingStyle.Quad,
							tweenLength,
							true,
							function() 
								if (newSize.X.Scale < 0) then
									loadingGreenBar.Visible = false
								end
							end)
					end

				else
					loadingGreenBar.Size = newSize
					loadingGreenBar.Visible = (newSize.X.Scale > 0)
				end
			end

			loadingGreenBar.Changed:connect(function(prop)
				if prop == "Size" then
					loadingPercent.Text = tostring( math.ceil(loadingGreenBar.Size.X.Scale * 100) ) .. "%"
				end
			end)

			return loadingFrame, updateLoadingGuiPercent, cancelButtonClicked
		end

		t.CreatePluginFrame = function (name,size,position,scrollable,parent)
			local function createMenuButton(size,position,text,fontsize,name,parent)
				local button = Instance.new("TextButton",parent)
				button.AutoButtonColor = false
				button.Name = name
				button.BackgroundTransparency = 1
				button.Position = position
				button.Size = size
				button.Font = Enum.Font.ArialBold
				button.FontSize = fontsize
				button.Text =  text
				button.TextColor3 = Color3.new(1,1,1)
				button.BorderSizePixel = 0
				button.BackgroundColor3 = Color3.new(20/255,20/255,20/255)

				button.MouseEnter:connect(function ( )
					if button.Selected then return end
					button.BackgroundTransparency = 0
				end)
				button.MouseLeave:connect(function ( )
					if button.Selected then return end
					button.BackgroundTransparency = 1
				end)

				return button

			end

			local dragBar = Instance.new("Frame",parent)
			dragBar.Name = tostring(name) .. "DragBar"
			dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
			dragBar.BorderColor3 = Color3.new(0,0,0)
			if size then
				dragBar.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,20)  + UDim2.new(0,20,0,0)
			else
				dragBar.Size = UDim2.new(0,183,0,20)
			end
			if position then
				dragBar.Position = position
			end
			dragBar.Active = true
			dragBar.Draggable = true
			--dragBar.Visible = false
			dragBar.MouseEnter:connect(function (  )
				dragBar.BackgroundColor3 = Color3.new(49/255,49/255,49/255)
			end)
			dragBar.MouseLeave:connect(function (  )
				dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
			end)

			-- plugin name label
			local pluginNameLabel = Instance.new("TextLabel",dragBar)
			pluginNameLabel.Name = "BarNameLabel"
			pluginNameLabel.Text = " " .. tostring(name)
			pluginNameLabel.TextColor3 = Color3.new(1,1,1)
			pluginNameLabel.TextStrokeTransparency = 0
			pluginNameLabel.Size = UDim2.new(1,0,1,0)
			pluginNameLabel.Font = Enum.Font.ArialBold
			pluginNameLabel.FontSize = Enum.FontSize.Size18
			pluginNameLabel.TextXAlignment = Enum.TextXAlignment.Left
			pluginNameLabel.BackgroundTransparency = 1

			-- close button
			local closeButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-16,0.5,-8),"X",Enum.FontSize.Size14,"CloseButton",dragBar)
			local closeEvent = Instance.new("BindableEvent")
			closeEvent.Name = "CloseEvent"
			closeEvent.Parent = closeButton
			closeButton.MouseButton1Click:connect(function ()
				closeEvent:Fire()
				closeButton.BackgroundTransparency = 1
			end)

			-- help button
			local helpButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-51,0.5,-8),"?",Enum.FontSize.Size14,"HelpButton",dragBar)
			local helpFrame = Instance.new("Frame",dragBar)
			helpFrame.Name = "HelpFrame"
			helpFrame.BackgroundColor3 = Color3.new(0,0,0)
			helpFrame.Size = UDim2.new(0,300,0,552)
			helpFrame.Position = UDim2.new(1,5,0,0)
			helpFrame.Active = true
			helpFrame.BorderSizePixel = 0
			helpFrame.Visible = false

			helpButton.MouseButton1Click:connect(function(  )
				helpFrame.Visible = not helpFrame.Visible
				if helpFrame.Visible then
					helpButton.Selected = true
					helpButton.BackgroundTransparency = 0
					local screenGui = getLayerCollectorAncestor(helpFrame)
					if screenGui then
						if helpFrame.AbsolutePosition.X + helpFrame.AbsoluteSize.X > screenGui.AbsoluteSize.X then --position on left hand side
							helpFrame.Position = UDim2.new(0,-5 - helpFrame.AbsoluteSize.X,0,0)
						else -- position on right hand side
							helpFrame.Position = UDim2.new(1,5,0,0)
						end
					else
						helpFrame.Position = UDim2.new(1,5,0,0)
					end
				else
					helpButton.Selected = false
					helpButton.BackgroundTransparency = 1
				end
			end)

			local minimizeButton = createMenuButton(UDim2.new(0,16,0,17),UDim2.new(1,-34,0.5,-8),"-",Enum.FontSize.Size14,"MinimizeButton",dragBar)
			minimizeButton.TextYAlignment = Enum.TextYAlignment.Top

			local minimizeFrame = Instance.new("Frame",dragBar)
			minimizeFrame.Name = "MinimizeFrame"
			minimizeFrame.BackgroundColor3 = Color3.new(73/255,73/255,73/255)
			minimizeFrame.BorderColor3 = Color3.new(0,0,0)
			minimizeFrame.Position = UDim2.new(0,0,1,0)
			if size then
				minimizeFrame.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,50) + UDim2.new(0,20,0,0)
			else
				minimizeFrame.Size = UDim2.new(0,183,0,50)
			end
			minimizeFrame.Visible = false

			local minimizeBigButton = Instance.new("TextButton",minimizeFrame)
			minimizeBigButton.Position = UDim2.new(0.5,-50,0.5,-20)
			minimizeBigButton.Name = "MinimizeButton"
			minimizeBigButton.Size = UDim2.new(0,100,0,40)
			minimizeBigButton.Style = Enum.ButtonStyle.RobloxButton
			minimizeBigButton.Font = Enum.Font.ArialBold
			minimizeBigButton.FontSize = Enum.FontSize.Size18
			minimizeBigButton.TextColor3 = Color3.new(1,1,1)
			minimizeBigButton.Text = "Show"

			local separatingLine = Instance.new("Frame",dragBar)
			separatingLine.Name = "SeparatingLine"
			separatingLine.BackgroundColor3 = Color3.new(115/255,115/255,115/255)
			separatingLine.BorderSizePixel = 0
			separatingLine.Position = UDim2.new(1,-18,0.5,-7)
			separatingLine.Size = UDim2.new(0,1,0,14)

			local otherSeparatingLine = separatingLine:clone()
			otherSeparatingLine.Position = UDim2.new(1,-35,0.5,-7)
			otherSeparatingLine.Parent = dragBar

			local widgetContainer = Instance.new("Frame",dragBar)
			widgetContainer.Name = "WidgetContainer"
			widgetContainer.BackgroundTransparency = 1
			widgetContainer.Position = UDim2.new(0,0,1,0)
			widgetContainer.BorderColor3 = Color3.new(0,0,0)
			if not scrollable then
				widgetContainer.BackgroundTransparency = 0
				widgetContainer.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
			end

			if size then
				if scrollable then
					widgetContainer.Size = size
				else
					widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,size.Y.Scale,size.Y.Offset)
				end
			else
				if scrollable then
					widgetContainer.Size = UDim2.new(0,163,0,400)
				else
					widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,0,400)
				end
			end
			if position then
				widgetContainer.Position = position + UDim2.new(0,0,0,20)
			end

			local frame,control,verticalDragger = nil
			if scrollable then
				--frame for widgets
				frame,control = t.CreateTrueScrollingFrame()
				frame.Size = UDim2.new(1, 0, 1, 0)
				frame.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
				frame.BorderColor3 = Color3.new(0,0,0)
				frame.Active = true
				frame.Parent = widgetContainer
				control.Parent = dragBar
				control.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
				control.BorderSizePixel = 0
				control.BackgroundTransparency = 0
				control.Position = UDim2.new(1,-21,1,1)
				if size then
					control.Size = UDim2.new(0,21,size.Y.Scale,size.Y.Offset)
				else
					control.Size = UDim2.new(0,21,0,400)
				end
				control:FindFirstChild("ScrollDownButton").Position = UDim2.new(0,0,1,-20)

				local fakeLine = Instance.new("Frame",control)
				fakeLine.Name = "FakeLine"
				fakeLine.BorderSizePixel = 0
				fakeLine.BackgroundColor3 = Color3.new(0,0,0)
				fakeLine.Size = UDim2.new(0,1,1,1)
				fakeLine.Position = UDim2.new(1,0,0,0)

				verticalDragger = Instance.new("TextButton",widgetContainer)
				verticalDragger.ZIndex = 2
				verticalDragger.AutoButtonColor = false
				verticalDragger.Name = "VerticalDragger"
				verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
				verticalDragger.BorderColor3 = Color3.new(0,0,0)
				verticalDragger.Size = UDim2.new(1,20,0,20)
				verticalDragger.Position = UDim2.new(0,0,1,0)
				verticalDragger.Active = true
				verticalDragger.Text = ""

				local scrubFrame = Instance.new("Frame",verticalDragger)
				scrubFrame.Name = "ScrubFrame"
				scrubFrame.BackgroundColor3 = Color3.new(1,1,1)
				scrubFrame.BorderSizePixel = 0
				scrubFrame.Position = UDim2.new(0.5,-5,0.5,0)
				scrubFrame.Size = UDim2.new(0,10,0,1)
				scrubFrame.ZIndex = 5
				local scrubTwo = scrubFrame:clone()
				scrubTwo.Position = UDim2.new(0.5,-5,0.5,-2)
				scrubTwo.Parent = verticalDragger
				local scrubThree = scrubFrame:clone()
				scrubThree.Position = UDim2.new(0.5,-5,0.5,2)
				scrubThree.Parent = verticalDragger

				local areaSoak = Instance.new("TextButton",getLayerCollectorAncestor(parent))
				areaSoak.Name = "AreaSoak"
				areaSoak.Size = UDim2.new(1,0,1,0)
				areaSoak.BackgroundTransparency = 1
				areaSoak.BorderSizePixel = 0
				areaSoak.Text = ""
				areaSoak.ZIndex = 10
				areaSoak.Visible = false
				areaSoak.Active = true

				local draggingVertical = false
				local startYPos = nil
				verticalDragger.MouseEnter:connect(function ()
					verticalDragger.BackgroundColor3 = Color3.new(60/255,60/255,60/255)
				end)
				verticalDragger.MouseLeave:connect(function ()
					verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
				end)
				verticalDragger.MouseButton1Down:connect(function(x,y)
					draggingVertical = true
					areaSoak.Visible = true
					startYPos = y
				end)
				areaSoak.MouseButton1Up:connect(function (  )
					draggingVertical = false
					areaSoak.Visible = false
				end)
				areaSoak.MouseMoved:connect(function(x,y)
					if not draggingVertical then return end

					local yDelta = y - startYPos
					if not control.ScrollDownButton.Visible and yDelta > 0 then
						return
					end

					if (widgetContainer.Size.Y.Offset + yDelta) < 150 then
						widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,150)
						control.Size = UDim2.new (0,21,0,150)
						return 
					end 

					startYPos = y

					if widgetContainer.Size.Y.Offset + yDelta >= 0 then
						widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,widgetContainer.Size.Y.Offset + yDelta)
						control.Size = UDim2.new(0,21,0,control.Size.Y.Offset + yDelta )
					end
				end)
			end

			local function switchMinimize()
				minimizeFrame.Visible = not minimizeFrame.Visible
				if scrollable then
					frame.Visible = not frame.Visible
					verticalDragger.Visible = not verticalDragger.Visible
					control.Visible = not control.Visible
				else
					widgetContainer.Visible = not widgetContainer.Visible
				end

				if minimizeFrame.Visible then
					minimizeButton.Text = "+"
				else
					minimizeButton.Text = "-"
				end
			end

			minimizeBigButton.MouseButton1Click:connect(function (  )
				switchMinimize()
			end)

			minimizeButton.MouseButton1Click:connect(function(  )
				switchMinimize()
			end)

			if scrollable then
				return dragBar, frame, helpFrame, closeEvent
			else
				return dragBar, widgetContainer, helpFrame, closeEvent
			end
		end

		t.Help = 
			function(funcNameOrFunc) 
				--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
				if funcNameOrFunc == "CreatePropertyDropDownMenu" or funcNameOrFunc == t.CreatePropertyDropDownMenu then
					return "Function CreatePropertyDropDownMenu.  " ..
					"Arguments: (instance, propertyName, enumType).  " .. 
					"Side effect: returns a container with a drop-down-box that is linked to the 'property' field of 'instance' which is of type 'enumType'" 
				end 
				if funcNameOrFunc == "CreateDropDownMenu" or funcNameOrFunc == t.CreateDropDownMenu then
					return "Function CreateDropDownMenu.  " .. 
					"Arguments: (items, onItemSelected).  " .. 
					"Side effect: Returns 2 results, a container to the gui object and a 'updateSelection' function for external updating.  The container is a drop-down-box created around a list of items" 
				end 
				if funcNameOrFunc == "CreateMessageDialog" or funcNameOrFunc == t.CreateMessageDialog then
					return "Function CreateMessageDialog.  " .. 
					"Arguments: (title, message, buttons). " .. 
					"Side effect: Returns a gui object of a message box with 'title' and 'message' as passed in.  'buttons' input is an array of Tables contains a 'Text' and 'Function' field for the text/callback of each button"
				end		
				if funcNameOrFunc == "CreateStyledMessageDialog" or funcNameOrFunc == t.CreateStyledMessageDialog then
					return "Function CreateStyledMessageDialog.  " .. 
					"Arguments: (title, message, style, buttons). " .. 
					"Side effect: Returns a gui object of a message box with 'title' and 'message' as passed in.  'buttons' input is an array of Tables contains a 'Text' and 'Function' field for the text/callback of each button, 'style' is a string, either Error, Notify or Confirm"
				end
				if funcNameOrFunc == "GetFontHeight" or funcNameOrFunc == t.GetFontHeight then
					return "Function GetFontHeight.  " .. 
					"Arguments: (font, fontSize). " .. 
					"Side effect: returns the size in pixels of the given font + fontSize"
				end
				if funcNameOrFunc == "LayoutGuiObjects" or funcNameOrFunc == t.LayoutGuiObjects then

				end
				if funcNameOrFunc == "CreateScrollingFrame" or funcNameOrFunc == t.CreateScrollingFrame then
					return "Function CreateScrollingFrame.  " .. 
					"Arguments: (orderList, style) " .. 
					"Side effect: returns 4 objects, (scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction).  'scrollFrame' can be filled with GuiObjects.  It will lay them out and allow scrollUpButton/scrollDownButton to interact with them.  Orderlist is optional (and specifies the order to layout the children.  Without orderlist, it uses the children order. style is also optional, and allows for a 'grid' styling if style is passed 'grid' as a string.  recalculateFunction can be called when a relayout is needed (when orderList changes)"
				end
				if funcNameOrFunc == "CreateTrueScrollingFrame" or funcNameOrFunc == t.CreateTrueScrollingFrame then
					return "Function CreateTrueScrollingFrame.  " .. 
					"Arguments: (nil) " .. 
					"Side effect: returns 2 objects, (scrollFrame, controlFrame).  'scrollFrame' can be filled with GuiObjects, and they will be clipped if not inside the frame's bounds. controlFrame has children scrollup and scrolldown, as well as a slider.  controlFrame can be parented to any guiobject and it will readjust itself to fit."
				end
				if funcNameOrFunc == "AutoTruncateTextObject" or funcNameOrFunc == t.AutoTruncateTextObject then
					return "Function AutoTruncateTextObject.  " .. 
					"Arguments: (textLabel) " .. 
					"Side effect: returns 2 objects, (textLabel, changeText).  The 'textLabel' input is modified to automatically truncate text (with ellipsis), if it gets too small to fit.  'changeText' is a function that can be used to change the text, it takes 1 string as an argument"
				end
				if funcNameOrFunc == "CreateSlider" or funcNameOrFunc == t.CreateSlider then
					return "Function CreateSlider.  " ..
					"Arguments: (steps, width, position) " ..
					"Side effect: returns 2 objects, (sliderGui, sliderPosition).  The 'steps' argument specifies how many different positions the slider can hold along the bar.  'width' specifies in pixels how wide the bar should be (modifiable afterwards if desired). 'position' argument should be a UDim2 for slider positioning. 'sliderPosition' is an IntValue whose current .Value specifies the specific step the slider is currently on."
				end
				if funcNameOrFunc == "CreateSliderNew" or funcNameOrFunc == t.CreateSliderNew then
					return "Function CreateSliderNew.  " ..
					"Arguments: (steps, width, position) " ..
					"Side effect: returns 2 objects, (sliderGui, sliderPosition).  The 'steps' argument specifies how many different positions the slider can hold along the bar.  'width' specifies in pixels how wide the bar should be (modifiable afterwards if desired). 'position' argument should be a UDim2 for slider positioning. 'sliderPosition' is an IntValue whose current .Value specifies the specific step the slider is currently on."
				end
				if funcNameOrFunc == "CreateLoadingFrame" or funcNameOrFunc == t.CreateLoadingFrame then
					return "Function CreateLoadingFrame.  " ..
					"Arguments: (name, size, position) " ..
					"Side effect: Creates a gui that can be manipulated to show progress for a particular action.  Name appears above the loading bar, and size and position are udim2 values (both size and position are optional arguments).  Returns 3 arguments, the first being the gui created. The second being updateLoadingGuiPercent, which is a bindable function.  This function takes one argument (two optionally), which should be a number between 0 and 1, representing the percentage the loading gui should be at.  The second argument to this function is a boolean value that if set to true will tween the current percentage value to the new percentage value, therefore our third argument is how long this tween should take. Our third returned argument is a BindableEvent, that when fired means that someone clicked the cancel button on the dialog."
				end
				if funcNameOrFunc == "CreateTerrainMaterialSelector" or funcNameOrFunc == t.CreateTerrainMaterialSelector then
					return "Function CreateTerrainMaterialSelector.  " ..
					"Arguments: (size, position) " ..
					"Side effect: Size and position are UDim2 values that specifies the selector's size and position.  Both size and position are optional arguments. This method returns 3 objects (terrainSelectorGui, terrainSelected, forceTerrainSelection).  terrainSelectorGui is just the gui object that we generate with this function, parent it as you like. TerrainSelected is a BindableEvent that is fired whenever a new terrain type is selected in the gui.  ForceTerrainSelection is a function that takes an argument of Enum.CellMaterial and will force the gui to show that material as currently selected."
				end
			end

		return t

	end;
};
G2L_MODULES[G2L["10c"]] = {
	Closure = function()
		local script = G2L["10c"];local t = {}

		-- Do a line/plane intersection.  The line starts at the camera.  The plane is at y == 0, normal(0, 1, 0)
		--
		-- vectorPos - End point of the line.
		--
		-- Return:
		-- cellPos - The terrain cell intersection point if there is one, vectorPos if there isn't.
		-- hit - Whether there was a plane intersection.  Value is true if there was, false if not.
		function PlaneIntersection(vectorPos)
			local hit = false
			local currCamera = game:GetService("Workspace").CurrentCamera
			local startPos = Vector3.new(currCamera.CoordinateFrame.p.X, currCamera.CoordinateFrame.p.Y, currCamera.CoordinateFrame.p.Z)
			local endPos = Vector3.new(vectorPos.X, vectorPos.Y, vectorPos.Z)
			local normal = Vector3.new(0, 1, 0)
			local p3 = Vector3.new(0, 0, 0)
			local startEndDot = normal:Dot(endPos - startPos)
			local cellPos = vectorPos
			if startEndDot ~= 0  then
				local t = normal:Dot(p3 - startPos) / startEndDot
				if(t >=0 and t <=1) then
					local intersection = ((endPos - startPos) * t) + startPos
					cellPos = game:GetService("Workspace").Terrain:WorldToCell(intersection)
					hit = true
				end
			end

			return cellPos, hit
		end


		-- Purpose:
		-- Checks for terrain touched by the mouse hit.
		-- Will do a plane intersection if no terrain is touched.
		--
		-- mouse - Mouse to check the .hit for.
		--
		-- Return:
		-- cellPos - Cell position hit.  Nil if none.
		function GetTerrainForMouse(mouse)
			-- There was no target, so all it could be is a plane intersection.
			-- Check for a plane intersection.  If there isn't one then nothing will get hit.
			local cell = game:GetService("Workspace").Terrain:WorldToCellPreferSolid(Vector3.new(mouse.hit.x, mouse.hit.y, mouse.hit.z))
			local planeLoc = nil
			local hit = nil
			-- If nothing was hit, do the plane intersection.
			if 0 == game:GetService("Workspace").Terrain:GetCell(cell.X, cell.Y, cell.Z).Value then
				cell = nil
				planeLoc, hit = PlaneIntersection(Vector3.new(mouse.hit.x, mouse.hit.y, mouse.hit.z))
				if hit then
					cell = planeLoc
				end
			end
			return cell
		end

		-- setup helper functions
		local insertBoundingBoxOverlapVector = Vector3.new(.3, .3, .3) -- we can still stamp if our character extrudes into the target stamping space by .3 or fewer units

		-- rotates a model by yAngle radians about the global y-axis
		local function rotatePartAndChildren(part, rotCF, offsetFromOrigin)
			-- rotate this thing, if it's a part
			if part:IsA("BasePart") then
				part.CFrame = (rotCF * (part.CFrame - offsetFromOrigin)) + offsetFromOrigin
			end

			-- recursively do the same to all children
			local partChildren = part:GetChildren()
			for c = 1, #partChildren do rotatePartAndChildren(partChildren[c], rotCF, offsetFromOrigin) end
		end

		local function modelRotate(model, yAngle)
			local rotCF = CFrame.Angles(0, yAngle, 0)
			local offsetFromOrigin = model:GetModelCFrame().p

			rotatePartAndChildren(model, rotCF, offsetFromOrigin)
		end


		local function collectParts(object, baseParts, scripts, decals)
			if object:IsA("BasePart") then
				baseParts[#baseParts+1] = object
			elseif object:IsA("Script") then
				scripts[#scripts+1] = object
			elseif object:IsA("Decal") then
				decals[#decals+1] = object
			end

			for index,child in pairs(object:GetChildren()) do
				collectParts(child, baseParts, scripts, decals)
			end
		end

		local function clusterPartsInRegion(startVector, endVector)
			local cluster = game:GetService("Workspace"):FindFirstChild("Terrain")

			local startCell = cluster:WorldToCell(startVector)
			local endCell = cluster:WorldToCell(endVector)

			local startX = startCell.X
			local startY = startCell.Y
			local startZ = startCell.Z

			local endX = endCell.X
			local endY = endCell.Y
			local endZ = endCell.Z

			if startX < cluster.MaxExtents.Min.X then startX = cluster.MaxExtents.Min.X end
			if startY < cluster.MaxExtents.Min.Y then startY = cluster.MaxExtents.Min.Y end
			if startZ < cluster.MaxExtents.Min.Z then startZ = cluster.MaxExtents.Min.Z end

			if endX > cluster.MaxExtents.Max.X then endX = cluster.MaxExtents.Max.X end
			if endY > cluster.MaxExtents.Max.Y then endY = cluster.MaxExtents.Max.Y end
			if endZ > cluster.MaxExtents.Max.Z then endZ = cluster.MaxExtents.Max.Z end

			for x = startX, endX do
				for y = startY, endY do
					for z = startZ, endZ do
						if (cluster:GetCell(x, y, z).Value) > 0 then return true end
					end
				end
			end

			return false
		end

		local function findSeatsInModel(parent, seatTable)
			if not parent then return end

			if parent.className == "Seat" or parent.className == "VehicleSeat" then
				table.insert(seatTable, parent)
			end
			local myChildren = parent:GetChildren()
			for j = 1, #myChildren do
				findSeatsInModel(myChildren[j], seatTable)
			end
		end

		local function setSeatEnabledStatus(model, isEnabled)
			local seatList = {}
			findSeatsInModel(model, seatList)

			if isEnabled then
				-- remove any welds called "SeatWeld" in seats
				for i = 1, #seatList do
					local nextSeat = seatList[i]:FindFirstChild("SeatWeld")
					while nextSeat do nextSeat:Remove() nextSeat = seatList[i]:FindFirstChild("SeatWeld") end
				end
			else
				-- put a weld called "SeatWeld" in every seat
				--   this tricks it into thinking there's already someone sitting there, and it won't make you sit XD
				for i = 1, #seatList do
					local fakeWeld = Instance.new("Weld")
					fakeWeld.Name = "SeatWeld"
					fakeWeld.Parent = seatList[i]
				end
			end
		end

		local function autoAlignToFace(parts)
			local aatf = parts:FindFirstChild("AutoAlignToFace")
			if aatf then return aatf.Value else return false end
		end

		local function getClosestAlignedWorldDirection(aVector3InWorld)
			local xDir = Vector3.new(1,0,0)
			local yDir = Vector3.new(0,1,0)
			local zDir = Vector3.new(0,0,1)
			local xDot = aVector3InWorld.x * xDir.x + aVector3InWorld.y * xDir.y + aVector3InWorld.z * xDir.z
			local yDot = aVector3InWorld.x * yDir.x + aVector3InWorld.y * yDir.y + aVector3InWorld.z * yDir.z
			local zDot = aVector3InWorld.x * zDir.x + aVector3InWorld.y * zDir.y + aVector3InWorld.z * zDir.z

			if math.abs(xDot) > math.abs(yDot) and math.abs(xDot) > math.abs(zDot) then
				if xDot > 0 then
					return 0
				else
					return 3
				end
			elseif math.abs(yDot) > math.abs(xDot) and math.abs(yDot) > math.abs(zDot) then
				if yDot > 0 then
					return 1
				else
					return 4
				end
			else
				if zDot > 0 then
					return 2
				else
					return 5
				end
			end
		end

		local function positionPartsAtCFrame3(aCFrame, currentParts)
			local insertCFrame = nil
			if not currentParts then return currentParts end
			if currentParts and (currentParts:IsA("Model") or currentParts:IsA("Tool")) then
				insertCFrame = currentParts:GetModelCFrame()
				currentParts:TranslateBy(aCFrame.p - insertCFrame.p)
			else
				currentParts.CFrame = aCFrame
			end
			return currentParts
		end

		local function calcRayHitTime(rayStart, raySlope, intersectionPlane)
			if math.abs(raySlope) < .01 then return 0 end -- 0 slope -->  we just say intersection time is 0, and sidestep this dimension
			return (intersectionPlane - rayStart) / raySlope
		end

		local function modelTargetSurface(partOrModel, rayStart, rayEnd)
			if not partOrModel then
				return 0
			end

			local modelCFrame = nil
			local modelSize = nil
			if partOrModel:IsA("Model") then
				modelCFrame = partOrModel:GetModelCFrame()
				modelSize = partOrModel:GetModelSize()
			else
				modelCFrame = partOrModel.CFrame
				modelSize = partOrModel.Size
			end

			local mouseRayStart = modelCFrame:pointToObjectSpace(rayStart)
			local mouseRayEnd = modelCFrame:pointToObjectSpace(rayEnd)
			local mouseSlope = mouseRayEnd - mouseRayStart

			local xPositive = 1
			local yPositive = 1
			local zPositive = 1
			if mouseSlope.X > 0 then xPositive = -1 end
			if mouseSlope.Y > 0 then yPositive = -1 end
			if mouseSlope.Z > 0 then zPositive = -1 end

			-- find which surface the transformed mouse ray hits (using modelSize):
			local xHitTime = calcRayHitTime(mouseRayStart.X, mouseSlope.X, modelSize.X/2 * xPositive)
			local yHitTime = calcRayHitTime(mouseRayStart.Y, mouseSlope.Y, modelSize.Y/2 * yPositive)
			local zHitTime = calcRayHitTime(mouseRayStart.Z, mouseSlope.Z, modelSize.Z/2 * zPositive)

			local hitFace = 0

			--if xHitTime >= 0 and yHitTime >= 0 and zHitTime >= 0 then
			if xHitTime > yHitTime then
				if xHitTime > zHitTime then
					-- xFace is hit
					hitFace = 1*xPositive
				else
					-- zFace is hit
					hitFace = 3*zPositive
				end
			else
				if yHitTime > zHitTime then
					-- yFace is hit
					hitFace = 2*yPositive
				else
					-- zFace is hit
					hitFace = 3*zPositive
				end
			end

			return hitFace
		end

		local function getBoundingBox2(partOrModel)

			-- for models, the bounding box is defined as the minimum and maximum individual part bounding boxes
			-- relative to the first part's coordinate frame.
			local minVec = Vector3.new(math.huge, math.huge, math.huge)
			local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

			if partOrModel:IsA("Terrain") then
				minVec = Vector3.new(-2, -2, -2)
				maxVec = Vector3.new(2, 2, 2)
			elseif partOrModel:IsA("BasePart") then
				minVec = -0.5 * partOrModel.Size
				maxVec = -minVec
			else
				maxVec = partOrModel:GetModelSize()*0.5
				minVec = -maxVec
			end

			-- Adjust bounding box to reflect what the model or part author wants in  terms of justification
			local justifyValue = partOrModel:FindFirstChild("Justification")
			if justifyValue ~= nil then
				-- find the multiple of 4 that contains the model
				local justify = justifyValue.Value
				local two = Vector3.new(2, 2, 2)
				local actualBox = maxVec - minVec - Vector3.new(0.01, 0.01, 0.01)
				local containingGridBox = Vector3.new(4 * math.ceil(actualBox.x/4), 4 * math.ceil(actualBox.y/4), 4 * math.ceil(actualBox.z/4))
				local adjustment = containingGridBox - actualBox
				minVec = minVec - 0.5 * adjustment * justify
				maxVec = maxVec + 0.5 * adjustment * (two - justify)
			end

			return minVec, maxVec
		end

		local function getBoundingBoxInWorldCoordinates(partOrModel)
			local minVec = Vector3.new(math.huge, math.huge, math.huge)
			local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

			if partOrModel:IsA("BasePart") and not partOrModel:IsA("Terrain") then
				local vec1 = partOrModel.CFrame:pointToWorldSpace(-0.5 * partOrModel.Size)
				local vec2 = partOrModel.CFrame:pointToWorldSpace(0.5 * partOrModel.Size)
				minVec = Vector3.new(math.min(vec1.X, vec2.X), math.min(vec1.Y, vec2.Y), math.min(vec1.Z, vec2.Z))
				maxVec = Vector3.new(math.max(vec1.X, vec2.X), math.max(vec1.Y, vec2.Y), math.max(vec1.Z, vec2.Z))
			elseif partOrModel:IsA("Terrain") then
				-- we shouldn't have to deal with this case
				--minVec = Vector3.new(-2, -2, -2)
				--maxVec = Vector3.new(2, 2, 2)
			else
				local vec1 = partOrModel:GetModelCFrame():pointToWorldSpace(-0.5 * partOrModel:GetModelSize())
				local vec2 = partOrModel:GetModelCFrame():pointToWorldSpace(0.5 * partOrModel:GetModelSize())
				minVec = Vector3.new(math.min(vec1.X, vec2.X), math.min(vec1.Y, vec2.Y), math.min(vec1.Z, vec2.Z))
				maxVec = Vector3.new(math.max(vec1.X, vec2.X), math.max(vec1.Y, vec2.Y), math.max(vec1.Z, vec2.Z))
			end

			return minVec, maxVec
		end

		local function getTargetPartBoundingBox(targetPart)
			if targetPart.Parent:FindFirstChild("RobloxModel") ~= nil then
				return getBoundingBox2(targetPart.Parent)
			else
				return getBoundingBox2(targetPart)
			end
		end

		local function getMouseTargetCFrame(targetPart)
			if targetPart.Parent:FindFirstChild("RobloxModel") ~= nil then
				if targetPart.Parent:IsA("Tool") then return targetPart.Parent.Handle.CFrame
				else return targetPart.Parent:GetModelCFrame() end
			else
				return targetPart.CFrame
			end
		end

		local function isBlocker(part) -- returns whether or not we want to cancel the stamp because we're blocked by this part
			if not part then return false end
			if not part.Parent then return false end
			if part:FindFirstChild("Humanoid") then return false end
			if part:FindFirstChild("RobloxStamper") or part:FindFirstChild("RobloxModel") then return true end
			if part:IsA("Part") and not part.CanCollide then return false end
			if part == game:GetService("Lighting") then return false end
			return isBlocker(part.Parent)
		end

		-- helper function to determine if a character can be pushed upwards by a certain amount
		-- character is 5 studs tall, we'll check a 1.5 x 1.5 x 4.5 box around char, with center .5 studs below torsocenter
		local function spaceAboveCharacter(charTorso, newTorsoY, stampData)
			local partsAboveChar = game:GetService("Workspace"):FindPartsInRegion3(
				Region3.new(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75),
					Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)),
				charTorso.Parent,
				100)

			for j = 1, #partsAboveChar do
				if partsAboveChar[j].CanCollide and not partsAboveChar[j]:IsDescendantOf(stampData.CurrentParts) then return false end
			end

			if clusterPartsInRegion(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75),
				Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)) then
				return false
			end

			return true
		end


		local function findConfigAtMouseTarget(Mouse, stampData)
			-- *Critical Assumption* :
			--				This function assumes the target CF axes are orthogonal with the target bounding box faces
			--				And, it assumes the insert CF axes are orthongonal with the insert bounding box faces
			--				Therefore, insertion will not work with angled faces on wedges or other "non-block" parts, nor
			--				will it work for parts in a model that are not orthogonally aligned with the model's CF.

			if not Mouse then return nil end -- This can happen sometimes, return if so
			if not stampData then error("findConfigAtMouseTarget: stampData is nil") return nil end
			if not stampData["CurrentParts"] then return nil end

			local grid = 4.0
			local admissibleConfig = false
			local targetConfig = CFrame.new(0,0,0)

			local minBB, maxBB = getBoundingBox2(stampData.CurrentParts)
			local diagBB = maxBB - minBB

			local insertCFrame
			if stampData.CurrentParts:IsA("Model") or stampData.CurrentParts:IsA("Tool") then
				insertCFrame = stampData.CurrentParts:GetModelCFrame()
			else
				insertCFrame = stampData.CurrentParts.CFrame
			end

			if Mouse then
				if stampData.CurrentParts:IsA("Tool") then
					Mouse.TargetFilter = stampData.CurrentParts.Handle
				else
					Mouse.TargetFilter = stampData.CurrentParts
				end
			end

			local hitPlane = false
			local targetPart = nil
			local success = pcall(function() targetPart = Mouse.Target end)

			if not success then-- or targetPart == nil then
				return admissibleConfig, targetConfig
			end

			local mouseHitInWorld = Vector3.new(0, 0, 0)
			if Mouse then
				mouseHitInWorld = Vector3.new(Mouse.Hit.x, Mouse.Hit.y, Mouse.Hit.z)
			end

			local cellPos = nil

			-- Nothing was hit, so check for the default plane.
			if nil == targetPart then
				cellPos = GetTerrainForMouse(Mouse)
				if nil == cellPos then
					hitPlane = false
					return admissibleConfig, targetConfig
				else
					targetPart = game:GetService("Workspace").Terrain
					hitPlane = true
					-- Take into account error that will occur.
					cellPos = Vector3.new(cellPos.X - 1, cellPos.Y, cellPos.Z)
					mouseHitInWorld = game:GetService("Workspace").Terrain:CellCenterToWorld(cellPos.x, cellPos.y, cellPos.z)
				end
			end

			-- test mouse hit location
			local minBBTarget, maxBBTarget = getTargetPartBoundingBox(targetPart)
			local diagBBTarget = maxBBTarget - minBBTarget
			local targetCFrame = getMouseTargetCFrame(targetPart)

			if targetPart:IsA("Terrain") then
				local cluster = game:GetService("Workspace"):FindFirstChild("Terrain")
				local cellID = cluster:WorldToCellPreferSolid(mouseHitInWorld)
				if hitPlane then
					cellID = cellPos
				end

				targetCFrame = CFrame.new(game:GetService("Workspace").Terrain:CellCenterToWorld(cellID.x, cellID.y, cellID.z))
			end

			local mouseHitInTarget = targetCFrame:pointToObjectSpace(mouseHitInWorld)
			local targetVectorInWorld = Vector3.new(0,0,0)
			if Mouse then
				-- DON'T WANT THIS IN TERMS OF THE MODEL CFRAME!  (.TargetSurface is in terms of the part CFrame, so this would break, right?  [HotThoth])
				--   (ideally, we would want to make the Mouse.TargetSurface a model-targetsurface instead, but for testing will be using the converse)
				--targetVectorInWorld = targetCFrame:vectorToWorldSpace(Vector3.FromNormalId(Mouse.TargetSurface))
				targetVectorInWorld = targetPart.CFrame:vectorToWorldSpace(Vector3.FromNormalId(Mouse.TargetSurface))   -- better, but model cframe would be best
		--[[if targetPart.Parent:IsA("Model") then
			local hitFace = modelTargetSurface(targetPart.Parent, Mouse.Hit.p, workspace.CurrentCamera.CoordinateFrame.p)  -- best, if you get it right
			local WORLD_AXES = {Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1)}
			if hitFace > 0 then
				targetVectorInWorld = targetCFrame:vectorToWorldSpace(WORLD_AXES[hitFace])
			elseif hitFace < 0 then
				targetVectorInWorld = targetCFrame:vectorToWorldSpace(-WORLD_AXES[-hitFace])
			end
		end]]
			end

			local targetRefPointInTarget
			local clampToSurface
			local insertRefPointInInsert

			if getClosestAlignedWorldDirection(targetVectorInWorld) == 0 then
				targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
				insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
				clampToSurface = Vector3.new(0,1,1)
			elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 3 then
				targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
				insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
				clampToSurface = Vector3.new(0,1,1)
			elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 1 then
				targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
				insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
				clampToSurface = Vector3.new(1,0,1)
			elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 4 then
				targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
				insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
				clampToSurface = Vector3.new(1,0,1)
			elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 2 then
				targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
				insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
				clampToSurface = Vector3.new(1,1,0)
			else
				targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
				insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
				clampToSurface = Vector3.new(1,1,0)
			end

			targetRefPointInTarget = targetRefPointInTarget * (0.5 * diagBBTarget) + 0.5 * (maxBBTarget + minBBTarget)
			insertRefPointInInsert = insertRefPointInInsert * (0.5 * diagBB) + 0.5 * (maxBB + minBB)

			-- To Do: For cases that are not aligned to the world grid, account for the minimal rotation
			-- needed to bring the Insert part(s) into alignment with the Target Part
			-- Apply the rotation here

			local delta = mouseHitInTarget - targetRefPointInTarget
			local deltaClamped = Vector3.new(grid * math.modf(delta.x/grid), grid * math.modf(delta.y/grid), grid * math.modf(delta.z/grid))
			deltaClamped = deltaClamped * clampToSurface
			local targetTouchInTarget = deltaClamped + targetRefPointInTarget

			local TargetTouchRelToWorld = targetCFrame:pointToWorldSpace(targetTouchInTarget)
			local InsertTouchInWorld = insertCFrame:vectorToWorldSpace(insertRefPointInInsert)
			local posInsertOriginInWorld = TargetTouchRelToWorld - InsertTouchInWorld

			local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = insertCFrame:components()
			targetConfig = CFrame.new(posInsertOriginInWorld.x, posInsertOriginInWorld.y, posInsertOriginInWorld.z, R00, R01, R02, R10, R11, R12, R20, R21, R22)
			admissibleConfig = true

			return admissibleConfig, targetConfig, getClosestAlignedWorldDirection(targetVectorInWorld)
		end

		local function truncateToCircleEighth(bigValue, littleValue)
			local big = math.abs(bigValue)
			local little = math.abs(littleValue)
			local hypotenuse = math.sqrt(big*big + little*little)
			local frac = little / hypotenuse

			local bigSign = 1
			local littleSign = 1
			if bigValue < 0 then bigSign = -1 end
			if littleValue < 0 then littleSign = -1 end

			if frac > .382683432 then
				-- between 22.5 and 45 degrees, so truncate to 45-degree tilt
				return .707106781 * hypotenuse * bigSign, .707106781 * hypotenuse * littleSign
			else
				-- between 0 and 22.5 degrees, so truncate to 0-degree tilt
				return hypotenuse * bigSign, 0
			end
		end


		local function saveTheWelds(object, manualWeldTable, manualWeldParentTable)
			if object:IsA("ManualWeld") or object:IsA("Rotate") then
				table.insert(manualWeldTable, object)
				table.insert(manualWeldParentTable, object.Parent)
			else
				local children = object:GetChildren()
				for i = 1, #children do
					saveTheWelds(children[i], manualWeldTable, manualWeldParentTable)
				end
			end
		end

		local function restoreTheWelds(manualWeldTable, manualWeldParentTable)
			for i = 1, #manualWeldTable do
				manualWeldTable[i].Parent = manualWeldParentTable[i]
			end
		end

		t.CanEditRegion = function(partOrModel, EditRegion) -- todo: use model and stamper metadata
			if not EditRegion then return true, false end

			local minBB, maxBB = getBoundingBoxInWorldCoordinates(partOrModel)

			if minBB.X < EditRegion.CFrame.p.X - EditRegion.Size.X/2 or
				minBB.Y < EditRegion.CFrame.p.Y - EditRegion.Size.Y/2 or
				minBB.Z < EditRegion.CFrame.p.Z - EditRegion.Size.Z/2 then
				return false, false
			end

			if maxBB.X > EditRegion.CFrame.p.X + EditRegion.Size.X/2 or
				maxBB.Y > EditRegion.CFrame.p.Y + EditRegion.Size.Y/2 or
				maxBB.Z > EditRegion.CFrame.p.Z + EditRegion.Size.Z/2 then
				return false, false
			end

			return true, false
		end

		t.GetStampModel = function(assetId, terrainShape, useAssetVersionId)
			if assetId == 0 then
				return nil, "No Asset"
			end
			if assetId < 0 then
				return nil, "Negative Asset"
			end

			local function UnlockInstances(object)
				if object:IsA("BasePart") then
					object.Locked = false
				end
				for index,child in pairs(object:GetChildren()) do
					UnlockInstances(child)
				end
			end

			local function getClosestColorToTerrainMaterial(terrainValue)
				if terrainValue == 1 then
					return BrickColor.new("Bright green")
				elseif terrainValue == 2 then
					return BrickColor.new("Bright yellow")
				elseif terrainValue == 3 then
					return BrickColor.new("Bright red")
				elseif terrainValue == 4 then
					return BrickColor.new("Sand red")
				elseif terrainValue == 5 then
					return BrickColor.new("Black")
				elseif terrainValue == 6 then
					return BrickColor.new("Dark stone grey")
				elseif terrainValue == 7 then
					return BrickColor.new("Sand blue")
				elseif terrainValue == 8 then
					return BrickColor.new("Deep orange")
				elseif terrainValue == 9 then
					return BrickColor.new("Dark orange")
				elseif terrainValue == 10 then
					return BrickColor.new("Reddish brown")
				elseif terrainValue == 11 then
					return BrickColor.new("Light orange")
				elseif terrainValue == 12 then
					return BrickColor.new("Light stone grey")
				elseif terrainValue == 13 then
					return BrickColor.new("Sand green")
				elseif terrainValue == 14 then
					return BrickColor.new("Medium stone grey")
				elseif terrainValue == 15 then
					return BrickColor.new("Really red")
				elseif terrainValue == 16 then
					return BrickColor.new("Really blue")
				elseif terrainValue == 17 then
					return BrickColor.new("Bright blue")
				else
					return BrickColor.new("Bright green")
				end
			end

			local function setupFakeTerrainPart(cellMat, cellType, cellOrient)
				local newTerrainPiece = nil
				if (cellType == 1 or cellType == 4) then newTerrainPiece = Instance.new("WedgePart")
				elseif (cellType == 2) then newTerrainPiece = Instance.new("CornerWedgePart")
				else newTerrainPiece = Instance.new("Part") end
				newTerrainPiece.Name = "MegaClusterCube"
				newTerrainPiece.Size = Vector3.new(4, 4, 4)
				newTerrainPiece.BottomSurface = "Smooth"
				newTerrainPiece.TopSurface = "Smooth"

				-- can add decals or textures here if feeling particularly adventurous...  for now, can make a table of look-up colors
				newTerrainPiece.BrickColor = getClosestColorToTerrainMaterial(cellMat)

		local sideways = 0
		local flipped = math.pi
		if cellType == 4 then sideways = -math.pi/2 end
		if cellType == 2 or cellType == 3 then flipped = 0 end
		newTerrainPiece.CFrame = CFrame.Angles(0, math.pi/2*cellOrient + flipped, sideways)

		if cellType == 3 then
			local inverseCornerWedgeMesh = Instance.new("SpecialMesh")
			inverseCornerWedgeMesh.MeshType = "FileMesh"
			inverseCornerWedgeMesh.MeshId = "https://www.roblox.com/asset/?id=66832495"
			inverseCornerWedgeMesh.Scale = Vector3.new(2, 2, 2)
			inverseCornerWedgeMesh.Parent = newTerrainPiece
		end

		local materialTag = Instance.new("Vector3Value")
		materialTag.Value = Vector3.new(cellMat, cellType, cellOrient)
		materialTag.Name = "ClusterMaterial"
		materialTag.Parent = newTerrainPiece

		return newTerrainPiece
	end

	-- This call will cause a "wait" until the data comes back
	-- below we wait a max of 8 seconds before deciding to bail out on loading
	local root
	local loader
	loading = true
	if useAssetVersionId then
		loader = coroutine.create(function()
			root = game:GetService("InsertService"):LoadAssetVersion(assetId)
			loading = false
		end)
		coroutine.resume(loader)
	else
		loader = coroutine.create(function()
			root = game:GetService("InsertService"):LoadAsset(assetId)
			loading = false
		end)
		coroutine.resume(loader)
	end

	local lastGameTime = 0
	local totalTime = 0
	local maxWait = 8
	while loading and totalTime < maxWait do
		lastGameTime = tick()
		wait(1)
		totalTime = totalTime + tick() - lastGameTime
	end
	loading = false

	if totalTime >= maxWait then
		return nil, "Load Time Fail"
	end


	if root == nil then
		return nil, "Load Asset Fail"
	end

	if not root:IsA("Model") then
		return nil, "Load Type Fail"
	end

	local instances = root:GetChildren()
	if #instances == 0 then
		return nil, "Empty Model Fail"
	end

	--Unlock all parts that are inserted, to make sure they are editable
	UnlockInstances(root)

	--Continue the insert process
	root = root:GetChildren()[1]

	--Examine the contents and decide what it looks like
	for pos, instance in pairs(instances) do
		if instance:IsA("Team") then
			instance.Parent = game:GetService("Teams")
		elseif instance:IsA("Sky") then
			local lightingService = game:GetService("Lighting")
			for index,child in pairs(lightingService:GetChildren()) do
				if child:IsA("Sky") then
					child:Remove();
				end
			end
			instance.Parent = lightingService
			return
		end
	end

	-- ...and tag all inserted models for subsequent origin identification
	-- if no RobloxModel tag already exists, then add it.
	if root:FindFirstChild("RobloxModel") == nil then
		local stringTag = Instance.new("BoolValue", root)
		stringTag.Name = "RobloxModel"

		if root:FindFirstChild("RobloxStamper") == nil then
			local stringTag2 = Instance.new("BoolValue", root)
			stringTag2.Name = "RobloxStamper"
		end
	end

	if terrainShape then
		if root.Name == "MegaClusterCube" then
			if (terrainShape == 6) then -- insert an autowedging tag
				local autowedgeTag = Instance.new("BoolValue")
				autowedgeTag.Name = "AutoWedge"
				autowedgeTag.Parent = root
			else
				local clusterTag = root:FindFirstChild("ClusterMaterial")
				if clusterTag then
					if clusterTag:IsA("Vector3Value") then
						root = setupFakeTerrainPart(clusterTag.Value.X, terrainShape, clusterTag.Value.Z)
					else
						root = setupFakeTerrainPart(clusterTag.Value, terrainShape, 0)
					end
				else
					root = setupFakeTerrainPart(1, terrainShape, 0)
				end
			end
		end
	end

	return root
end



t.SetupStamperDragger = function(modelToStamp, Mouse, StampInModel, AllowedStampRegion, StampFailedFunc)
	if not modelToStamp then
		error("SetupStamperDragger: modelToStamp (first arg) is nil!  Should be a stamper model")
		return nil
	end
	if not modelToStamp:IsA("Model") and not modelToStamp:IsA("BasePart") then
		error("SetupStamperDragger: modelToStamp (first arg) is neither a Model or Part!")
		return nil
	end
	if not Mouse then
		error("SetupStamperDragger: Mouse (second arg) is nil!  Should be a mouse object")
		return nil
	end
	if not Mouse:IsA("Mouse") then
		error("SetupStamperDragger: Mouse (second arg) is not of type Mouse!")
		return nil
	end

	local stampInModel = nil
	local allowedStampRegion = nil
	local stampFailedFunc = nil
	if StampInModel then
		if not StampInModel:IsA("Model") then
			error("SetupStamperDragger: StampInModel (optional third arg) is not of type 'Model'")
			return nil
		end
		if not AllowedStampRegion then
			error("SetupStamperDragger: AllowedStampRegion (optional fourth arg) is nil when StampInModel (optional third arg) is defined")
			return nil
		end
		stampFailedFunc = StampFailedFunc
		stampInModel = StampInModel
		allowedStampRegion = AllowedStampRegion
	end

	-- Init all state variables
	local gInitial90DegreeRotations = 0
	local stampData = nil
	local mouseTarget = nil

	local errorBox = Instance.new("SelectionBox")
	errorBox.Color = BrickColor.new("Bright red")
	errorBox.Transparency = 0
	errorBox.Archivable = false

	-- for megacluster MEGA STAMPING
	local adornPart = Instance.new("Part")
	adornPart.Parent = nil
	adornPart.Size = Vector3.new(4, 4, 4)
	adornPart.CFrame = CFrame.new()
	adornPart.Archivable = false

	local adorn = Instance.new("SelectionBox")
	adorn.Color = BrickColor.new("Toothpaste")
	adorn.Adornee = adornPart
	adorn.Visible = true
	adorn.Transparency = 0
	adorn.Name = "HighScalabilityStamperLine"
	adorn.Archivable = false

	local HighScalabilityLine = {}
	HighScalabilityLine.Start = nil
	HighScalabilityLine.End = nil
	HighScalabilityLine.Adorn = adorn
	HighScalabilityLine.AdornPart = adornPart
	HighScalabilityLine.InternalLine = nil
	HighScalabilityLine.NewHint = true

	HighScalabilityLine.MorePoints = {nil, nil}
	HighScalabilityLine.MoreLines = {nil, nil}
	HighScalabilityLine.Dimensions = 1

	local control = {}
	local movingLock = false
	local stampUpLock = false
	local unstampableSurface = false
	local mouseCons = {}
	local keyCon = nil

	local stamped = Instance.new("BoolValue")
	stamped.Archivable = false
	stamped.Value = false

	local lastTarget = {}
	lastTarget.TerrainOrientation = 0
	lastTarget.CFrame = 0

	local cellInfo = {}
	cellInfo.Material = 1
	cellInfo.clusterType = 0
	cellInfo.clusterOrientation = 0

	local function isMegaClusterPart()
		if not stampData then return false end
		if not stampData.CurrentParts then return false end

		return ( stampData.CurrentParts:FindFirstChild("ClusterMaterial",true) or (stampData.CurrentParts.Name == "MegaClusterCube") )
	end

	local function DoHighScalabilityRegionSelect()
		local megaCube = stampData.CurrentParts:FindFirstChild("MegaClusterCube")
		if not megaCube then
			if not stampData.CurrentParts.Name == "MegaClusterCube" then
				return
			else
				megaCube = stampData.CurrentParts
			end
		end

		HighScalabilityLine.End = megaCube.CFrame.p
		local line = nil
		local line2 = Vector3.new(0, 0, 0)
		local line3 = Vector3.new(0, 0, 0)

		if HighScalabilityLine.Dimensions == 1 then
			-- extract the line from these positions and limit to a 2D plane made from 2 of the world axes
			--   then use dominating axis to limit line to be at 45-degree intervals
			--   will use this internal representation of the line for the actual stamping
			line = (HighScalabilityLine.End - HighScalabilityLine.Start)

			if math.abs(line.X) < math.abs(line.Y) then
				if math.abs(line.X) < math.abs(line.Z) then
					-- limit to Y/Z plane, domination unknown
					local newY, newZ
					if (math.abs(line.Y) > math.abs(line.Z)) then
						newY, newZ = truncateToCircleEighth(line.Y, line.Z)
					else
						newZ, newY = truncateToCircleEighth(line.Z, line.Y)
					end
					line = Vector3.new(0, newY, newZ)
				else
					-- limit to X/Y plane, with Y dominating
					local newY, newX = truncateToCircleEighth(line.Y, line.X)
					line = Vector3.new(newX, newY, 0)
				end
			else
				if math.abs(line.Y) < math.abs(line.Z) then
					-- limit to X/Z plane, domination unknown
					local newX, newZ
					if math.abs(line.X) > math.abs(line.Z) then
						newX, newZ = truncateToCircleEighth(line.X, line.Z)
					else
						newZ, newX = truncateToCircleEighth(line.Z, line.X)
					end
					line = Vector3.new(newX, 0, newZ)
				else
					-- limit to X/Y plane, with X dominating
					local newX, newY = truncateToCircleEighth(line.X, line.Y)
					line = Vector3.new(newX, newY, 0)
				end
			end
			HighScalabilityLine.InternalLine = line

		elseif HighScalabilityLine.Dimensions == 2 then
			line = HighScalabilityLine.MoreLines[1]
			line2 = HighScalabilityLine.End - HighScalabilityLine.MorePoints[1]

			-- take out any component of line2 along line1, so you get perpendicular to line1 component
			line2 = line2 - line.unit*line.unit:Dot(line2)

			local tempCFrame = CFrame.new(HighScalabilityLine.Start, HighScalabilityLine.Start + line)

			-- then zero out whichever is the smaller component
			local yAxis = tempCFrame:vectorToWorldSpace(Vector3.new(0, 1, 0))
			local xAxis = tempCFrame:vectorToWorldSpace(Vector3.new(1, 0, 0))

			local xComp = xAxis:Dot(line2)
			local yComp = yAxis:Dot(line2)

			if math.abs(yComp) > math.abs(xComp) then
				line2 = line2 - xAxis * xComp
			else
				line2 = line2 - yAxis * yComp
			end

			HighScalabilityLine.InternalLine = line2

		elseif HighScalabilityLine.Dimensions == 3 then
			line  = HighScalabilityLine.MoreLines[1]
			line2 = HighScalabilityLine.MoreLines[2]
			line3 = HighScalabilityLine.End - HighScalabilityLine.MorePoints[2]

			-- zero out all components of previous lines
			line3 = line3 - line.unit * line.unit:Dot(line3)
			line3 = line3 - line2.unit * line2.unit:Dot(line3)

			HighScalabilityLine.InternalLine = line3
		end

		-- resize the "line" graphic to be the correct size and orientation
		local tempCFrame = CFrame.new(HighScalabilityLine.Start, HighScalabilityLine.Start + line)

		if HighScalabilityLine.Dimensions == 1 then  -- faster calculation for line
			HighScalabilityLine.AdornPart.Size = Vector3.new(4, 4, line.magnitude + 4)
			HighScalabilityLine.AdornPart.CFrame = tempCFrame + tempCFrame:vectorToWorldSpace(Vector3.new(2, 2, 2) - HighScalabilityLine.AdornPart.Size/2)
		else
			local boxSize = tempCFrame:vectorToObjectSpace(line + line2 + line3)
			HighScalabilityLine.AdornPart.Size = Vector3.new(4, 4, 4) + Vector3.new(math.abs(boxSize.X), math.abs(boxSize.Y), math.abs(boxSize.Z))
			HighScalabilityLine.AdornPart.CFrame = tempCFrame + tempCFrame:vectorToWorldSpace(boxSize/2)
		end

		-- make player able to see this ish

		local gui = nil
		if game:GetService("Players")["LocalPlayer"] then
			gui = game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui")
			if gui and gui:IsA("PlayerGui") then
				if HighScalabilityLine.Dimensions == 1 and line.magnitude > 3 then -- don't show if mouse hasn't moved enough
					HighScalabilityLine.Adorn.Parent = gui
				elseif HighScalabilityLine.Dimensions > 1 then
					HighScalabilityLine.Adorn.Parent = gui
				end
			end
		end

		if gui == nil then -- we are in studio
			gui = game:GetService("CoreGui")
			if HighScalabilityLine.Dimensions == 1 and line.magnitude > 3 then -- don't show if mouse hasn't moved enough
				HighScalabilityLine.Adorn.Parent = gui
			elseif HighScalabilityLine.Dimensions > 1 then
				HighScalabilityLine.Adorn.Parent = gui
			end
		end
	end


	local function DoStamperMouseMove(Mouse)
		if not Mouse then
			error("Error: RbxStamper.DoStamperMouseMove: Mouse is nil")
			return
		end
		if not Mouse:IsA("Mouse") then
			error("Error: RbxStamper.DoStamperMouseMove: Mouse is of type", Mouse.className,"should be of type Mouse")
			return
		end

		-- There wasn't a target (no part or terrain), so check for plane intersection.
		if not Mouse.Target then
			local cellPos = GetTerrainForMouse(Mouse)
			if nil == cellPos then
				return
			end
		end

		if not stampData then
			return
		end

		-- don't move with dragger - will move in one step on mouse down
		-- draw ghost at acceptable positions
		local configFound, targetCFrame, targetSurface = findConfigAtMouseTarget(Mouse, stampData)
		if not configFound then
			error("RbxStamper.DoStamperMouseMove No configFound, returning")
			return
		end

		local numRotations = 0 -- update this according to how many rotations you need to get it to target surface
		if autoAlignToFace(stampData.CurrentParts) and targetSurface ~= 1 and targetSurface ~= 4 then -- pre-rotate the flag or portrait so it's aligned correctly
			if		targetSurface == 3 then numRotations = 0 - gInitial90DegreeRotations + autoAlignToFace(stampData.CurrentParts)
			elseif	targetSurface == 0 then numRotations = 2 - gInitial90DegreeRotations + autoAlignToFace(stampData.CurrentParts)
			elseif	targetSurface == 5 then numRotations = 3 - gInitial90DegreeRotations + autoAlignToFace(stampData.CurrentParts)
			elseif	targetSurface == 2 then numRotations = 1 - gInitial90DegreeRotations + autoAlignToFace(stampData.CurrentParts)
			end
		end

		local ry = math.pi/2
		gInitial90DegreeRotations = gInitial90DegreeRotations + numRotations
		if stampData.CurrentParts:IsA("Model") or stampData.CurrentParts:IsA("Tool") then
			--stampData.CurrentParts:Rotate(0, ry*numRotations, 0)
			modelRotate(stampData.CurrentParts, ry*numRotations)
		else
			stampData.CurrentParts.CFrame = CFrame.fromEulerAnglesXYZ(0, ry*numRotations, 0) * stampData.CurrentParts.CFrame
		end

		-- CODE TO CHECK FOR DRAGGING GHOST PART INTO A COLLIDING STATE
		local minBB, maxBB = getBoundingBoxInWorldCoordinates(stampData.CurrentParts)

		-- need to offset by distance to be dragged
		local currModelCFrame = nil
		if stampData.CurrentParts:IsA("Model") then
			currModelCFrame = stampData.CurrentParts:GetModelCFrame()
		else
			currModelCFrame = stampData.CurrentParts.CFrame
		end

		minBB = minBB + targetCFrame.p - currModelCFrame.p
		maxBB = maxBB + targetCFrame.p - currModelCFrame.p

		-- don't drag into terrain
		if clusterPartsInRegion(minBB + insertBoundingBoxOverlapVector, maxBB - insertBoundingBoxOverlapVector) then
			if lastTarget.CFrame then
				if (stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)) then
					local theClusterMaterial = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
					if theClusterMaterial:IsA("Vector3Value") then
						local stampClusterMaterial = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
						if stampClusterMaterial then
							stampClusterMaterial = theClusterMaterial
						end
					end
				end
			end
			return
		end

		-- if we are stamping a terrain part, make sure it goes on the grid! Otherwise preview block could be placed off grid, but stamped on grid
		if isMegaClusterPart() then
			local cellToStamp = game:GetService("Workspace").Terrain:WorldToCell(targetCFrame.p)
			local newCFramePosition = game:GetService("Workspace").Terrain:CellCenterToWorld(cellToStamp.X, cellToStamp.Y, cellToStamp.Z)
			local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = targetCFrame:components()
			targetCFrame = CFrame.new(newCFramePosition.X,newCFramePosition.Y,newCFramePosition.Z,R00, R01, R02, R10, R11, R12, R20, R21, R22)
		end

		positionPartsAtCFrame3(targetCFrame, stampData.CurrentParts)
		lastTarget.CFrame = targetCFrame  -- successful positioning, so update 'dat cframe
		if stampData.CurrentParts:FindFirstChild("ClusterMaterial", true) then
			local clusterMat = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
			if clusterMat:IsA("Vector3Value") then
				lastTarget.TerrainOrientation = clusterMat.Value.Z
			end
		end


		-- auto break joints code
		if Mouse and Mouse.Target and Mouse.Target.Parent then
			local modelInfo = Mouse.Target:FindFirstChild("RobloxModel")
			if not modelInfo then modelInfo = Mouse.Target.Parent:FindFirstChild("RobloxModel") end

			local myModelInfo = stampData.CurrentParts:FindFirstChild("UnstampableFaces")

			--if (modelInfo and modelInfo.Parent:FindFirstChild("UnstampableFaces")) or (modelInfo and myModelInfo) then  -- need better targetSurface calcs
			if (true) then
				local breakingFaces = ""
				local myBreakingFaces = ""
				if modelInfo and modelInfo.Parent:FindFirstChild("UnstampableFaces") then breakingFaces = modelInfo.Parent.UnstampableFaces.Value end
				if myModelInfo then myBreakingFaces = myModelInfo.Value end
				local hitFace = 0

				if modelInfo then hitFace = modelTargetSurface(modelInfo.Parent, game:GetService("Workspace").CurrentCamera.CoordinateFrame.p, Mouse.Hit.p) end

				-- are we stamping TO an unstampable surface?
				for bf in string.gmatch(breakingFaces, "[^,]+") do
					if hitFace == tonumber(bf) then
						-- return before we hit the JointsService code below!
						unstampableSurface = true
						game:GetService("JointsService"):ClearJoinAfterMoveJoints() -- clear the JointsService cache
						return
					end
				end

				-- now we have to cast the ray back in the other direction to find the surface we're stamping FROM
				hitFace = modelTargetSurface(stampData.CurrentParts, Mouse.Hit.p, game:GetService("Workspace").CurrentCamera.CoordinateFrame.p)

				-- are we stamping WITH an unstampable surface?
				for bf in string.gmatch(myBreakingFaces, "[^,]+") do
					if hitFace == tonumber(bf) then
						unstampableSurface = true
						game:GetService("JointsService"):ClearJoinAfterMoveJoints() -- clear the JointsService cache
						return
					end
				end

				-- just need to match breakingFace against targetSurface using rotation supplied by modelCFrame
				-- targetSurface: 1 is top, 4 is bottom,
			end
		end

		-- to show joints during the mouse move
		unstampableSurface = false
		game:GetService("JointsService"):SetJoinAfterMoveInstance(stampData.CurrentParts)

		-- most common mouse inactive error occurs here, so check mouse active one more time in a pcall
		if not pcall(function()
				if Mouse and Mouse.Target and Mouse.Target.Parent:FindFirstChild("RobloxModel") == nil then
					return
				else
					return
				end
			end)
		then
			error("Error: RbxStamper.DoStamperMouseMove Mouse is nil on second check")
			game:GetService("JointsService"):ClearJoinAfterMoveJoints()
			Mouse = nil
			return
		end

		if Mouse and Mouse.Target and Mouse.Target.Parent:FindFirstChild("RobloxModel") == nil then
			game:GetService("JointsService"):SetJoinAfterMoveTarget(Mouse.Target)
		else
			game:GetService("JointsService"):SetJoinAfterMoveTarget(nil)
		end
		game:GetService("JointsService"):ShowPermissibleJoints()

		-- here we allow for a line of high-scalability parts
		if isMegaClusterPart() and HighScalabilityLine and HighScalabilityLine.Start then
				DoHighScalabilityRegionSelect()
		end
	end

	local function setupKeyListener(key, Mouse)
		if control and control["Paused"] then return end -- don't do this if we have no stamp

		key = string.lower(key)
		if key == 'r' and not autoAlignToFace(stampData.CurrentParts) then -- rotate the model
			gInitial90DegreeRotations = gInitial90DegreeRotations + 1

			-- Update orientation value if this is a fake terrain part
			local clusterValues = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
			if clusterValues and clusterValues:IsA("Vector3Value") then
				clusterValues.Value = Vector3.new(clusterValues.Value.X, clusterValues.Value.Y, (clusterValues.Value.Z + 1) % 4)
			end

			-- Rotate the parts or all the parts in the model
			local ry = math.pi/2
			if stampData.CurrentParts:IsA("Model") or stampData.CurrentParts:IsA("Tool") then
				--stampData.CurrentParts:Rotate(0, ry, 0)
				modelRotate(stampData.CurrentParts, ry)
			else
				stampData.CurrentParts.CFrame = CFrame.fromEulerAnglesXYZ(0, ry, 0) * stampData.CurrentParts.CFrame
			end

			-- After rotating, update the position
			configFound, targetCFrame = findConfigAtMouseTarget(Mouse, stampData)
			if configFound then
				positionPartsAtCFrame3(targetCFrame, stampData.CurrentParts)

				-- update everything else in MouseMove
				DoStamperMouseMove(Mouse)
			end
		elseif key == 'c' then -- try to expand our high scalability dragger dimension
			if HighScalabilityLine.InternalLine and HighScalabilityLine.InternalLine.magnitude > 0 and HighScalabilityLine.Dimensions < 3 then
				HighScalabilityLine.MorePoints[HighScalabilityLine.Dimensions] = HighScalabilityLine.End
				HighScalabilityLine.MoreLines[HighScalabilityLine.Dimensions] = HighScalabilityLine.InternalLine
				HighScalabilityLine.Dimensions = HighScalabilityLine.Dimensions + 1
				HighScalabilityLine.NewHint = true
			end
		end
	end

	keyCon = Mouse.KeyDown:connect(function(key) -- init key connection (keeping code close to func)
		setupKeyListener(key, Mouse)
	end)

	local function resetHighScalabilityLine()
		if HighScalabilityLine then
			HighScalabilityLine.Start = nil
			HighScalabilityLine.End = nil
			HighScalabilityLine.InternalLine = nil
			HighScalabilityLine.NewHint = true
		end
	end

	local function flashRedBox()
		local gui = game:GetService("CoreGui")
		if game:GetService("Players") then
			if game:GetService("Players")["LocalPlayer"] then
				if game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui") then
					gui = game:GetService("Players").LocalPlayer.PlayerGui
				end
			end
		end
		if not stampData["ErrorBox"] then return end

		stampData.ErrorBox.Parent = gui
		if stampData.CurrentParts:IsA("Tool") then
			stampData.ErrorBox.Adornee = stampData.CurrentParts.Handle
		else
			stampData.ErrorBox.Adornee = stampData.CurrentParts
		end

		delay(0,function()
			for i = 1, 3 do
				if stampData["ErrorBox"] then stampData.ErrorBox.Visible = true end
				wait(0.13)
				if stampData["ErrorBox"] then stampData.ErrorBox.Visible = false end
				wait(0.13)
			end
			if stampData["ErrorBox"] then
				stampData.ErrorBox.Adornee = nil
				stampData.ErrorBox.Parent = nil
			end
		end)
	end

	local function DoStamperMouseDown(Mouse)
		if not Mouse then
			error("Error: RbxStamper.DoStamperMouseDown: Mouse is nil")
			return
		end
		if not Mouse:IsA("Mouse") then
			error("Error: RbxStamper.DoStamperMouseDown: Mouse is of type", Mouse.className,"should be of type Mouse")
			return
		end
		if not stampData then
			return
		end

		if isMegaClusterPart() then
			if Mouse and HighScalabilityLine then
				local megaCube = stampData.CurrentParts:FindFirstChild("MegaClusterCube", true)
				local terrain = game:GetService("Workspace").Terrain
				if megaCube then
					HighScalabilityLine.Dimensions = 1
					local tempCell = terrain:WorldToCell(megaCube.CFrame.p)
					HighScalabilityLine.Start = terrain:CellCenterToWorld(tempCell.X, tempCell.Y, tempCell.Z)
					return
				else
					HighScalabilityLine.Dimensions = 1
					local tempCell = terrain:WorldToCell(stampData.CurrentParts.CFrame.p)
					HighScalabilityLine.Start = terrain:CellCenterToWorld(tempCell.X, tempCell.Y, tempCell.Z)
					return
				end
			end
		end
	end

	local function loadSurfaceTypes(part, surfaces)
		part.TopSurface = surfaces[1]
		part.BottomSurface = surfaces[2]
		part.LeftSurface = surfaces[3]
		part.RightSurface = surfaces[4]
		part.FrontSurface = surfaces[5]
		part.BackSurface = surfaces[6]
	end

	local function saveSurfaceTypes(part, myTable)
		local tempTable = {}
		tempTable[1] = part.TopSurface
		tempTable[2] = part.BottomSurface
		tempTable[3] = part.LeftSurface
		tempTable[4] = part.RightSurface
		tempTable[5] = part.FrontSurface
		tempTable[6] = part.BackSurface

		myTable[part] = tempTable
	end

	local function makeSurfaceUnjoinable(part, surface)
		-- TODO: FILL OUT!
	end

	local function prepareModel(model)
		if not model then return nil end

		local gDesiredTrans = 0.7
		local gStaticTrans = 1

		local clone = model:Clone()
		local scripts = {}
		local parts = {}
		local decals = {}

		stampData = {}
		stampData.DisabledScripts = {}
		stampData.TransparencyTable = {}
		stampData.MaterialTable = {}
		stampData.CanCollideTable = {}
		stampData.AnchoredTable = {}
		stampData.ArchivableTable = {}
		stampData.DecalTransparencyTable = {}
		stampData.SurfaceTypeTable = {}

		collectParts(clone, parts, scripts, decals)

		if #parts <= 0 then return nil, "no parts found in modelToStamp" end

		for index,script in pairs(scripts) do
			if not(script.Disabled) then
				script.Disabled = true
				stampData.DisabledScripts[#stampData.DisabledScripts + 1] = script
			end
		end
		for index, part in pairs(parts) do
			stampData.TransparencyTable[part] = part.Transparency
			part.Transparency = gStaticTrans + (1 - gStaticTrans) * part.Transparency
			stampData.MaterialTable[part] = part.Material
			part.Material = Enum.Material.Plastic
			stampData.CanCollideTable[part] = part.CanCollide
			part.CanCollide = false
			stampData.AnchoredTable[part] = part.Anchored
			part.Anchored = true
			stampData.ArchivableTable[part] = part.Archivable
			part.Archivable = false

			saveSurfaceTypes(part, stampData.SurfaceTypeTable)

			local fadeInDelayTime = 0.5
			local transFadeInTime = 0.5
			delay(0,function()
				wait(fadeInDelayTime) -- give it some time to be completely transparent

				local begTime = tick()
				local currTime = begTime
				while (currTime - begTime) < transFadeInTime and part and part:IsA("BasePart") and part.Transparency > gDesiredTrans do
					local newTrans = 1 - (((currTime - begTime)/transFadeInTime) * (gStaticTrans - gDesiredTrans))
					if stampData["TransparencyTable"] and stampData.TransparencyTable[part] then
						part.Transparency = newTrans + (1 - newTrans) * stampData.TransparencyTable[part]
					end
					wait(0.03)
					currTime = tick()
				end
				if part and part:IsA("BasePart") then
					if stampData["TransparencyTable"] and stampData.TransparencyTable[part] then
						part.Transparency = gDesiredTrans + (1 - gDesiredTrans) * stampData.TransparencyTable[part]
					end
				end
			end)
		end

		for index, decal in pairs(decals) do
			stampData.DecalTransparencyTable[decal] = decal.Transparency
			decal.Transparency = gDesiredTrans + (1 - gDesiredTrans) * decal.Transparency
		end

		-- disable all seats
		setSeatEnabledStatus(clone, true)
		setSeatEnabledStatus(clone, false)

		stampData.CurrentParts = clone

		-- if auto-alignable, we enforce a pre-rotation to the canonical "0-frame"
		if autoAlignToFace(clone) then
			stampData.CurrentParts:ResetOrientationToIdentity()
			gInitial90DegreeRotations = 0
		else -- pre-rotate if necessary
			local ry = gInitial90DegreeRotations * math.pi/2
			if stampData.CurrentParts:IsA("Model") or stampData.CurrentParts:IsA("Tool") then
				--stampData.CurrentParts:Rotate(0, ry, 0)
				modelRotate(stampData.CurrentParts, ry)
			else
				stampData.CurrentParts.CFrame = CFrame.fromEulerAnglesXYZ(0, ry, 0) * stampData.CurrentParts.CFrame
			end
		end

		-- since we're cloning the old model instead of the new one, we will need to update the orientation based on the original value AND how many more
		--  rotations we expect since then [either that or we need to store the just-stamped clusterMaterial.Value.Z somewhere].  This should fix the terrain rotation
		--  issue (fingers crossed) [HotThoth]

		local clusterMaterial = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
		if clusterMaterial and clusterMaterial:IsA("Vector3Value") then
			clusterMaterial.Value = Vector3.new(clusterMaterial.Value.X, clusterMaterial.Value.Y, (clusterMaterial.Value.Z + gInitial90DegreeRotations) % 4)
		end

		-- After rotating, update the position
		local configFound, targetCFrame = findConfigAtMouseTarget(Mouse, stampData)
		if configFound then
			stampData.CurrentParts = positionPartsAtCFrame3(targetCFrame, stampData.CurrentParts)
		end

		-- to show joints during the mouse move
		game:GetService("JointsService"):SetJoinAfterMoveInstance(stampData.CurrentParts)

		return clone, parts
	end

	local function checkTerrainBlockCollisions(cellPos, checkHighScalabilityStamp)
		local cellCenterToWorld = game:GetService("Workspace").Terrain.CellCenterToWorld
		local cellCenter = cellCenterToWorld(game:GetService("Workspace").Terrain, cellPos.X, cellPos.Y, cellPos.Z)
		local cellBlockingParts = game:GetService("Workspace"):FindPartsInRegion3(Region3.new(cellCenter - Vector3.new(2, 2, 2) + insertBoundingBoxOverlapVector, cellCenter + Vector3.new(2, 2, 2) - insertBoundingBoxOverlapVector), stampData.CurrentParts,	100)

		local skipThisCell = false

		for b = 1, #cellBlockingParts do
			if isBlocker(cellBlockingParts[b]) then skipThisCell = true break end
		end

		if not skipThisCell then
			-- pop players up above any set cells
			local alreadyPushedUp = {}
			-- if no blocking model below, then see if stamping on top of a character
			for b = 1, #cellBlockingParts do
				if	cellBlockingParts[b].Parent and
					not alreadyPushedUp[cellBlockingParts[b].Parent] and
					cellBlockingParts[b].Parent:FindFirstChild("Humanoid") and
					cellBlockingParts[b].Parent:FindFirstChild("Humanoid"):IsA("Humanoid") then
				-----------------------------------------------------------------------------------
						local blockingPersonTorso = cellBlockingParts[b].Parent:FindFirstChild("Torso")
						alreadyPushedUp[cellBlockingParts[b].Parent] = true

						if blockingPersonTorso then
							-- if so, let's push the person upwards so they pop on top of the stamped model/part (but only if there's space above them)
							local newY = cellCenter.Y + 5
							if spaceAboveCharacter(blockingPersonTorso, newY, stampData) then
								blockingPersonTorso.CFrame = blockingPersonTorso.CFrame + Vector3.new(0, newY - blockingPersonTorso.CFrame.p.Y, 0)
							else
								-- if no space, we just skip this one
								skipThisCell = true
								break
							end
						end
				-----------------------------------------------------------------------------------
				end
			end
		end

		if not skipThisCell then  -- if we STILL aren't skipping...  then we're good to go!
			local canSetCell = true

			if checkHighScalabilityStamp then -- check to see if cell is in region, if not we'll skip set
				if allowedStampRegion then
					local cellPos = cellCenterToWorld(game:GetService("Workspace").Terrain, cellPos.X, cellPos.Y, cellPos.Z)
					if cellPos.X + 2 > allowedStampRegion.CFrame.p.X + allowedStampRegion.Size.X/2 then
						canSetCell = false
					elseif cellPos.X - 2 < allowedStampRegion.CFrame.p.X - allowedStampRegion.Size.X/2 then
						canSetCell = false
					elseif cellPos.Y + 2 > allowedStampRegion.CFrame.p.Y + allowedStampRegion.Size.Y/2 then
						canSetCell = false
					elseif cellPos.Y - 2 < allowedStampRegion.CFrame.p.Y - allowedStampRegion.Size.Y/2 then
						canSetCell = false
					elseif cellPos.Z + 2 > allowedStampRegion.CFrame.p.Z + allowedStampRegion.Size.Z/2 then
						canSetCell = false
					elseif cellPos.Z - 2 < allowedStampRegion.CFrame.p.Z - allowedStampRegion.Size.Z/2 then
						canSetCell = false
					end
				end
			end

			return canSetCell
		end
		return false
	end


	local function ResolveMegaClusterStamp(checkHighScalabilityStamp)
		local cellSet = false

		local cluser = game:GetService("Workspace").Terrain

		local line = HighScalabilityLine.InternalLine
		local cMax = game:GetService("Workspace").Terrain.MaxExtents.Max
		local cMin = game:GetService("Workspace").Terrain.MaxExtents.Min

		local clusterMaterial = 1 -- default is grass
		local clusterType = 0 -- default is brick
		local clusterOrientation = 0 -- default is 0 rotation

		local autoWedgeClusterParts = false
		if stampData.CurrentParts:FindFirstChild("AutoWedge") then autoWedgeClusterParts = true end

		if stampData.CurrentParts:FindFirstChild("ClusterMaterial", true) then
			clusterMaterial = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
			if clusterMaterial:IsA("Vector3Value") then
				clusterType = clusterMaterial.Value.Y
				clusterOrientation = clusterMaterial.Value.Z
				clusterMaterial = clusterMaterial.Value.X
			elseif clusterMaterial:IsA("IntValue") then
				clusterMaterial = clusterMaterial.Value
			end
		end

		if HighScalabilityLine.Adorn.Parent and HighScalabilityLine.Start and ((HighScalabilityLine.Dimensions > 1) or (line and line.magnitude > 0)) then
			local startCell = game:GetService("Workspace").Terrain:WorldToCell(HighScalabilityLine.Start)
			local xInc = {0,0,0}
			local yInc = {0,0,0}
			local zInc = {0,0,0}

			local cluster = game:GetService("Workspace").Terrain

			local incrementVect = {nil, nil, nil}
			local stepVect = {Vector3.new(0, 0, 0), Vector3.new(0, 0, 0), Vector3.new(0, 0, 0)}

			local worldAxes = {Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1)}

			local lines = {}
			if HighScalabilityLine.Dimensions > 1 then table.insert(lines, HighScalabilityLine.MoreLines[1]) end
			if line and line.magnitude > 0 then table.insert(lines, line) end
			if HighScalabilityLine.Dimensions > 2 then table.insert(lines, HighScalabilityLine.MoreLines[2]) end

			for i = 1, #lines do
				lines[i] = Vector3.new(math.floor(lines[i].X+.5), math.floor(lines[i].Y+.5), math.floor(lines[i].Z+.5)) -- round to integers

				if lines[i].X > 0 then xInc[i] = 1 elseif lines[i].X < 0 then xInc[i] = -1 end
				if lines[i].Y > 0 then yInc[i] = 1 elseif lines[i].Y < 0 then yInc[i] = -1 end
				if lines[i].Z > 0 then zInc[i] = 1 elseif lines[i].Z < 0 then zInc[i] = -1 end

				incrementVect[i] = Vector3.new(xInc[i], yInc[i], zInc[i])
				if incrementVect[i].magnitude < .9 then incrementVect[i] = nil end
			end


			if not lines[2] then lines[2] = Vector3.new(0, 0, 0) end
			if not lines[3] then lines[3] = Vector3.new(0, 0, 0) end

			local waterForceTag = stampData.CurrentParts:FindFirstChild("WaterForceTag", true)
			local waterForceDirectionTag = stampData.CurrentParts:FindFirstChild("WaterForceDirectionTag", true)

			while (stepVect[3].magnitude*4 <= lines[3].magnitude) do
				local outerStepVectIndex = 1
				while outerStepVectIndex < 4 do
					stepVect[2] = Vector3.new(0, 0, 0)
					while (stepVect[2].magnitude*4 <= lines[2].magnitude) do
						local innerStepVectIndex = 1
						while innerStepVectIndex < 4 do
							stepVect[1] = Vector3.new(0, 0, 0)
							while (stepVect[1].magnitude*4 <= lines[1].magnitude) do
								local stepVectSum = stepVect[1] + stepVect[2] + stepVect[3]
								local cellPos = Vector3int16.new(startCell.X + stepVectSum.X, startCell.Y + stepVectSum.Y, startCell.Z + stepVectSum.Z)
								if cellPos.X >= cMin.X and cellPos.Y >= cMin.Y and cellPos.Z >= cMin.Z and cellPos.X < cMax.X and cellPos.Y < cMax.Y and cellPos.Z < cMax.Z then
									-- check if overlaps player or part
									local okToStampTerrainBlock = checkTerrainBlockCollisions(cellPos, checkHighScalabilityStamp)

									if okToStampTerrainBlock then
										if waterForceTag then
											cluster:SetWaterCell(cellPos.X, cellPos.Y, cellPos.Z, Enum.WaterForce[waterForceTag.Value], Enum.WaterDirection[waterForceDirectionTag.Value])
										else
											cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, clusterMaterial, clusterType, clusterOrientation)
										end
										cellSet = true

										-- auto-wedge it?
										if (autoWedgeClusterParts) then
											game:GetService("Workspace").Terrain:AutowedgeCells(Region3int16.new(Vector3int16.new(cellPos.x - 1, cellPos.y - 1, cellPos.z - 1),
												Vector3int16.new(cellPos.x + 1, cellPos.y + 1, cellPos.z + 1)))
										end
									end
								end
								stepVect[1] = stepVect[1] + incrementVect[1]
							end
							if incrementVect[2] then
								while innerStepVectIndex < 4 and worldAxes[innerStepVectIndex]:Dot(incrementVect[2]) == 0 do
									innerStepVectIndex = innerStepVectIndex + 1
								end
								if innerStepVectIndex < 4 then
									stepVect[2] = stepVect[2] + worldAxes[innerStepVectIndex] * worldAxes[innerStepVectIndex]:Dot(incrementVect[2])
								end
								innerStepVectIndex = innerStepVectIndex + 1
							else
								stepVect[2] = Vector3.new(1, 0, 0)
								innerStepVectIndex = 4 -- skip all remaining loops
							end
							if (stepVect[2].magnitude*4 > lines[2].magnitude) then innerStepVectIndex = 4 end
						end
					end
					if incrementVect[3] then
						while outerStepVectIndex < 4 and worldAxes[outerStepVectIndex]:Dot(incrementVect[3]) == 0 do
							outerStepVectIndex = outerStepVectIndex + 1
						end
						if outerStepVectIndex < 4 then
							stepVect[3] = stepVect[3] + worldAxes[outerStepVectIndex] * worldAxes[outerStepVectIndex]:Dot(incrementVect[3])
						end
						outerStepVectIndex = outerStepVectIndex + 1
					else -- skip all remaining loops
						stepVect[3] = Vector3.new(1, 0, 0) outerStepVectIndex = 4
					end
					if (stepVect[3].magnitude*4 > lines[3].magnitude) then outerStepVectIndex = 4 end
				end
			end
		end

		-- and also get rid of any HighScalabilityLine stuff if it's there
		HighScalabilityLine.Start = nil
		HighScalabilityLine.Adorn.Parent = nil

		-- Mark for undo.
		if cellSet then
			stampData.CurrentParts.Parent = nil
			pcall(function() game:GetService("ChangeHistoryService"): SetWaypoint("StamperMulti") end)
		end

		return cellSet
	end

	local function DoStamperMouseUp(Mouse)
		if not Mouse then
			error("Error: RbxStamper.DoStamperMouseUp: Mouse is nil")
			return false
		end
		if not Mouse:IsA("Mouse") then
			error("Error: RbxStamper.DoStamperMouseUp: Mouse is of type", Mouse.className,"should be of type Mouse")
			return false
		end

		if not stampData.Dragger then
			error("Error: RbxStamper.DoStamperMouseUp: stampData.Dragger is nil")
			return false
		end

		if not HighScalabilityLine then
			return false
		end

		local checkHighScalabilityStamp = nil
		if stampInModel then
			local canStamp = nil
			local isHSLPart = isMegaClusterPart()

			if isHSLPart and
				HighScalabilityLine and
				HighScalabilityLine.Start and
				HighScalabilityLine.InternalLine and
				HighScalabilityLine.InternalLine.magnitude > 0 then -- we have an HSL line, test later
					canStamp = true
					checkHighScalabilityStamp = true
			else
				canStamp, checkHighScalabilityStamp = t.CanEditRegion(stampData.CurrentParts, allowedStampRegion)
			end

			if not canStamp then
				if stampFailedFunc then
					stampFailedFunc()
				end
				return false
			end
		end

		-- if unstampable face, then don't let us stamp there!
		if unstampableSurface then
			flashRedBox()
			return false
		end

		-- recheck if we can stamp, as we just moved part
		local canStamp, checkHighScalabilityStamp = t.CanEditRegion(stampData.CurrentParts, allowedStampRegion)
		if not canStamp then
			if stampFailedFunc then
				stampFailedFunc()
			end
			return false
		end

		-- Prevent part from being stamped on top of a player

		local minBB, maxBB = getBoundingBoxInWorldCoordinates(stampData.CurrentParts)

		-- HotThoth's note:  Now that above CurrentParts positioning has been commented out, to be truly correct, we would need to use the
		--                     value of configFound from the previous onStamperMouseMove call which moved the CurrentParts
		--                     Shouldn't this be true when lastTargetCFrame has been set and false otherwise?
		configFound, targetCFrame = findConfigAtMouseTarget(Mouse, stampData)

		if configFound and not HighScalabilityLine.Adorn.Parent then
			if clusterPartsInRegion(minBB + insertBoundingBoxOverlapVector, maxBB - insertBoundingBoxOverlapVector) then
				flashRedBox()
				return false
			end

			local blockingParts = game:GetService("Workspace"):FindPartsInRegion3(Region3.new(minBB + insertBoundingBoxOverlapVector,
																	maxBB - insertBoundingBoxOverlapVector),
																	stampData.CurrentParts,
																	100)


			for b = 1, #blockingParts do
				if isBlocker(blockingParts[b]) then
					flashRedBox()
					return false
				end
			end

			local alreadyPushedUp = {}
				-- if no blocking model below, then see if stamping on top of a character
				for b = 1, #blockingParts do
					if	blockingParts[b].Parent and
						not alreadyPushedUp[blockingParts[b].Parent] and
						blockingParts[b].Parent:FindFirstChild("Humanoid") and
						blockingParts[b].Parent:FindFirstChild("Humanoid"):IsA("Humanoid") then
					---------------------------------------------------------------------------
							local blockingPersonTorso = blockingParts[b].Parent:FindFirstChild("Torso")
							alreadyPushedUp[blockingParts[b].Parent] = true

							if blockingPersonTorso then
								-- if so, let's push the person upwards so they pop on top of the stamped model/part (but only if there's space above them)
								local newY = maxBB.Y + 3
								if spaceAboveCharacter(blockingPersonTorso, newY, stampData) then
									blockingPersonTorso.CFrame = blockingPersonTorso.CFrame + Vector3.new(0, newY - blockingPersonTorso.CFrame.p.Y, 0)
								else
									-- if no space, we just error
									flashRedBox()
									return false
								end
							end
					---------------------------------------------------------------------------
					end
				end

		elseif (not configFound) and not (HighScalabilityLine.Start and HighScalabilityLine.Adorn.Parent) then -- if no config then only stamp if it's a real HSL!
			resetHighScalabilityLine()
			return false
		end

		-- something will be stamped!  so set the "StampedSomething" toggle to true
		if game:GetService("Players")["LocalPlayer"] then
			if game:GetService("Players").LocalPlayer["Character"] then
				local localChar = game:GetService("Players").LocalPlayer.Character
				local stampTracker = localChar:FindFirstChild("StampTracker")
				if stampTracker and not stampTracker.Value then
					stampTracker.Value = true
				end
			end
		end

		-- if we drew a line of mega parts, stamp them out
		if HighScalabilityLine.Start and HighScalabilityLine.Adorn.Parent and isMegaClusterPart() then
			if ResolveMegaClusterStamp(checkHighScalabilityStamp) or checkHighScalabilityStamp then
				-- kill the ghost part
				stampData.CurrentParts.Parent = nil
				return true
			end
		end

		-- not High-Scalability-Line-Based, so behave normally [and get rid of any HSL stuff]
		HighScalabilityLine.Start = nil
		HighScalabilityLine.Adorn.Parent = nil

		local cluster = game:GetService("Workspace").Terrain

		-- if target point is in cluster, just use cluster:SetCell
		if isMegaClusterPart() then
			-- if targetCFrame is inside cluster, just set that cell to 1 and return
			--local cellPos = cluster:WorldToCell(targetCFrame.p)

			local cellPos
			if stampData.CurrentParts:IsA("Model") then cellPos = cluster:WorldToCell(stampData.CurrentParts:GetModelCFrame().p)
			else cellPos = cluster:WorldToCell(stampData.CurrentParts.CFrame.p) end

			local cMax = game:GetService("Workspace").Terrain.MaxExtents.Max
			local cMin = game:GetService("Workspace").Terrain.MaxExtents.Min

			if checkTerrainBlockCollisions(cellPos, false) then

				local clusterValues = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
				local waterForceTag = stampData.CurrentParts:FindFirstChild("WaterForceTag", true)
				local waterForceDirectionTag = stampData.CurrentParts:FindFirstChild("WaterForceDirectionTag", true)

				if cellPos.X >= cMin.X and cellPos.Y >= cMin.Y and cellPos.Z >= cMin.Z and cellPos.X < cMax.X and cellPos.Y < cMax.Y and cellPos.Z < cMax.Z then

					if waterForceTag then
						cluster:SetWaterCell(cellPos.X, cellPos.Y, cellPos.Z, Enum.WaterForce[waterForceTag.Value], Enum.WaterDirection[waterForceDirectionTag.Value])
					elseif not clusterValues then
						cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, cellInfo.Material, cellInfo.clusterType, gInitial90DegreeRotations % 4)
					elseif clusterValues:IsA("Vector3Value") then
						cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, clusterValues.Value.X, clusterValues.Value.Y, clusterValues.Value.Z)
					else
						cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, clusterValues.Value, 0, 0)
					end

					local autoWedgeClusterParts = false
					if stampData.CurrentParts:FindFirstChild("AutoWedge") then autoWedgeClusterParts = true end

					-- auto-wedge it
					if (autoWedgeClusterParts) then
						game:GetService("Workspace").Terrain:AutowedgeCells(
							Region3int16.new(
								Vector3int16.new(cellPos.x - 1, cellPos.y - 1, cellPos.z - 1),
								Vector3int16.new(cellPos.x + 1, cellPos.y + 1, cellPos.z + 1)
							)
						)
					end

					-- kill the ghost part
					stampData.CurrentParts.Parent = nil

					-- Mark for undo.  It has to happen here or the selection display will come back also.
					pcall(function() game:GetService("ChangeHistoryService"):SetWaypoint("StamperSingle") end)
					return true
				end
			else
				-- you tried to stamp a HSL-single part where one does not belong!
				flashRedBox()
				return false
			end
		end

		local function getPlayer()
			if game:GetService("Players")["LocalPlayer"] then
				return game:GetService("Players").LocalPlayer
			end
			return nil
		end


		-- Post process: after positioning the part or model, restore transparency, material, anchored and collide states and create joints
		if stampData.CurrentParts:IsA("Model") or stampData.CurrentParts:IsA("Tool") then
			if stampData.CurrentParts:IsA("Model") then
				-- Tyler's magical hack-code for allowing/preserving clones of both Surface and Manual Welds...  just don't ask X<
				local manualWeldTable = {}
				local manualWeldParentTable = {}
				saveTheWelds(stampData.CurrentParts, manualWeldTable, manualWeldParentTable)
				stampData.CurrentParts:BreakJoints()
				stampData.CurrentParts:MakeJoints()
				restoreTheWelds(manualWeldTable, manualWeldParentTable)
			end

			-- if it's a model, we also want to fill in the playerID and playerName tags, if it has those (e.g. for the friend-only door)
			local playerIdTag = stampData.CurrentParts:FindFirstChild("PlayerIdTag")
			local playerNameTag = stampData.CurrentParts:FindFirstChild("PlayerNameTag")
			if playerIdTag ~= nil then
				local tempPlayerValue = getPlayer()
				if tempPlayerValue ~= nil then playerIdTag.Value = tempPlayerValue.UserId end
			end
			if playerNameTag ~= nil then
				if game:GetService("Players")["LocalPlayer"] then
					local tempPlayerValue = game:GetService("Players").LocalPlayer
					if tempPlayerValue ~= nil then playerNameTag.Value = tempPlayerValue.Name end
				end
			end
			-- ...and tag all inserted models for subsequent origin identification
			-- if no RobloxModel tag already exists, then add it.
			if stampData.CurrentParts:FindFirstChild("RobloxModel") == nil then
				local stringTag = Instance.new("BoolValue", stampData.CurrentParts)
				stringTag.Name = "RobloxModel"

				if stampData.CurrentParts:FindFirstChild("RobloxStamper") == nil then
					local stringTag2 = Instance.new("BoolValue", stampData.CurrentParts)
					stringTag2.Name = "RobloxStamper"
				end
			end

		else
			stampData.CurrentParts:BreakJoints()
			if stampData.CurrentParts:FindFirstChild("RobloxStamper") == nil then
				local stringTag2 = Instance.new("BoolValue", stampData.CurrentParts)
				stringTag2.Name = "RobloxStamper"
			end
		end

		-- make sure all the joints are activated before restoring anchor states
		game:GetService("JointsService"):CreateJoinAfterMoveJoints()

		-- Restore the original properties for all parts being stamped
		for part, transparency in pairs(stampData.TransparencyTable) do
			part.Transparency = transparency
		end
		for part, archivable in pairs(stampData.ArchivableTable) do
			part.Archivable = archivable
		end
		for part, material in pairs(stampData.MaterialTable) do
			part.Material = material
		end
		for part, collide in pairs(stampData.CanCollideTable) do
			part.CanCollide = collide
		end
		for part, anchored in pairs(stampData.AnchoredTable) do
			part.Anchored = anchored
		end
		for decal, transparency in pairs(stampData.DecalTransparencyTable) do
			decal.Transparency = transparency
		end

		for part, surfaces in pairs(stampData.SurfaceTypeTable) do
			loadSurfaceTypes(part, surfaces)
		end

		if isMegaClusterPart() then
			stampData.CurrentParts.Transparency = 0
		end

		-- re-enable all seats
		setSeatEnabledStatus(stampData.CurrentParts, true)

		stampData.TransparencyTable = nil
		stampData.ArchivableTable = nil
		stampData.MaterialTable = nil
		stampData.CanCollideTable = nil
		stampData.AnchoredTable = nil
		stampData.SurfaceTypeTable = nil

		-- ...and tag all inserted models for subsequent origin identification
		-- if no RobloxModel tag already exists, then add it.
		if stampData.CurrentParts:FindFirstChild("RobloxModel") == nil then
			local stringTag = Instance.new("BoolValue", stampData.CurrentParts)
			stringTag.Name = "RobloxModel"
		end

		--Re-enable the scripts
		for index,script in pairs(stampData.DisabledScripts) do
			script.Disabled = false
		end

		--Now that they are all marked enabled, reinsert them into the world so they start running
		for index,script in pairs(stampData.DisabledScripts) do
			local oldParent = script.Parent
			script.Parent = nil
			script:Clone().Parent = oldParent
		end

		-- clear out more data
		stampData.DisabledScripts = nil
		stampData.Dragger = nil
		stampData.CurrentParts = nil

		pcall(function() game:GetService("ChangeHistoryService"): SetWaypoint("StampedObject") end)
		return true
	end

	local function pauseStamper()
		for i = 1, #mouseCons do -- stop the mouse from doing anything
			mouseCons[i]:disconnect()
			mouseCons[i] = nil
		end
		mouseCons = {}

		if stampData and stampData.CurrentParts then -- remove our ghost part
			stampData.CurrentParts.Parent = nil
			stampData.CurrentParts:Remove()
		end

		resetHighScalabilityLine()

		game:GetService("JointsService"):ClearJoinAfterMoveJoints()
	end


	local function prepareUnjoinableSurfaces(modelCFrame, parts, whichSurface)
		local AXIS_VECTORS = {Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1)}  -- maybe last one is negative?  TODO: check this!
		local isPositive = 1
		if whichSurface < 0 then isPositive = isPositive * -1 whichSurface = whichSurface*-1 end
		local surfaceNormal = isPositive * modelCFrame:vectorToWorldSpace(AXIS_VECTORS[whichSurface])

		for i = 1, #parts do
			local currPart = parts[i]

			-- now just need to find which surface of currPart most closely match surfaceNormal and then set that to Unjoinable
			local surfaceNormalInLocalCoords = currPart.CFrame:vectorToObjectSpace(surfaceNormal)
			if math.abs(surfaceNormalInLocalCoords.X) > math.abs(surfaceNormalInLocalCoords.Y) then
				if math.abs(surfaceNormalInLocalCoords.X) > math.abs(surfaceNormalInLocalCoords.Z) then
					if surfaceNormalInLocalCoords.X > 0 then currPart.RightSurface = "Unjoinable" else currPart.LeftSurface = "Unjoinable" end
				else
					if surfaceNormalInLocalCoords.Z > 0 then currPart.BackSurface = "Unjoinable" else currPart.FrontSurface = "Unjoinable" end
				end
			else
				if math.abs(surfaceNormalInLocalCoords.Y) > math.abs(surfaceNormalInLocalCoords.Z) then
					if surfaceNormalInLocalCoords.Y > 0 then currPart.TopSurface = "Unjoinable" else currPart.BottomSurface = "Unjoinable" end
				else
					if surfaceNormalInLocalCoords.Z > 0 then currPart.BackSurface = "Unjoinable" else currPart.FrontSurface = "Unjoinable" end
				end
			end
		end
	end

	local function resumeStamper()
		local clone, parts = prepareModel(modelToStamp)

		if not clone or not parts then
			return
		end

		-- if we have unjoinable faces, then we want to change those surfaces to be Unjoinable
		local unjoinableTag = clone:FindFirstChild("UnjoinableFaces", true)
		if unjoinableTag then
			for unjoinableSurface in string.gmatch(unjoinableTag.Value, "[^,]*") do
				if tonumber(unjoinableSurface) then
					if clone:IsA("Model") then
						prepareUnjoinableSurfaces(clone:GetModelCFrame(), parts, tonumber(unjoinableSurface))
					else
						prepareUnjoinableSurfaces(clone.CFrame, parts, tonumber(unjoinableSurface))
					end
				end
			end
		end

		stampData.ErrorBox = errorBox
		if stampInModel then
			clone.Parent = stampInModel
		else
			clone.Parent = game:GetService("Workspace")
		end

		if clone:FindFirstChild("ClusterMaterial", true) then -- extract all info from vector
			local clusterMaterial = clone:FindFirstChild("ClusterMaterial", true)
			if (clusterMaterial:IsA("Vector3Value")) then
				cellInfo.Material = clusterMaterial.Value.X
				cellInfo.clusterType = clusterMaterial.Value.Y
				cellInfo.clusterOrientation = clusterMaterial.Value.Z
			elseif clusterMaterial:IsA("IntValue") then
				cellInfo.Material = clusterMaterial.Value
			end
		end

		pcall(function() mouseTarget = Mouse.Target end)

		if mouseTarget and mouseTarget.Parent:FindFirstChild("RobloxModel") == nil then
			game:GetService("JointsService"):SetJoinAfterMoveTarget(mouseTarget)
		else
			game:GetService("JointsService"):SetJoinAfterMoveTarget(nil)
		end
		game:GetService("JointsService"):ShowPermissibleJoints()

		for index, object in pairs(stampData.DisabledScripts) do
			if object.Name == "GhostRemovalScript" then
				object.Parent = stampData.CurrentParts
			end
		end

		stampData.Dragger = Instance.new("Dragger")

		--Begin a movement by faking a MouseDown signal
		stampData.Dragger:MouseDown(parts[1], Vector3.new(0,0,0), parts)
		stampData.Dragger:MouseUp()

		DoStamperMouseMove(Mouse)

		table.insert(mouseCons,Mouse.Move:connect(function()
			if movingLock or stampUpLock then return end
			movingLock = true
				DoStamperMouseMove(Mouse)
			movingLock = false
		end))

		table.insert(mouseCons,Mouse.Button1Down:connect(function()
			DoStamperMouseDown(Mouse)
		end))

		table.insert(mouseCons,Mouse.Button1Up:connect(function()
			stampUpLock = true
				while movingLock do wait() end
				stamped.Value = DoStamperMouseUp(Mouse)
				resetHighScalabilityLine()
			stampUpLock = false
		end))

		stamped.Value = false
	end

	local function resetStamperState(newModelToStamp)

		-- if we have a new model, swap it out
		if newModelToStamp then
			if not newModelToStamp:IsA("Model") and not newModelToStamp:IsA("BasePart") then
				error("resetStamperState: newModelToStamp (first arg) is not nil, but not a model or part!")
			end
			modelToStamp = newModelToStamp
		end

		-- first clear our state
		pauseStamper()
		-- now lets load in the new model
		resumeStamper()

	end

	-- load the model initially
	resetStamperState()


	-- setup the control table we pass back to the user
	control.Stamped = stamped -- BoolValue that fires when user stamps
	control.Paused = false

	control.LoadNewModel = function(newStampModel) -- allows us to specify a new stamper model to be used with this stamper
		if newStampModel and not newStampModel:IsA("Model") and not newStampModel:IsA("BasePart") then
			error("Control.LoadNewModel: newStampModel (first arg) is not a Model or Part!")
			return nil
		end
		resetStamperState(newStampModel)
	end

	control.ReloadModel = function() -- will automatically set stamper to get a new model of current model and start stamping with new model
		resetStamperState()
	end

	control.Pause = function() -- temporarily stops stamping, use resume to start up again
		if not control.Paused then
			pauseStamper()
			control.Paused = true
		else
			print("RbxStamper Warning: Tried to call Control.Pause() when already paused")
		end
	end

	control.Resume = function() -- resumes stamping, if currently paused
		if control.Paused then
			resumeStamper()
			control.Paused = false
		else
			print("RbxStamper Warning: Tried to call Control.Resume() without Pausing First")
		end
	end

	control.ResetRotation = function() -- resets the model rotation so new models are at default orientation
		-- gInitial90DegreeRotations = 0
		-- Note:  This function will not always work quite the way we want it to; we will have to build this out further so it works with
		--        High-Scalability and with the new model orientation setting methods (model:ResetOrientationToIdentity())  [HotThoth]
	end

	control.Destroy = function() -- Stops current Stamp operation and destroys control construct
		for i = 1, #mouseCons do
			mouseCons[i]:disconnect()
			mouseCons[i] = nil
		end

		if keyCon then
			keyCon:disconnect()
		end

		game:GetService("JointsService"):ClearJoinAfterMoveJoints()

		if adorn then adorn:Destroy() end
		if adornPart then adornPart:Destroy() end
		if errorBox then errorBox:Destroy() end
		if stampData then
			if stampData["Dragger"] then
				stampData.Dragger:Destroy()
			end
			if stampData.CurrentParts then
				stampData.CurrentParts:Destroy()
			end
		end
		if control and control["Stamped"] then
			control.Stamped:Destroy()
		end
		control = nil
	end

	return control
end

t.Help =
	function(funcNameOrFunc)
		--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
		if funcNameOrFunc == "GetStampModel" or funcNameOrFunc == t.GetStampModel then
			return "Function GetStampModel.  Arguments: assetId, useAssetVersionId.  assetId is the asset to load in, define useAssetVersionId as true if assetId is a version id instead of a relative assetId.  Side effect: returns a model of the assetId, or a string with error message if something fails"
		end
		if funcNameOrFunc == "SetupStamperDragger" or funcNameOrFunc == t.SetupStamperDragger then
			return "Function SetupStamperDragger. Side Effect: Creates 4x4 stamping mechanism for building out parts quickly. Arguments: ModelToStamp, Mouse, LegalStampCheckFunction. ModelToStamp should be a Model or Part, preferrably loaded from RbxStamper.GetStampModel and should have extents that are multiples of 4.  Mouse should be a mouse object (obtained from things such as Tool.OnEquipped), used to drag parts around 'stamp' them out. LegalStampCheckFunction is optional, used as a callback with a table argument (table is full of instances about to be stamped). Function should return either true or false, false stopping the stamp action."
		end
	end

return t

end;
};
G2L_MODULES[G2L["10d"]] = {
Closure = function()
    local script = G2L["10d"];local t = {}

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------JSON Functions Begin----------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

 --JSON Encoder and Parser for Lua 5.1
 --
 --Copyright 2007 Shaun Brown  (http://www.chipmunkav.com)
 --All Rights Reserved.
 
 --Permission is hereby granted, free of charge, to any person 
 --obtaining a copy of this software to deal in the Software without 
 --restriction, including without limitation the rights to use, 
 --copy, modify, merge, publish, distribute, sublicense, and/or 
 --sell copies of the Software, and to permit persons to whom the 
 --Software is furnished to do so, subject to the following conditions:
 
 --The above copyright notice and this permission notice shall be 
 --included in all copies or substantial portions of the Software.
 --If you find this software useful please give www.chipmunkav.com a mention.

 --THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 --EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
 --OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 --IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
 --ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
 --CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
 --CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
local string = string
local math = math
local table = table
local error = error
local tonumber = tonumber
local tostring = tostring
local type = type
local setmetatable = setmetatable
local pairs = pairs
local ipairs = ipairs
local assert = assert


local StringBuilder = {
	buffer = {}
}

function StringBuilder:New()
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.buffer = {}
	return o
end

function StringBuilder:Append(s)
	self.buffer[#self.buffer+1] = s
end

function StringBuilder:ToString()
	return table.concat(self.buffer)
end

local JsonWriter = {
	backslashes = {
		['\b'] = "\\b",
		['\t'] = "\\t",	
		['\n'] = "\\n", 
		['\f'] = "\\f",
		['\r'] = "\\r", 
		['"']  = "\\\"", 
		['\\'] = "\\\\", 
		['/']  = "\\/"
	}
}

function JsonWriter:New()
	local o = {}
	o.writer = StringBuilder:New()
	setmetatable(o, self)
	self.__index = self
	return o
end

function JsonWriter:Append(s)
	self.writer:Append(s)
end

function JsonWriter:ToString()
	return self.writer:ToString()
end

function JsonWriter:Write(o)
	local t = type(o)
	if t == "nil" then
		self:WriteNil()
	elseif t == "boolean" then
		self:WriteString(o)
	elseif t == "number" then
		self:WriteString(o)
	elseif t == "string" then
		self:ParseString(o)
	elseif t == "table" then
		self:WriteTable(o)
	elseif t == "function" then
		self:WriteFunction(o)
	elseif t == "thread" then
		self:WriteError(o)
	elseif t == "userdata" then
		self:WriteError(o)
	end
end

function JsonWriter:WriteNil()
	self:Append("null")
end

function JsonWriter:WriteString(o)
	self:Append(tostring(o))
end

function JsonWriter:ParseString(s)
	self:Append('"')
	self:Append(string.gsub(s, "[%z%c\\\"/]", function(n)
		local c = self.backslashes[n]
		if c then return c end
		return string.format("\\u%.4X", string.byte(n))
	end))
	self:Append('"')
end

function JsonWriter:IsArray(t)
	local count = 0
	local isindex = function(k) 
		if type(k) == "number" and k > 0 then
			if math.floor(k) == k then
				return true
			end
		end
		return false
	end
	for k,v in pairs(t) do
		if not isindex(k) then
			return false, '{', '}'
		else
			count = math.max(count, k)
		end
	end
	return true, '[', ']', count
end

function JsonWriter:WriteTable(t)
	local ba, st, et, n = self:IsArray(t)
	self:Append(st)	
	if ba then		
		for i = 1, n do
			self:Write(t[i])
			if i < n then
				self:Append(',')
			end
		end
	else
		local first = true;
		for k, v in pairs(t) do
			if not first then
				self:Append(',')
			end
			first = false;			
			self:ParseString(k)
			self:Append(':')
			self:Write(v)			
		end
	end
	self:Append(et)
end

function JsonWriter:WriteError(o)
	error(string.format(
		"Encoding of %s unsupported", 
		tostring(o)))
end

function JsonWriter:WriteFunction(o)
	if o == Null then 
		self:WriteNil()
	else
		self:WriteError(o)
	end
end

local StringReader = {
	s = "",
	i = 0
}

function StringReader:New(s)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.s = s or o.s
	return o	
end

function StringReader:Peek()
	local i = self.i + 1
	if i <= #self.s then
		return string.sub(self.s, i, i)
	end
	return nil
end

function StringReader:Next()
	self.i = self.i+1
	if self.i <= #self.s then
		return string.sub(self.s, self.i, self.i)
	end
	return nil
end

function StringReader:All()
	return self.s
end

local JsonReader = {
	escapes = {
		['t'] = '\t',
		['n'] = '\n',
		['f'] = '\f',
		['r'] = '\r',
		['b'] = '\b',
	}
}

function JsonReader:New(s)
	local o = {}
	o.reader = StringReader:New(s)
	setmetatable(o, self)
	self.__index = self
	return o;
end

function JsonReader:Read()
	self:SkipWhiteSpace()
	local peek = self:Peek()
	if peek == nil then
		error(string.format(
			"Nil string: '%s'", 
			self:All()))
	elseif peek == '{' then
		return self:ReadObject()
	elseif peek == '[' then
		return self:ReadArray()
	elseif peek == '"' then
		return self:ReadString()
	elseif string.find(peek, "[%+%-%d]") then
		return self:ReadNumber()
	elseif peek == 't' then
		return self:ReadTrue()
	elseif peek == 'f' then
		return self:ReadFalse()
	elseif peek == 'n' then
		return self:ReadNull()
	elseif peek == '/' then
		self:ReadComment()
		return self:Read()
	else
		return nil
	end
end
		
function JsonReader:ReadTrue()
	self:TestReservedWord{'t','r','u','e'}
	return true
end

function JsonReader:ReadFalse()
	self:TestReservedWord{'f','a','l','s','e'}
	return false
end

function JsonReader:ReadNull()
	self:TestReservedWord{'n','u','l','l'}
	return nil
end

function JsonReader:TestReservedWord(t)
	for i, v in ipairs(t) do
		if self:Next() ~= v then
			 error(string.format(
				"Error reading '%s': %s", 
				table.concat(t), 
				self:All()))
		end
	end
end

function JsonReader:ReadNumber()
        local result = self:Next()
        local peek = self:Peek()
        while peek ~= nil and string.find(
		peek, 
		"[%+%-%d%.eE]") do
            result = result .. self:Next()
            peek = self:Peek()
	end
	result = tonumber(result)
	if result == nil then
	        error(string.format(
			"Invalid number: '%s'", 
			result))
	else
		return result
	end
end

function JsonReader:ReadString()
	local result = ""
	assert(self:Next() == '"')
        while self:Peek() ~= '"' do
		local ch = self:Next()
		if ch == '\\' then
			ch = self:Next()
			if self.escapes[ch] then
				ch = self.escapes[ch]
			end
		end
                result = result .. ch
	end
        assert(self:Next() == '"')
	local fromunicode = function(m)
		return string.char(tonumber(m, 16))
	end
	return string.gsub(
		result, 
		"u%x%x(%x%x)", 
		fromunicode)
end

function JsonReader:ReadComment()
        assert(self:Next() == '/')
        local second = self:Next()
        if second == '/' then
            self:ReadSingleLineComment()
        elseif second == '*' then
            self:ReadBlockComment()
        else
            error(string.format(
		"Invalid comment: %s", 
		self:All()))
	end
end

function JsonReader:ReadBlockComment()
	local done = false
	while not done do
		local ch = self:Next()		
		if ch == '*' and self:Peek() == '/' then
			done = true
                end
		if not done and 
			ch == '/' and 
			self:Peek() == "*" then
                    error(string.format(
			"Invalid comment: %s, '/*' illegal.",  
			self:All()))
		end
	end
	self:Next()
end

function JsonReader:ReadSingleLineComment()
	local ch = self:Next()
	while ch ~= '\r' and ch ~= '\n' do
		ch = self:Next()
	end
end

function JsonReader:ReadArray()
	local result = {}
	assert(self:Next() == '[')
	local done = false
	if self:Peek() == ']' then
		done = true;
	end
	while not done do
		local item = self:Read()
		result[#result+1] = item
		self:SkipWhiteSpace()
		if self:Peek() == ']' then
			done = true
		end
		if not done then
			local ch = self:Next()
			if ch ~= ',' then
				error(string.format(
					"Invalid array: '%s' due to: '%s'", 
					self:All(), ch))
			end
		end
	end
	assert(']' == self:Next())
	return result
end

function JsonReader:ReadObject()
	local result = {}
	assert(self:Next() == '{')
	local done = false
	if self:Peek() == '}' then
		done = true
	end
	while not done do
		local key = self:Read()
		if type(key) ~= "string" then
			error(string.format(
				"Invalid non-string object key: %s", 
				key))
		end
		self:SkipWhiteSpace()
		local ch = self:Next()
		if ch ~= ':' then
			error(string.format(
				"Invalid object: '%s' due to: '%s'", 
				self:All(), 
				ch))
		end
		self:SkipWhiteSpace()
		local val = self:Read()
		result[key] = val
		self:SkipWhiteSpace()
		if self:Peek() == '}' then
			done = true
		end
		if not done then
			ch = self:Next()
                	if ch ~= ',' then
				error(string.format(
					"Invalid array: '%s' near: '%s'", 
					self:All(), 
					ch))
			end
		end
	end
	assert(self:Next() == "}")
	return result
end

function JsonReader:SkipWhiteSpace()
	local p = self:Peek()
	while p ~= nil and string.find(p, "[%s/]") do
		if p == '/' then
			self:ReadComment()
		else
			self:Next()
		end
		p = self:Peek()
	end
end

function JsonReader:Peek()
	return self.reader:Peek()
end

function JsonReader:Next()
	return self.reader:Next()
end

function JsonReader:All()
	return self.reader:All()
end

function Encode(o)
	local writer = JsonWriter:New()
	writer:Write(o)
	return writer:ToString()
end

function Decode(s)
	local reader = JsonReader:New(s)
	return reader:Read()
end

function Null()
	return Null
end
-------------------- End JSON Parser ------------------------

t.DecodeJSON = function(jsonString)
	pcall(function() warn("RbxUtility.DecodeJSON is deprecated, please use Game:GetService('HttpService'):JSONDecode() instead.") end)

	if type(jsonString) == "string" then
		return Decode(jsonString)
	end
	print("RbxUtil.DecodeJSON expects string argument!")
	return nil
end

t.EncodeJSON = function(jsonTable)
	pcall(function() warn("RbxUtility.EncodeJSON is deprecated, please use Game:GetService('HttpService'):JSONEncode() instead.") end)
	return Encode(jsonTable)
end








------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
--------------------------------------------Terrain Utilities Begin-----------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
--makes a wedge at location x, y, z
--sets cell x, y, z to default material if parameter is provided, if not sets cell x, y, z to be whatever material it previously w
--returns true if made a wedge, false if the cell remains a block
t.MakeWedge = function(x, y, z, defaultmaterial)
	return game:GetService("Terrain"):AutoWedgeCell(x,y,z)
end

t.SelectTerrainRegion = function(regionToSelect, color, selectEmptyCells, selectionParent)
	local terrain = game:GetService("Workspace"):FindFirstChild("Terrain")
	if not terrain then return end

	assert(regionToSelect)
	assert(color)

	if not type(regionToSelect) == "Region3" then
		error("regionToSelect (first arg), should be of type Region3, but is type",type(regionToSelect))
	end
	if not type(color) == "BrickColor" then
		error("color (second arg), should be of type BrickColor, but is type",type(color))
	end

	-- frequently used terrain calls (speeds up call, no lookup necessary)
	local GetCell = terrain.GetCell
	local WorldToCellPreferSolid = terrain.WorldToCellPreferSolid
	local CellCenterToWorld = terrain.CellCenterToWorld
	local emptyMaterial = Enum.CellMaterial.Empty

	-- container for all adornments, passed back to user
	local selectionContainer = Instance.new("Model")
	selectionContainer.Name = "SelectionContainer"
	selectionContainer.Archivable = false
	if selectionParent then
		selectionContainer.Parent = selectionParent
	else
		selectionContainer.Parent = game:GetService("Workspace")
	end

	local updateSelection = nil -- function we return to allow user to update selection
	local currentKeepAliveTag = nil -- a tag that determines whether adorns should be destroyed
	local aliveCounter = 0 -- helper for currentKeepAliveTag
	local lastRegion = nil -- used to stop updates that do nothing
	local adornments = {} -- contains all adornments
	local reusableAdorns = {}

	local selectionPart = Instance.new("Part")
	selectionPart.Name = "SelectionPart"
	selectionPart.Transparency = 1
	selectionPart.Anchored = true
	selectionPart.Locked = true
	selectionPart.CanCollide = false
	selectionPart.Size = Vector3.new(4.2,4.2,4.2)

	local selectionBox = Instance.new("SelectionBox")

	-- srs translation from region3 to region3int16
	local function Region3ToRegion3int16(region3)
		local theLowVec = region3.CFrame.p - (region3.Size/2) + Vector3.new(2,2,2)
		local lowCell = WorldToCellPreferSolid(terrain,theLowVec)

		local theHighVec = region3.CFrame.p + (region3.Size/2) - Vector3.new(2,2,2)
		local highCell = WorldToCellPreferSolid(terrain, theHighVec)

		local highIntVec = Vector3int16.new(highCell.x,highCell.y,highCell.z)
		local lowIntVec = Vector3int16.new(lowCell.x,lowCell.y,lowCell.z)

		return Region3int16.new(lowIntVec,highIntVec)
	end

	-- helper function that creates the basis for a selection box
	function createAdornment(theColor)
		local selectionPartClone = nil
		local selectionBoxClone = nil

		if #reusableAdorns > 0 then
			selectionPartClone = reusableAdorns[1]["part"]
			selectionBoxClone = reusableAdorns[1]["box"]
			table.remove(reusableAdorns,1)

			selectionBoxClone.Visible = true
		else
			selectionPartClone = selectionPart:Clone()
			selectionPartClone.Archivable = false

			selectionBoxClone = selectionBox:Clone()
			selectionBoxClone.Archivable = false

			selectionBoxClone.Adornee = selectionPartClone
			selectionBoxClone.Parent = selectionContainer

			selectionBoxClone.Adornee = selectionPartClone

			selectionBoxClone.Parent = selectionContainer
		end
			
		if theColor then
			selectionBoxClone.Color = theColor
		end

		return selectionPartClone, selectionBoxClone
	end

	-- iterates through all current adornments and deletes any that don't have latest tag
	function cleanUpAdornments()
		for cellPos, adornTable in pairs(adornments) do

			if adornTable.KeepAlive ~= currentKeepAliveTag then -- old news, we should get rid of this
				adornTable.SelectionBox.Visible = false
				table.insert(reusableAdorns,{part = adornTable.SelectionPart, box = adornTable.SelectionBox})
				adornments[cellPos] = nil
			end
		end
	end

	-- helper function to update tag
	function incrementAliveCounter()
		aliveCounter = aliveCounter + 1
		if aliveCounter > 1000000 then
			aliveCounter = 0
		end
		return aliveCounter
	end

	-- finds full cells in region and adorns each cell with a box, with the argument color
	function adornFullCellsInRegion(region, color)
		local regionBegin = region.CFrame.p - (region.Size/2) + Vector3.new(2,2,2)
		local regionEnd = region.CFrame.p + (region.Size/2) - Vector3.new(2,2,2)

		local cellPosBegin = WorldToCellPreferSolid(terrain, regionBegin)
		local cellPosEnd = WorldToCellPreferSolid(terrain, regionEnd)

		currentKeepAliveTag = incrementAliveCounter()
		for y = cellPosBegin.y, cellPosEnd.y do
			for z = cellPosBegin.z, cellPosEnd.z do
				for x = cellPosBegin.x, cellPosEnd.x do
					local cellMaterial = GetCell(terrain, x, y, z)
					
					if cellMaterial ~= emptyMaterial then
						local cframePos = CellCenterToWorld(terrain, x, y, z)
						local cellPos = Vector3int16.new(x,y,z)

						local updated = false
						for cellPosAdorn, adornTable in pairs(adornments) do
							if cellPosAdorn == cellPos then
								adornTable.KeepAlive = currentKeepAliveTag
								if color then
									adornTable.SelectionBox.Color = color
								end
								updated = true
								break
							end 
						end

						if not updated then
							local selectionPart, selectionBox = createAdornment(color)
							selectionPart.Size = Vector3.new(4,4,4)
							selectionPart.CFrame = CFrame.new(cframePos)
							local adornTable = {SelectionPart = selectionPart, SelectionBox = selectionBox, KeepAlive = currentKeepAliveTag}
							adornments[cellPos] = adornTable
						end
					end
				end
			end
		end
		cleanUpAdornments()
	end


	------------------------------------- setup code ------------------------------
	lastRegion = regionToSelect

	if selectEmptyCells then -- use one big selection to represent the area selected
		local selectionPart, selectionBox = createAdornment(color)

		selectionPart.Size = regionToSelect.Size
		selectionPart.CFrame = regionToSelect.CFrame

		adornments.SelectionPart = selectionPart
		adornments.SelectionBox = selectionBox

		updateSelection = 
			function (newRegion, color)
				if newRegion and newRegion ~= lastRegion then
					lastRegion = newRegion
				 	selectionPart.Size = newRegion.Size
					selectionPart.CFrame = newRegion.CFrame
				end
				if color then
					selectionBox.Color = color
				end
			end
	else -- use individual cell adorns to represent the area selected
		adornFullCellsInRegion(regionToSelect, color)
		updateSelection = 
			function (newRegion, color)
				if newRegion and newRegion ~= lastRegion then
					lastRegion = newRegion
					adornFullCellsInRegion(newRegion, color)
				end
			end

	end

	local destroyFunc = function()
		updateSelection = nil
		if selectionContainer then selectionContainer:Destroy() end
		adornments = nil
	end

	return updateSelection, destroyFunc
end

-----------------------------Terrain Utilities End-----------------------------







------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------Signal class begin------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
--[[
A 'Signal' object identical to the internal RBXScriptSignal object in it's public API and semantics. This function 
can be used to create "custom events" for user-made code.
API:
Method :connect( function handler )
	Arguments:   The function to connect to.
	Returns:     A new connection object which can be used to disconnect the connection
	Description: Connects this signal to the function specified by |handler|. That is, when |fire( ... )| is called for
	             the signal the |handler| will be called with the arguments given to |fire( ... )|. Note, the functions
	             connected to a signal are called in NO PARTICULAR ORDER, so connecting one function after another does
	             NOT mean that the first will be called before the second as a result of a call to |fire|.

Method :disconnect()
	Arguments:   None
	Returns:     None
	Description: Disconnects all of the functions connected to this signal.

Method :fire( ... )
	Arguments:   Any arguments are accepted
	Returns:     None
	Description: Calls all of the currently connected functions with the given arguments.

Method :wait()
	Arguments:   None
	Returns:     The arguments given to fire
	Description: This call blocks until 
]]

function t.CreateSignal()
	local this = {}

	local mBindableEvent = Instance.new('BindableEvent')
	local mAllCns = {} --all connection objects returned by mBindableEvent::connect

	--main functions
	function this:connect(func)
		if self ~= this then error("connect must be called with `:`, not `.`", 2) end
		if type(func) ~= 'function' then
			error("Argument #1 of connect must be a function, got a "..type(func), 2)
		end
		local cn = mBindableEvent.Event:Connect(func)
		mAllCns[cn] = true
		local pubCn = {}
		function pubCn:disconnect()
			cn:Disconnect()
			mAllCns[cn] = nil
		end
		pubCn.Disconnect = pubCn.disconnect
		
		return pubCn
	end
	
	function this:disconnect()
		if self ~= this then error("disconnect must be called with `:`, not `.`", 2) end
		for cn, _ in pairs(mAllCns) do
			cn:Disconnect()
			mAllCns[cn] = nil
		end
	end
	
	function this:wait()
		if self ~= this then error("wait must be called with `:`, not `.`", 2) end
		return mBindableEvent.Event:Wait()
	end
	
	function this:fire(...)
		if self ~= this then error("fire must be called with `:`, not `.`", 2) end
		mBindableEvent:Fire(...)
	end
	
	this.Connect = this.connect
	this.Disconnect = this.disconnect
	this.Wait = this.wait
	this.Fire = this.fire

	return this
end

------------------------------------------------- Sigal class End ------------------------------------------------------




------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------Create Function Begins---------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
--[[
A "Create" function for easy creation of Roblox instances. The function accepts a string which is the classname of
the object to be created. The function then returns another function which either accepts accepts no arguments, in 
which case it simply creates an object of the given type, or a table argument that may contain several types of data, 
in which case it mutates the object in varying ways depending on the nature of the aggregate data. These are the
type of data and what operation each will perform:
1) A string key mapping to some value:
      Key-Value pairs in this form will be treated as properties of the object, and will be assigned in NO PARTICULAR
      ORDER. If the order in which properties is assigned matter, then they must be assigned somewhere else than the
      |Create| call's body.

2) An integral key mapping to another Instance:
      Normal numeric keys mapping to Instances will be treated as children if the object being created, and will be
      parented to it. This allows nice recursive calls to Create to create a whole hierarchy of objects without a
      need for temporary variables to store references to those objects.

3) A key which is a value returned from Create.Event( eventname ), and a value which is a function function
      The Create.E( string ) function provides a limited way to connect to signals inside of a Create hierarchy 
      for those who really want such a functionality. The name of the event whose name is passed to 
      Create.E( string )

4) A key which is the Create function itself, and a value which is a function
      The function will be run with the argument of the object itself after all other initialization of the object is 
      done by create. This provides a way to do arbitrary things involving the object from withing the create 
      hierarchy. 
      Note: This function is called SYNCHRONOUSLY, that means that you should only so initialization in
      it, not stuff which requires waiting, as the Create call will block until it returns. While waiting in the 
      constructor callback function is possible, it is probably not a good design choice.
      Note: Since the constructor function is called after all other initialization, a Create block cannot have two 
      constructor functions, as it would not be possible to call both of them last, also, this would be unnecessary.


Some example usages:

A simple example which uses the Create function to create a model object and assign two of it's properties.
local model = Create'Model'{
    Name = 'A New model',
    Parent = workspace,
}


An example where a larger hierarchy of object is made. After the call the hierarchy will look like this:
Model_Container
 |-ObjectValue
 |  |
 |  `-BoolValueChild
 `-IntValue

local model = Create'Model'{
    Name = 'Model_Container',
    Create'ObjectValue'{
        Create'BoolValue'{
            Name = 'BoolValueChild',
        },
    },
    Create'IntValue'{},
}


An example using the event syntax:

local part = Create'Part'{
    [Create.E'Touched'] = function(part)
        print("I was touched by "..part.Name)
    end,	
}


An example using the general constructor syntax:

local model = Create'Part'{
    [Create] = function(this)
        print("Constructor running!")
        this.Name = GetGlobalFoosAndBars(this)
    end,
}


Note: It is also perfectly legal to save a reference to the function returned by a call Create, this will not cause
      any unexpected behavior. EG:
      local partCreatingFunction = Create'Part'
      local part = partCreatingFunction()
]]

--the Create function need to be created as a functor, not a function, in order to support the Create.E syntax, so it
--will be created in several steps rather than as a single function declaration.
local function Create_PrivImpl(objectType)
	if type(objectType) ~= 'string' then
		error("Argument of Create must be a string", 2)
	end
	--return the proxy function that gives us the nice Create'string'{data} syntax
	--The first function call is a function call using Lua's single-string-argument syntax
	--The second function call is using Lua's single-table-argument syntax
	--Both can be chained together for the nice effect.
	return function(dat)
		--default to nothing, to handle the no argument given case
		dat = dat or {}

		--make the object to mutate
		local obj = Instance.new(objectType)
		local parent = nil

		--stored constructor function to be called after other initialization
		local ctor = nil

		for k, v in pairs(dat) do
			--add property
			if type(k) == 'string' then
				if k == 'Parent' then
					-- Parent should always be set last, setting the Parent of a new object
					-- immediately makes performance worse for all subsequent property updates.
					parent = v
				else
					obj[k] = v
				end


			--add child
			elseif type(k) == 'number' then
				if type(v) ~= 'userdata' then
					error("Bad entry in Create body: Numeric keys must be paired with children, got a: "..type(v), 2)
				end
				v.Parent = obj


			--event connect
			elseif type(k) == 'table' and k.__eventname then
				if type(v) ~= 'function' then
					error("Bad entry in Create body: Key `[Create.E\'"..k.__eventname.."\']` must have a function value\
					       got: "..tostring(v), 2)
				end
				obj[k.__eventname]:connect(v)


			--define constructor function
			elseif k == t.Create then
				if type(v) ~= 'function' then
					error("Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
					       got: "..tostring(v), 2)
				elseif ctor then
					--ctor already exists, only one allowed
					error("Bad entry in Create body: Only one constructor function is allowed", 2)
				end
				ctor = v


			else
				error("Bad entry ("..tostring(k).." => "..tostring(v)..") in Create body", 2)
			end
		end

		--apply constructor function if it exists
		if ctor then
			ctor(obj)
		end
		
		if parent then
			obj.Parent = parent
		end

		--return the completed object
		return obj
	end
end

--now, create the functor:
t.Create = setmetatable({}, {__call = function(tb, ...) return Create_PrivImpl(...) end})

--and create the "Event.E" syntax stub. Really it's just a stub to construct a table which our Create
--function can recognize as special.
t.Create.E = function(eventName)
	return {__eventname = eventName}
end

-------------------------------------------------Create function End----------------------------------------------------




------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------Documentation Begin-----------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

t.Help = 
	function(funcNameOrFunc) 
		--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
		if funcNameOrFunc == "DecodeJSON" or funcNameOrFunc == t.DecodeJSON then
			return "Function DecodeJSON.  " ..
			       "Arguments: (string).  " .. 
			       "Side effect: returns a table with all parsed JSON values" 
		end
		if funcNameOrFunc == "EncodeJSON" or funcNameOrFunc == t.EncodeJSON then
			return "Function EncodeJSON.  " ..
			       "Arguments: (table).  " .. 
			       "Side effect: returns a string composed of argument table in JSON data format" 
		end  
		if funcNameOrFunc == "MakeWedge" or funcNameOrFunc == t.MakeWedge then
			return "Function MakeWedge. " ..
			       "Arguments: (x, y, z, [default material]). " ..
			       "Description: Makes a wedge at location x, y, z. Sets cell x, y, z to default material if "..
			       "parameter is provided, if not sets cell x, y, z to be whatever material it previously was. "..
			       "Returns true if made a wedge, false if the cell remains a block "
		end
		if funcNameOrFunc == "SelectTerrainRegion" or funcNameOrFunc == t.SelectTerrainRegion then
			return "Function SelectTerrainRegion. " ..
			       "Arguments: (regionToSelect, color, selectEmptyCells, selectionParent). " ..
			       "Description: Selects all terrain via a series of selection boxes within the regionToSelect " ..
			       "(this should be a region3 value). The selection box color is detemined by the color argument " ..
			       "(should be a brickcolor value). SelectionParent is the parent that the selection model gets placed to (optional)." ..
			       "SelectEmptyCells is bool, when true will select all cells in the " ..
			       "region, otherwise we only select non-empty cells. Returns a function that can update the selection," ..
			       "arguments to said function are a new region3 to select, and the adornment color (color arg is optional). " ..
			       "Also returns a second function that takes no arguments and destroys the selection"
		end
		if funcNameOrFunc == "CreateSignal" or funcNameOrFunc == t.CreateSignal then
			return "Function CreateSignal. "..
			       "Arguments: None. "..
			       "Returns: The newly created Signal object. This object is identical to the RBXScriptSignal class "..
			       "used for events in Objects, but is a Lua-side object so it can be used to create custom events in"..
			       "Lua code. "..
			       "Methods of the Signal object: :connect, :wait, :fire, :disconnect. "..
			       "For more info you can pass the method name to the Help function, or view the wiki page "..
			       "for this library. EG: Help('Signal:connect')."
		end
		if funcNameOrFunc == "Signal:connect" then
			return "Method Signal:connect. "..
			       "Arguments: (function handler). "..
			       "Return: A connection object which can be used to disconnect the connection to this handler. "..
			       "Description: Connectes a handler function to this Signal, so that when |fire| is called the "..
			       "handler function will be called with the arguments passed to |fire|."
		end
		if funcNameOrFunc == "Signal:wait" then
			return "Method Signal:wait. "..
			       "Arguments: None. "..
			       "Returns: The arguments passed to the next call to |fire|. "..
			       "Description: This call does not return until the next call to |fire| is made, at which point it "..
			       "will return the values which were passed as arguments to that |fire| call."
		end
		if funcNameOrFunc == "Signal:fire" then
			return "Method Signal:fire. "..
			       "Arguments: Any number of arguments of any type. "..
			       "Returns: None. "..
			       "Description: This call will invoke any connected handler functions, and notify any waiting code "..
			       "attached to this Signal to continue, with the arguments passed to this function. Note: The calls "..
			       "to handlers are made asynchronously, so this call will return immediately regardless of how long "..
			       "it takes the connected handler functions to complete."
		end
		if funcNameOrFunc == "Signal:disconnect" then
			return "Method Signal:disconnect. "..
			       "Arguments: None. "..
			       "Returns: None. "..
			       "Description: This call disconnects all handlers attacched to this function, note however, it "..
			       "does NOT make waiting code continue, as is the behavior of normal Roblox events. This method "..
			       "can also be called on the connection object which is returned from Signal:connect to only "..
			       "disconnect a single handler, as opposed to this method, which will disconnect all handlers."
		end
		if funcNameOrFunc == "Create" then
			return "Function Create. "..
			       "Arguments: A table containing information about how to construct a collection of objects. "..
			       "Returns: The constructed objects. "..
			       "Descrition: Create is a very powerfull function, whose description is too long to fit here, and "..
			       "is best described via example, please see the wiki page for a description of how to use it."
		end
	end
	
--------------------------------------------Documentation Ends----------------------------------------------------------

return t

end;
};
G2L_MODULES[G2L["122"]] = {
Closure = function()
    local script = G2L["122"];local t = {}

local function ScopedConnect(parentInstance, instance, event, signalFunc, syncFunc, removeFunc)
	local eventConnection = nil

	--Connection on parentInstance is scoped by parentInstance (when destroyed, it goes away)
	local tryConnect = function()
		if game:IsAncestorOf(parentInstance) then
			--Entering the world, make sure we are connected/synced
			if not eventConnection then
				eventConnection = instance[event]:connect(signalFunc)
				if syncFunc then syncFunc() end
			end
		else
			--Probably leaving the world, so disconnect for now
			if eventConnection then
				eventConnection:disconnect()
				if removeFunc then removeFunc() end
			end
		end
	end

	--Hook it up to ancestryChanged signal
	local connection = parentInstance.AncestryChanged:connect(tryConnect)
	
	--Now connect us if we're already in the world
	tryConnect()
	
	return connection
end

local function getLayerCollectorAncestor(instance)
	local localInstance = instance
	while localInstance and not localInstance:IsA("LayerCollector") do
		localInstance = localInstance.Parent
	end
	return localInstance
end

local function CreateButtons(frame, buttons, yPos, ySize)
	local buttonNum = 1
	local buttonObjs = {}
	for i, obj in ipairs(buttons) do 
		local button = Instance.new("TextButton")
		button.Name = "Button" .. buttonNum
		button.Font = Enum.Font.Arial
		button.FontSize = Enum.FontSize.Size18
		button.AutoButtonColor = true
		button.Modal = true
		if obj["Style"] then
			button.Style = obj.Style
		else
			button.Style = Enum.ButtonStyle.RobloxButton
		end
		if obj["ZIndex"] then
			button.ZIndex = obj.ZIndex
		end
		button.Text = obj.Text
		button.TextColor3 = Color3.new(1,1,1)
		button.MouseButton1Click:connect(obj.Function)
		button.Parent = frame
		buttonObjs[buttonNum] = button

		buttonNum = buttonNum + 1
	end
	local numButtons = buttonNum-1

	if numButtons == 1 then
		frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
		frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
	elseif numButtons == 2 then
		frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
		frame.Button1.Size = UDim2.new(.8/3,0, ySize.Scale, ySize.Offset)

		frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
		frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
	elseif numButtons >= 3 then
		local spacing = .1 / numButtons
		local buttonSize = .9 / numButtons

		buttonNum = 1
		while buttonNum <= numButtons do
			buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
			buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
			buttonNum = buttonNum + 1
		end
	end
end

local function setSliderPos(newAbsPosX,slider,sliderPosition,bar,steps)

	local newStep = steps - 1 --otherwise we really get one more step than we want
	local relativePosX = math.min(1, math.max(0, (newAbsPosX - bar.AbsolutePosition.X) / bar.AbsoluteSize.X ))
	local wholeNum, remainder = math.modf(relativePosX * newStep)
	if remainder > 0.5 then
		wholeNum = wholeNum + 1
	end
	relativePosX = wholeNum/newStep

	local result = math.ceil(relativePosX * newStep)
	if sliderPosition.Value ~= (result + 1) then --only update if we moved a step
		sliderPosition.Value = result + 1
		slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
	end
	
end

local function cancelSlide(areaSoak)
	areaSoak.Visible = false
end

t.CreateStyledMessageDialog = function(title, message, style, buttons)
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0.5, 0, 0, 165)
	frame.Position = UDim2.new(0.25, 0, 0.5, -72.5)
	frame.Name = "MessageDialog"
	frame.Active = true
	frame.Style = Enum.FrameStyle.RobloxRound	
	
	local styleImage = Instance.new("ImageLabel")
	styleImage.Name = "StyleImage"
	styleImage.BackgroundTransparency = 1
	styleImage.Position = UDim2.new(0,5,0,15)
	if style == "error" or style == "Error" then
		styleImage.Size = UDim2.new(0, 71, 0, 71)
		styleImage.Image = "https://www.roblox.com/asset/?id=42565285"
	elseif style == "notify" or style == "Notify" then
		styleImage.Size = UDim2.new(0, 71, 0, 71)
		styleImage.Image = "https://www.roblox.com/asset/?id=42604978"
	elseif style == "confirm" or style == "Confirm" then
		styleImage.Size = UDim2.new(0, 74, 0, 76)
		styleImage.Image = "https://www.roblox.com/asset/?id=42557901"
	else
		return t.CreateMessageDialog(title,message,buttons)
	end
	styleImage.Parent = frame
	
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Text = title
	titleLabel.TextStrokeTransparency = 0
	titleLabel.BackgroundTransparency = 1
	titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
	titleLabel.Position = UDim2.new(0, 80, 0, 0)
	titleLabel.Size = UDim2.new(1, -80, 0, 40)
	titleLabel.Font = Enum.Font.ArialBold
	titleLabel.FontSize = Enum.FontSize.Size36
	titleLabel.TextXAlignment = Enum.TextXAlignment.Center
	titleLabel.TextYAlignment = Enum.TextYAlignment.Center
	titleLabel.Parent = frame

	local messageLabel = Instance.new("TextLabel")
	messageLabel.Name = "Message"
	messageLabel.Text = message
	messageLabel.TextStrokeTransparency = 0
	messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
	messageLabel.Position = UDim2.new(0.025, 80, 0, 45)
	messageLabel.Size = UDim2.new(0.95, -80, 0, 55)
	messageLabel.BackgroundTransparency = 1
	messageLabel.Font = Enum.Font.Arial
	messageLabel.FontSize = Enum.FontSize.Size18
	messageLabel.TextWrap = true
	messageLabel.TextXAlignment = Enum.TextXAlignment.Left
	messageLabel.TextYAlignment = Enum.TextYAlignment.Top
	messageLabel.Parent = frame

	CreateButtons(frame, buttons, UDim.new(0, 105), UDim.new(0, 40) )

	return frame
end

t.CreateMessageDialog = function(title, message, buttons)
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0.5, 0, 0.5, 0)
	frame.Position = UDim2.new(0.25, 0, 0.25, 0)
	frame.Name = "MessageDialog"
	frame.Active = true
	frame.Style = Enum.FrameStyle.RobloxRound

	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Text = title
	titleLabel.BackgroundTransparency = 1
	titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
	titleLabel.Position = UDim2.new(0, 0, 0, 0)
	titleLabel.Size = UDim2.new(1, 0, 0.15, 0)
	titleLabel.Font = Enum.Font.ArialBold
	titleLabel.FontSize = Enum.FontSize.Size36
	titleLabel.TextXAlignment = Enum.TextXAlignment.Center
	titleLabel.TextYAlignment = Enum.TextYAlignment.Center
	titleLabel.Parent = frame

	local messageLabel = Instance.new("TextLabel")
	messageLabel.Name = "Message"
	messageLabel.Text = message
	messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
	messageLabel.Position = UDim2.new(0.025, 0, 0.175, 0)
	messageLabel.Size = UDim2.new(0.95, 0, .55, 0)
	messageLabel.BackgroundTransparency = 1
	messageLabel.Font = Enum.Font.Arial
	messageLabel.FontSize = Enum.FontSize.Size18
	messageLabel.TextWrap = true
	messageLabel.TextXAlignment = Enum.TextXAlignment.Left
	messageLabel.TextYAlignment = Enum.TextYAlignment.Top
	messageLabel.Parent = frame

	CreateButtons(frame, buttons, UDim.new(0.8,0), UDim.new(0.15, 0))

	return frame
end

-- written by jmargh
-- to be used for the new settings menu
t.CreateScrollingDropDownMenu = function(onSelectedCallback, size, position, baseZ)
	local maxVisibleList = 6
	local baseZIndex = 0
	if type(baseZ) == 'number' then
		baseZIndex = baseZ
	end

	local dropDownMenu = {}
	local currentList = nil

	local updateFunc = nil
	local frame = Instance.new('Frame')
	frame.Name = "DropDownMenuFrame"
	frame.Size = size
	frame.Position = position
	frame.BackgroundTransparency = 1
	dropDownMenu.Frame = frame

	local currentSelectionName = Instance.new('TextButton')
	currentSelectionName.Name = "CurrentSelectionName"
	currentSelectionName.Size = UDim2.new(1, 0, 1, 0)
	currentSelectionName.BackgroundTransparency = 1
	currentSelectionName.Font = Enum.Font.SourceSansBold
	currentSelectionName.FontSize = Enum.FontSize.Size18
	currentSelectionName.TextXAlignment = Enum.TextXAlignment.Left
	currentSelectionName.TextYAlignment = Enum.TextYAlignment.Center
	currentSelectionName.TextColor3 = Color3.new(0.5, 0.5, 0.5)
	currentSelectionName.TextWrap = true
	currentSelectionName.ZIndex = baseZIndex
	currentSelectionName.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
	currentSelectionName.Text = "Choose One"
	currentSelectionName.Parent = frame
	dropDownMenu.CurrentSelectionButton = currentSelectionName

	local icon = Instance.new('ImageLabel')
	icon.Name = "DropDownIcon"
	icon.Size = UDim2.new(0, 16, 0, 12)
	icon.Position = UDim2.new(1, -17, 0.5, -6)
	icon.Image = 'rbxasset://textures/ui/dropdown_arrow.png'
	icon.BackgroundTransparency = 1
	icon.ZIndex = baseZIndex
	icon.Parent = currentSelectionName

	local listMenu = nil
	local scrollingBackground = nil
	local visibleCount = 0
	local isOpen = false

	local function onEntrySelected()
		icon.Rotation = 0
		scrollingBackground:TweenSize(UDim2.new(1, 0, 0, currentSelectionName.AbsoluteSize.y), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.15, true)
		--
		listMenu.ScrollBarThickness = 0
		listMenu:TweenSize(UDim2.new(1, -16, 0, 24), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.15, true, function()
			if not isOpen then
				listMenu.Visible = false
				scrollingBackground.Visible = false
			end
		end)
		isOpen = false
	end

	currentSelectionName.MouseButton1Click:connect(function()
		if not currentSelectionName.Active or #currentList == 0 then return end
		if isOpen then
			onEntrySelected()
			return
		end
		--
		isOpen = true
		icon.Rotation = 180
		if listMenu then listMenu.Visible = true end
		if scrollingBackground then scrollingBackground.Visible = true end
		--
		if scrollingBackground then
			scrollingBackground:TweenSize(UDim2.new(1, 0, 0, visibleCount * 24 + 8), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.15, true)
		end
		if listMenu then
			listMenu:TweenSize(UDim2.new(1, -16, 0, visibleCount * 24), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.15, true, function()
				listMenu.ScrollBarThickness = 6
			end)
		end
	end)

	--[[ Public API ]]--
	dropDownMenu.IsOpen = function()
		return isOpen
	end

	dropDownMenu.Close = function()
		onEntrySelected()
	end

	dropDownMenu.Reset = function()
		isOpen = false
		icon.Rotation = 0
		listMenu.ScrollBarThickness = 0
		listMenu.Size = UDim2.new(1, -16, 0, 24)
		listMenu.Visible = false
		scrollingBackground.Visible = false
	end

	dropDownMenu.SetVisible = function(isVisible)
		if frame then
			frame.Visible = isVisible
		end
	end

	dropDownMenu.UpdateZIndex = function(newZIndexBase)
		currentSelectionName.ZIndex = newZIndexBase
		icon.ZIndex = newZIndexBase
		if scrollingBackground then scrollingBackground.ZIndex = newZIndexBase + 1 end
		if listMenu then
			listMenu.ZIndex = newZIndexBase + 2
			for _,child in pairs(listMenu:GetChildren()) do
				child.ZIndex = newZIndexBase + 4
			end
		end
	end

	dropDownMenu.SetActive = function(isActive)
		currentSelectionName.Active = isActive
	end

	dropDownMenu.SetSelectionText = function(text)
		currentSelectionName.Text = text
	end

	dropDownMenu.CreateList = function(list)
		currentSelectionName.Text = "Choose One"
		if listMenu then listMenu:Destroy() end
		if scrollingBackground then scrollingBackground:Destroy() end
		--
		currentList = list
		local length = #list
		visibleCount = math.min(maxVisibleList, length)
		local listMenuOffset = visibleCount * 24

		listMenu = Instance.new('ScrollingFrame')
		listMenu.Name = "ListMenu"
		listMenu.Size = UDim2.new(1, -16, 0, 24)
		listMenu.Position = UDim2.new(0, 12, 0, 32)
		listMenu.CanvasSize = UDim2.new(0, 0, 0, length * 24)
		listMenu.BackgroundTransparency = 1
		listMenu.BorderSizePixel = 0
		listMenu.ZIndex = baseZIndex + 2
		listMenu.Visible = false
		listMenu.Active = true
		listMenu.BottomImage = 'rbxasset://textures/ui/scroll-bottom.png'
		listMenu.MidImage = 'rbxasset://textures/ui/scroll-middle.png'
		listMenu.TopImage = 'rbxasset://textures/ui/scroll-top.png'
		listMenu.ScrollBarThickness = 0
		listMenu.Parent = frame

		scrollingBackground = Instance.new('TextButton')
		scrollingBackground.Name = "ScrollingBackground"
		scrollingBackground.Size = UDim2.new(1, 0, 0, currentSelectionName.AbsoluteSize.y)
		scrollingBackground.Position = UDim2.new(0, 0, 0, 28)
		scrollingBackground.BackgroundColor3 = Color3.new(1, 1, 1)
		scrollingBackground.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
		scrollingBackground.ZIndex = baseZIndex + 1
		scrollingBackground.Text = ""
		scrollingBackground.Visible = false
		scrollingBackground.AutoButtonColor = false
		scrollingBackground.Parent = frame

		for i = 1, length do
			local entry = list[i]
			local btn = Instance.new('TextButton')
			btn.Name = entry
			btn.Size = UDim2.new(1, 0, 0, 24)
			btn.Position = UDim2.new(0, 0, 0, (i - 1) * 24)
			btn.BackgroundTransparency = 0
			btn.BackgroundColor3 = Color3.new(1, 1, 1)
			btn.BorderSizePixel = 0
			btn.Font = Enum.Font.SourceSans
			btn.FontSize = Enum.FontSize.Size18
			btn.TextColor3 = Color3.new(0.5, 0.5, 0.5)
			btn.TextXAlignment = Enum.TextXAlignment.Left
			btn.TextYAlignment = Enum.TextYAlignment.Center
			btn.Text = entry
			btn.ZIndex = baseZIndex + 4
			btn.AutoButtonColor = false
			btn.Parent = listMenu

			btn.MouseButton1Click:connect(function()
				currentSelectionName.Text = btn.Text
				onEntrySelected()
				btn.Font = Enum.Font.SourceSans
				btn.TextColor3 = Color3.new(0.5, 0.5, 0.5)
				btn.BackgroundColor3 = Color3.new(1, 1, 1)
				onSelectedCallback(btn.Text)
			end)

			btn.MouseEnter:connect(function()
				btn.TextColor3 = Color3.new(1, 1, 1)
				btn.BackgroundColor3 = Color3.new(0.75, 0.75, 0.75)
			end)
			btn.MouseLeave:connect(function()
				btn.TextColor3 = Color3.new(0.5, 0.5, 0.5)
				btn.BackgroundColor3 = Color3.new(1, 1, 1)
			end)
		end
	end

	return dropDownMenu
end

t.CreateDropDownMenu = function(items, onSelect, forRoblox, whiteSkin, baseZ)
	local baseZIndex = 0
	if (type(baseZ) == "number") then
		baseZIndex = baseZ
	end
	local width = UDim.new(0, 100)
	local height = UDim.new(0, 32)

	local xPos = 0.055
	local frame = Instance.new("Frame")
	local textColor = Color3.new(1,1,1)
	if (whiteSkin) then
		textColor = Color3.new(0.5, 0.5, 0.5)
	end
	frame.Name = "DropDownMenu"
	frame.BackgroundTransparency = 1
	frame.Size = UDim2.new(width, height)

	local dropDownMenu = Instance.new("TextButton")
	dropDownMenu.Name = "DropDownMenuButton"
	dropDownMenu.TextWrap = true
	dropDownMenu.TextColor3 = textColor
	dropDownMenu.Text = "Choose One"
	dropDownMenu.Font = Enum.Font.ArialBold
	dropDownMenu.FontSize = Enum.FontSize.Size18
	dropDownMenu.TextXAlignment = Enum.TextXAlignment.Left
	dropDownMenu.TextYAlignment = Enum.TextYAlignment.Center
	dropDownMenu.BackgroundTransparency = 1
	dropDownMenu.AutoButtonColor = true
	if (whiteSkin) then
		dropDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
	else
		dropDownMenu.Style = Enum.ButtonStyle.RobloxButton
	end
	dropDownMenu.Size = UDim2.new(1,0,1,0)
	dropDownMenu.Parent = frame
	dropDownMenu.ZIndex = 2 + baseZIndex

	local dropDownIcon = Instance.new("ImageLabel")
	dropDownIcon.Name = "Icon"
	dropDownIcon.Active = false
	if (whiteSkin) then
		dropDownIcon.Image = "rbxasset://textures/ui/dropdown_arrow.png"
		dropDownIcon.Size = UDim2.new(0,16,0,12)
		dropDownIcon.Position = UDim2.new(1,-17,0.5, -6)
	else
		dropDownIcon.Image = "https://www.roblox.com/asset/?id=45732894"
		dropDownIcon.Size = UDim2.new(0,11,0,6)
		dropDownIcon.Position = UDim2.new(1,-11,0.5, -2)
	end
	dropDownIcon.BackgroundTransparency = 1
	dropDownIcon.Parent = dropDownMenu
	dropDownIcon.ZIndex = 2 + baseZIndex
	
	local itemCount = #items
	local dropDownItemCount = #items
	local useScrollButtons = false
	if dropDownItemCount > 6 then
		useScrollButtons = true
		dropDownItemCount = 6
	end
	
	local droppedDownMenu = Instance.new("TextButton")
	droppedDownMenu.Name = "List"
	droppedDownMenu.Text = ""
	droppedDownMenu.BackgroundTransparency = 1
	--droppedDownMenu.AutoButtonColor = true
	if (whiteSkin) then
		droppedDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
	else
		droppedDownMenu.Style = Enum.ButtonStyle.RobloxButton
	end
	droppedDownMenu.Visible = false
	droppedDownMenu.Active = true	--Blocks clicks
	droppedDownMenu.Position = UDim2.new(0,0,0,0)
	droppedDownMenu.Size = UDim2.new(1,0, (1 + dropDownItemCount)*.8, 0)
	droppedDownMenu.Parent = frame
	droppedDownMenu.ZIndex = 2 + baseZIndex

	local choiceButton = Instance.new("TextButton")
	choiceButton.Name = "ChoiceButton"
	choiceButton.BackgroundTransparency = 1
	choiceButton.BorderSizePixel = 0
	choiceButton.Text = "ReplaceMe"
	choiceButton.TextColor3 = textColor
	choiceButton.TextXAlignment = Enum.TextXAlignment.Left
	choiceButton.TextYAlignment = Enum.TextYAlignment.Center
	choiceButton.BackgroundColor3 = Color3.new(1, 1, 1)
	choiceButton.Font = Enum.Font.Arial
	choiceButton.FontSize = Enum.FontSize.Size18
	if useScrollButtons then
		choiceButton.Size = UDim2.new(1,-13, .8/((dropDownItemCount + 1)*.8),0) 
	else
		choiceButton.Size = UDim2.new(1, 0, .8/((dropDownItemCount + 1)*.8),0) 
	end
	choiceButton.TextWrap = true
	choiceButton.ZIndex = 2 + baseZIndex

	local areaSoak = Instance.new("TextButton")
	areaSoak.Name = "AreaSoak"
	areaSoak.Text = ""
	areaSoak.BackgroundTransparency = 1
	areaSoak.Active = true
	areaSoak.Size = UDim2.new(1,0,1,0)
	areaSoak.Visible = false
	areaSoak.ZIndex = 3 + baseZIndex

	local dropDownSelected = false

	local scrollUpButton 
	local scrollDownButton
	local scrollMouseCount = 0

	local setZIndex = function(baseZIndex)
		droppedDownMenu.ZIndex = baseZIndex +1
		if scrollUpButton then
			scrollUpButton.ZIndex = baseZIndex + 3
		end
		if scrollDownButton then
			scrollDownButton.ZIndex = baseZIndex + 3
		end
		
		local children = droppedDownMenu:GetChildren()
		if children then
			for i, child in ipairs(children) do
				if child.Name == "ChoiceButton" then
					child.ZIndex = baseZIndex + 2
				elseif child.Name == "ClickCaptureButton" then
					child.ZIndex = baseZIndex
				end
			end
		end
	end

	local scrollBarPosition = 1
	local updateScroll = function()
		if scrollUpButton then
			scrollUpButton.Active = scrollBarPosition > 1 
		end
		if scrollDownButton then
			scrollDownButton.Active = scrollBarPosition + dropDownItemCount <= itemCount 
		end

		local children = droppedDownMenu:GetChildren()
		if not children then return end

		local childNum = 1			
		for i, obj in ipairs(children) do
			if obj.Name == "ChoiceButton" then
				if childNum < scrollBarPosition or childNum >= scrollBarPosition + dropDownItemCount then
					obj.Visible = false
				else
					obj.Position = UDim2.new(0,0,((childNum-scrollBarPosition+1)*.8)/((dropDownItemCount+1)*.8),0)
					obj.Visible = true
				end
				obj.TextColor3 = textColor
				obj.BackgroundTransparency = 1

				childNum = childNum + 1
			end
		end
	end
	local toggleVisibility = function()
		dropDownSelected = not dropDownSelected

		areaSoak.Visible = not areaSoak.Visible
		dropDownMenu.Visible = not dropDownSelected
		droppedDownMenu.Visible = dropDownSelected
		if dropDownSelected then
			setZIndex(4 + baseZIndex)
		else
			setZIndex(2 + baseZIndex)
		end
		if useScrollButtons then
			updateScroll()
		end
	end
	droppedDownMenu.MouseButton1Click:connect(toggleVisibility)

	local updateSelection = function(text)
		local foundItem = false
		local children = droppedDownMenu:GetChildren()
		local childNum = 1
		if children then
			for i, obj in ipairs(children) do
				if obj.Name == "ChoiceButton" then
					if obj.Text == text then
						obj.Font = Enum.Font.ArialBold
						foundItem = true			
						scrollBarPosition = childNum						
						if (whiteSkin) then
							obj.TextColor3 = Color3.new(90/255,142/255,233/255)
						end
					else
						obj.Font = Enum.Font.Arial
						if (whiteSkin) then
							obj.TextColor3 = textColor
						end
					end
					childNum = childNum + 1
				end
			end
		end
		if not text then
			dropDownMenu.Text = "Choose One"
			scrollBarPosition = 1
		else
			if not foundItem then
				error("Invalid Selection Update -- " .. text)
			end

			if scrollBarPosition + dropDownItemCount > itemCount + 1 then
				scrollBarPosition = itemCount - dropDownItemCount + 1
			end

			dropDownMenu.Text = text
		end
	end
	
	local function scrollDown()
		if scrollBarPosition + dropDownItemCount <= itemCount then
			scrollBarPosition = scrollBarPosition + 1
			updateScroll()
			return true
		end
		return false
	end
	local function scrollUp()
		if scrollBarPosition > 1 then
			scrollBarPosition = scrollBarPosition - 1
			updateScroll()
			return true
		end
		return false
	end
	
	if useScrollButtons then
		--Make some scroll buttons
		scrollUpButton = Instance.new("ImageButton")
		scrollUpButton.Name = "ScrollUpButton"
		scrollUpButton.BackgroundTransparency = 1
		scrollUpButton.Image = "rbxasset://textures/ui/scrollbuttonUp.png"
		scrollUpButton.Size = UDim2.new(0,17,0,17) 
		scrollUpButton.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),0)
		scrollUpButton.MouseButton1Click:connect(
			function()
				scrollMouseCount = scrollMouseCount + 1
			end)
		scrollUpButton.MouseLeave:connect(
			function()
				scrollMouseCount = scrollMouseCount + 1
			end)
		scrollUpButton.MouseButton1Down:connect(
			function()
				scrollMouseCount = scrollMouseCount + 1
	
				scrollUp()
				local val = scrollMouseCount
				wait(0.5)
				while val == scrollMouseCount do
					if scrollUp() == false then
						break
					end
					wait(0.1)
				end				
			end)

		scrollUpButton.Parent = droppedDownMenu

		scrollDownButton = Instance.new("ImageButton")
		scrollDownButton.Name = "ScrollDownButton"
		scrollDownButton.BackgroundTransparency = 1
		scrollDownButton.Image = "rbxasset://textures/ui/scrollbuttonDown.png"
		scrollDownButton.Size = UDim2.new(0,17,0,17) 
		scrollDownButton.Position = UDim2.new(1,-11,1,-11)
		scrollDownButton.Parent = droppedDownMenu
		scrollDownButton.MouseButton1Click:connect(
			function()
				scrollMouseCount = scrollMouseCount + 1
			end)
		scrollDownButton.MouseLeave:connect(
			function()
				scrollMouseCount = scrollMouseCount + 1
			end)
		scrollDownButton.MouseButton1Down:connect(
			function()
				scrollMouseCount = scrollMouseCount + 1

				scrollDown()
				local val = scrollMouseCount
				wait(0.5)
				while val == scrollMouseCount do
					if scrollDown() == false then
						break
					end
					wait(0.1)
				end				
			end)	

		local scrollbar = Instance.new("ImageLabel")
		scrollbar.Name = "ScrollBar"
		scrollbar.Image = "rbxasset://textures/ui/scrollbar.png"
		scrollbar.BackgroundTransparency = 1
		scrollbar.Size = UDim2.new(0, 18, (dropDownItemCount*.8)/((dropDownItemCount+1)*.8), -(17) - 11 - 4)
		scrollbar.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),17+2)
		scrollbar.Parent = droppedDownMenu
	end

	for i,item in ipairs(items) do
		-- needed to maintain local scope for items in event listeners below
		local button = choiceButton:clone()
		if forRoblox then
			button.RobloxLocked = true
		end		
		button.Text = item
		button.Parent = droppedDownMenu
		if (whiteSkin) then
			button.TextColor3 = textColor
		end

		button.MouseButton1Click:connect(function()
			--Remove Highlight
			if (not whiteSkin) then
				button.TextColor3 = Color3.new(1,1,1)
			end
			button.BackgroundTransparency = 1

			updateSelection(item)
			onSelect(item)

			toggleVisibility()
		end)
		button.MouseEnter:connect(function()
			--Add Highlight	
			if (not whiteSkin) then
				button.TextColor3 = Color3.new(0,0,0)
			end
			button.BackgroundTransparency = 0
		end)

		button.MouseLeave:connect(function()
			--Remove Highlight
			if (not whiteSkin) then
				button.TextColor3 = Color3.new(1,1,1)
			end
			button.BackgroundTransparency = 1
		end)
	end

	--This does the initial layout of the buttons	
	updateScroll()
	
	frame.AncestryChanged:connect(function(child,parent)
		if parent == nil then
			areaSoak.Parent = nil
		else
			areaSoak.Parent = getLayerCollectorAncestor(frame)
		end
	end)

	dropDownMenu.MouseButton1Click:connect(toggleVisibility)
	areaSoak.MouseButton1Click:connect(toggleVisibility)
	return frame, updateSelection
end

t.CreatePropertyDropDownMenu = function(instance, property, enum)

	local items = enum:GetEnumItems()
	local names = {}
	local nameToItem = {}
	for i,obj in ipairs(items) do
		names[i] = obj.Name
		nameToItem[obj.Name] = obj
	end

	local frame
	local updateSelection
	frame, updateSelection = t.CreateDropDownMenu(names, function(text) instance[property] = nameToItem[text] end)

	ScopedConnect(frame, instance, "Changed", 
		function(prop)
			if prop == property then
				updateSelection(instance[property].Name)
			end
		end,
		function()
			updateSelection(instance[property].Name)
		end)

	return frame
end

t.GetFontHeight = function(font, fontSize)
	if font == nil or fontSize == nil then
		error("Font and FontSize must be non-nil")
	end
	
	local fontSizeInt = tonumber(fontSize.Name:match("%d+")) -- Clever hack to extract the size from the enum itself.

	if font == Enum.Font.Legacy then -- Legacy has a 50% bigger size.
		return math.ceil(fontSizeInt*1.5)
	else -- Size is literally just the fontSizeInt
		return fontSizeInt
	end
end

local function layoutGuiObjectsHelper(frame, guiObjects, settingsTable)
	local totalPixels = frame.AbsoluteSize.Y
	local pixelsRemaining = frame.AbsoluteSize.Y
	for i, child in ipairs(guiObjects) do
		if child:IsA("TextLabel") or child:IsA("TextButton") then
			local isLabel = child:IsA("TextLabel")
			if isLabel then
				pixelsRemaining = pixelsRemaining - settingsTable["TextLabelPositionPadY"]
			else
				pixelsRemaining = pixelsRemaining - settingsTable["TextButtonPositionPadY"]
			end
			child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
			child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, pixelsRemaining)

			if child.TextFits and child.TextBounds.Y < pixelsRemaining then
				child.Visible = true
				if isLabel then
					child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable["TextLabelSizePadY"])
				else 
					child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable["TextButtonSizePadY"])
				end

				while not child.TextFits do
					child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.AbsoluteSize.Y + 1)
				end
				pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y		

				if isLabel then
					pixelsRemaining = pixelsRemaining - settingsTable["TextLabelPositionPadY"]
				else
					pixelsRemaining = pixelsRemaining - settingsTable["TextButtonPositionPadY"]
				end
			else
				child.Visible = false
				pixelsRemaining = -1
			end			

		else
			--GuiObject
			child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
			pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
			child.Visible = (pixelsRemaining >= 0)
		end
	end
end

t.LayoutGuiObjects = function(frame, guiObjects, settingsTable)
	if not frame:IsA("GuiObject") then
		error("Frame must be a GuiObject")
	end
	for i, child in ipairs(guiObjects) do
		if not child:IsA("GuiObject") then
			error("All elements that are layed out must be of type GuiObject")
		end
	end

	if not settingsTable then
		settingsTable = {}
	end

	if not settingsTable["TextLabelSizePadY"] then
		settingsTable["TextLabelSizePadY"] = 0
	end
	if not settingsTable["TextLabelPositionPadY"] then
		settingsTable["TextLabelPositionPadY"] = 0
	end
	if not settingsTable["TextButtonSizePadY"] then
		settingsTable["TextButtonSizePadY"] = 12
	end
	if not settingsTable["TextButtonPositionPadY"] then
		settingsTable["TextButtonPositionPadY"] = 2
	end

	--Wrapper frame takes care of styled objects
	local wrapperFrame = Instance.new("Frame")
	wrapperFrame.Name = "WrapperFrame"
	wrapperFrame.BackgroundTransparency = 1
	wrapperFrame.Size = UDim2.new(1,0,1,0)
	wrapperFrame.Parent = frame

	for i, child in ipairs(guiObjects) do
		child.Parent = wrapperFrame
	end

	local recalculate = function()
		wait()
		layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
	end
	
	frame.Changed:connect(
		function(prop)
			if prop == "AbsoluteSize" then
				--Wait a heartbeat for it to sync in
				recalculate(nil)
			end
		end)
	frame.AncestryChanged:connect(recalculate)

	layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
end


t.CreateSlider = function(steps,width,position)
	local sliderGui = Instance.new("Frame")
	sliderGui.Size = UDim2.new(1,0,1,0)
	sliderGui.BackgroundTransparency = 1
	sliderGui.Name = "SliderGui"
	
	local sliderSteps = Instance.new("IntValue")
	sliderSteps.Name = "SliderSteps"
	sliderSteps.Value = steps
	sliderSteps.Parent = sliderGui
	
	local areaSoak = Instance.new("TextButton")
	areaSoak.Name = "AreaSoak"
	areaSoak.Text = ""
	areaSoak.BackgroundTransparency = 1
	areaSoak.Active = false
	areaSoak.Size = UDim2.new(1,0,1,0)
	areaSoak.Visible = false
	areaSoak.ZIndex = 4
	
	sliderGui.AncestryChanged:connect(function(child,parent)
		if parent == nil then
			areaSoak.Parent = nil
		else
			areaSoak.Parent = getLayerCollectorAncestor(sliderGui)
		end
	end)
	
	local sliderPosition = Instance.new("IntValue")
	sliderPosition.Name = "SliderPosition"
	sliderPosition.Value = 0
	sliderPosition.Parent = sliderGui
	
	local id = math.random(1,100)
	
	local bar = Instance.new("TextButton")
	bar.Text = ""
	bar.AutoButtonColor = false
	bar.Name = "Bar"
	bar.BackgroundColor3 = Color3.new(0,0,0)
	if type(width) == "number" then
		bar.Size = UDim2.new(0,width,0,5)
	else
		bar.Size = UDim2.new(0,200,0,5)
	end
	bar.BorderColor3 = Color3.new(95/255,95/255,95/255)
	bar.ZIndex = 2
	bar.Parent = sliderGui
	
	if position["X"] and position["X"]["Scale"] and position["X"]["Offset"] and position["Y"] and position["Y"]["Scale"] and position["Y"]["Offset"] then
		bar.Position = position
	end
	
	local slider = Instance.new("ImageButton")
	slider.Name = "Slider"
	slider.BackgroundTransparency = 1
	slider.Image = "rbxasset://textures/ui/Slider.png"
	slider.Position = UDim2.new(0,0,0.5,-10)
	slider.Size = UDim2.new(0,20,0,20)
	slider.ZIndex = 3
	slider.Parent = bar
	
	local areaSoakMouseMoveCon = nil
	
	areaSoak.MouseLeave:connect(function()
		if areaSoak.Visible then
			cancelSlide(areaSoak)
		end
	end)
	areaSoak.MouseButton1Up:connect(function()
		if areaSoak.Visible then
			cancelSlide(areaSoak)
		end
	end)
	
	slider.MouseButton1Down:connect(function()
		areaSoak.Visible = true
		if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
		areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
			setSliderPos(x,slider,sliderPosition,bar,steps)
		end)
	end)
	
	slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
	
	sliderPosition.Changed:connect(function(prop)
		sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
		local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
		slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
	end)
	
	bar.MouseButton1Down:connect(function(x,y)
		setSliderPos(x,slider,sliderPosition,bar,steps)
	end)
	
	return sliderGui, sliderPosition, sliderSteps

end



t.CreateSliderNew = function(steps,width,position)
	local sliderGui = Instance.new("Frame")
	sliderGui.Size = UDim2.new(1,0,1,0)
	sliderGui.BackgroundTransparency = 1
	sliderGui.Name = "SliderGui"
	
	local sliderSteps = Instance.new("IntValue")
	sliderSteps.Name = "SliderSteps"
	sliderSteps.Value = steps
	sliderSteps.Parent = sliderGui
	
	local areaSoak = Instance.new("TextButton")
	areaSoak.Name = "AreaSoak"
	areaSoak.Text = ""
	areaSoak.BackgroundTransparency = 1
	areaSoak.Active = false
	areaSoak.Size = UDim2.new(1,0,1,0)
	areaSoak.Visible = false
	areaSoak.ZIndex = 6
	
	sliderGui.AncestryChanged:connect(function(child,parent)
		if parent == nil then
			areaSoak.Parent = nil
		else
			areaSoak.Parent = getLayerCollectorAncestor(sliderGui)
		end
	end)
	
	local sliderPosition = Instance.new("IntValue")
	sliderPosition.Name = "SliderPosition"
	sliderPosition.Value = 0
	sliderPosition.Parent = sliderGui
	
	local id = math.random(1,100)
	
	local sliderBarImgHeight = 7
	local sliderBarCapImgWidth = 4

	local bar = Instance.new("ImageButton")
	bar.BackgroundTransparency = 1
	bar.Image = "rbxasset://textures/ui/Slider-BKG-Center.png"
	bar.Name = "Bar"
	local displayWidth = 200
	if type(width) == "number" then
		bar.Size = UDim2.new(0,width - (sliderBarCapImgWidth * 2),0,sliderBarImgHeight)
		displayWidth = width - (sliderBarCapImgWidth * 2)
	else
		bar.Size = UDim2.new(0,200,0,sliderBarImgHeight)
	end
	bar.ZIndex = 3
	bar.Parent = sliderGui	
	if position["X"] and position["X"]["Scale"] and position["X"]["Offset"] and position["Y"] and position["Y"]["Scale"] and position["Y"]["Offset"] then
		bar.Position = position
	end

	local barLeft = bar:clone()
	barLeft.Name = "BarLeft"
	barLeft.Image = "rbxasset://textures/ui/Slider-BKG-Left-Cap.png"
	barLeft.Size = UDim2.new(0, sliderBarCapImgWidth, 0, sliderBarImgHeight)
	barLeft.Position = UDim2.new(position.X.Scale, position.X.Offset - sliderBarCapImgWidth, position.Y.Scale, position.Y.Offset)
	barLeft.Parent = sliderGui	
	barLeft.ZIndex = 3

	local barRight = barLeft:clone()
	barRight.Name = "BarRight"
	barRight.Image = "rbxasset://textures/ui/Slider-BKG-Right-Cap.png"
	barRight.Position = UDim2.new(position.X.Scale, position.X.Offset + displayWidth, position.Y.Scale, position.Y.Offset)
	barRight.Parent = sliderGui	

	local fillLeft = barLeft:clone()
	fillLeft.Name = "FillLeft"
	fillLeft.Image = "rbxasset://textures/ui/Slider-Fill-Left-Cap.png"
	fillLeft.Parent = sliderGui	
	fillLeft.ZIndex = 4

	local fill = fillLeft:clone()
	fill.Name = "Fill"
	fill.Image = "rbxasset://textures/ui/Slider-Fill-Center.png"
	fill.Parent = bar	
	fill.ZIndex = 4
	fill.Position = UDim2.new(0, 0, 0, 0)
	fill.Size = UDim2.new(0.5, 0, 1, 0)


--	bar.Visible = false

	local slider = Instance.new("ImageButton")
	slider.Name = "Slider"
	slider.BackgroundTransparency = 1
	slider.Image = "rbxasset://textures/ui/slider_new_tab.png"
	slider.Position = UDim2.new(0,0,0.5,-14)
	slider.Size = UDim2.new(0,28,0,28)
	slider.ZIndex = 5
	slider.Parent = bar
	
	local areaSoakMouseMoveCon = nil
	
	areaSoak.MouseLeave:connect(function()
		if areaSoak.Visible then
			cancelSlide(areaSoak)
		end
	end)
	areaSoak.MouseButton1Up:connect(function()
		if areaSoak.Visible then
			cancelSlide(areaSoak)
		end
	end)
	
	slider.MouseButton1Down:connect(function()
		areaSoak.Visible = true
		if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
		areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
			setSliderPos(x,slider,sliderPosition,bar,steps)
		end)
	end)
	
	slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
	
	sliderPosition.Changed:connect(function(prop)
		sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
		local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
		slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
		fill.Size = UDim2.new(relativePosX, 0, 1, 0)
	end)
	
	bar.MouseButton1Down:connect(function(x,y)
		setSliderPos(x,slider,sliderPosition,bar,steps)
	end)

	fill.MouseButton1Down:connect(function(x,y)
		setSliderPos(x,slider,sliderPosition,bar,steps)
	end)

	fillLeft.MouseButton1Down:connect(function(x,y)
		setSliderPos(x,slider,sliderPosition,bar,steps)
	end)


	return sliderGui, sliderPosition, sliderSteps

end





t.CreateTrueScrollingFrame = function()
	local lowY = nil
	local highY = nil
	
	local dragCon = nil
	local upCon = nil

	local internalChange = false

	local descendantsChangeConMap = {}

	local scrollingFrame = Instance.new("Frame")
	scrollingFrame.Name = "ScrollingFrame"
	scrollingFrame.Active = true
	scrollingFrame.Size = UDim2.new(1,0,1,0)
	scrollingFrame.ClipsDescendants = true

	local controlFrame = Instance.new("Frame")
	controlFrame.Name = "ControlFrame"
	controlFrame.BackgroundTransparency = 1
	controlFrame.Size = UDim2.new(0,18,1,0)
	controlFrame.Position = UDim2.new(1,-20,0,0)
	controlFrame.Parent = scrollingFrame
	
	local scrollBottom = Instance.new("BoolValue")
	scrollBottom.Value = false
	scrollBottom.Name = "ScrollBottom"
	scrollBottom.Parent = controlFrame
	
	local scrollUp = Instance.new("BoolValue")
	scrollUp.Value = false
	scrollUp.Name = "scrollUp"
	scrollUp.Parent = controlFrame

	local scrollUpButton = Instance.new("TextButton")
	scrollUpButton.Name = "ScrollUpButton"
	scrollUpButton.Text = ""
	scrollUpButton.AutoButtonColor = false
	scrollUpButton.BackgroundColor3 = Color3.new(0,0,0)
	scrollUpButton.BorderColor3 = Color3.new(1,1,1)
	scrollUpButton.BackgroundTransparency = 0.5
	scrollUpButton.Size = UDim2.new(0,18,0,18)
	scrollUpButton.ZIndex = 2
	scrollUpButton.Parent = controlFrame
	for i = 1, 6 do
		local triFrame = Instance.new("Frame")
		triFrame.BorderColor3 = Color3.new(1,1,1)
		triFrame.Name = "tri" .. tostring(i)
		triFrame.ZIndex = 3
		triFrame.BackgroundTransparency = 0.5
		triFrame.Size = UDim2.new(0,12 - ((i -1) * 2),0,0)
		triFrame.Position = UDim2.new(0,3 + (i -1),0.5,2 - (i -1))
		triFrame.Parent = scrollUpButton
	end
	scrollUpButton.MouseEnter:connect(function()
		scrollUpButton.BackgroundTransparency = 0.1
		local upChildren = scrollUpButton:GetChildren()
		for i = 1, #upChildren do
			upChildren[i].BackgroundTransparency = 0.1
		end
	end)
	scrollUpButton.MouseLeave:connect(function()
		scrollUpButton.BackgroundTransparency = 0.5
		local upChildren = scrollUpButton:GetChildren()
		for i = 1, #upChildren do
			upChildren[i].BackgroundTransparency = 0.5
		end
	end)

	local scrollDownButton = scrollUpButton:clone()
	scrollDownButton.Name = "ScrollDownButton"
	scrollDownButton.Position = UDim2.new(0,0,1,-18)
	local downChildren = scrollDownButton:GetChildren()
	for i = 1, #downChildren do
		downChildren[i].Position = UDim2.new(0,3 + (i -1),0.5,-2 + (i - 1))
	end
	scrollDownButton.MouseEnter:connect(function()
		scrollDownButton.BackgroundTransparency = 0.1
		local downChildren = scrollDownButton:GetChildren()
		for i = 1, #downChildren do
			downChildren[i].BackgroundTransparency = 0.1
		end
	end)
	scrollDownButton.MouseLeave:connect(function()
		scrollDownButton.BackgroundTransparency = 0.5
		local downChildren = scrollDownButton:GetChildren()
		for i = 1, #downChildren do
			downChildren[i].BackgroundTransparency = 0.5
		end
	end)
	scrollDownButton.Parent = controlFrame
	
	local scrollTrack = Instance.new("Frame")
	scrollTrack.Name = "ScrollTrack"
	scrollTrack.BackgroundTransparency = 1
	scrollTrack.Size = UDim2.new(0,18,1,-38)
	scrollTrack.Position = UDim2.new(0,0,0,19)
	scrollTrack.Parent = controlFrame

	local scrollbar = Instance.new("TextButton")
	scrollbar.BackgroundColor3 = Color3.new(0,0,0)
	scrollbar.BorderColor3 = Color3.new(1,1,1)
	scrollbar.BackgroundTransparency = 0.5
	scrollbar.AutoButtonColor = false
	scrollbar.Text = ""
	scrollbar.Active = true
	scrollbar.Name = "ScrollBar"
	scrollbar.ZIndex = 2
	scrollbar.BackgroundTransparency = 0.5
	scrollbar.Size = UDim2.new(0, 18, 0.1, 0)
	scrollbar.Position = UDim2.new(0,0,0,0)
	scrollbar.Parent = scrollTrack

	local scrollNub = Instance.new("Frame")
	scrollNub.Name = "ScrollNub"
	scrollNub.BorderColor3 = Color3.new(1,1,1)
	scrollNub.Size = UDim2.new(0,10,0,0)
	scrollNub.Position = UDim2.new(0.5,-5,0.5,0)
	scrollNub.ZIndex = 2
	scrollNub.BackgroundTransparency = 0.5
	scrollNub.Parent = scrollbar

	local newNub = scrollNub:clone()
	newNub.Position = UDim2.new(0.5,-5,0.5,-2)
	newNub.Parent = scrollbar
	
	local lastNub = scrollNub:clone()
	lastNub.Position = UDim2.new(0.5,-5,0.5,2)
	lastNub.Parent = scrollbar

	scrollbar.MouseEnter:connect(function()
		scrollbar.BackgroundTransparency = 0.1
		scrollNub.BackgroundTransparency = 0.1
		newNub.BackgroundTransparency = 0.1
		lastNub.BackgroundTransparency = 0.1
	end)
	scrollbar.MouseLeave:connect(function()
		scrollbar.BackgroundTransparency = 0.5
		scrollNub.BackgroundTransparency = 0.5
		newNub.BackgroundTransparency = 0.5
		lastNub.BackgroundTransparency = 0.5
	end)

	local mouseDrag = Instance.new("ImageButton")
	mouseDrag.Active = false
	mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
	mouseDrag.AutoButtonColor = false
	mouseDrag.BackgroundTransparency = 1
	mouseDrag.Name = "mouseDrag"
	mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
	mouseDrag.ZIndex = 10
	
	local function positionScrollBar(x,y,offset)
		local oldPos = scrollbar.Position

		if y < scrollTrack.AbsolutePosition.y then
			scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
			return (oldPos ~= scrollbar.Position)
		end
		
		local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y

		if y > (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
			scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
			return (oldPos ~= scrollbar.Position)
		end
		local newScaleYPos = (y - scrollTrack.AbsolutePosition.y - offset)/scrollTrack.AbsoluteSize.y
		if newScaleYPos + relativeSize > 1 then
			newScaleYPos = 1 - relativeSize
			scrollBottom.Value = true
			scrollUp.Value = false
		elseif newScaleYPos <= 0 then
			newScaleYPos = 0
			scrollUp.Value = true
			scrollBottom.Value = false
		else
			scrollUp.Value = false
			scrollBottom.Value = false
		end
		scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,newScaleYPos,0)
		
		return (oldPos ~= scrollbar.Position)
	end

	local function drillDownSetHighLow(instance)
		if not instance or not instance:IsA("GuiObject") then return end
		if instance == controlFrame then return end
		if instance:IsDescendantOf(controlFrame) then return end
		if not instance.Visible then return end

		if lowY and lowY > instance.AbsolutePosition.Y then
			lowY = instance.AbsolutePosition.Y
		elseif not lowY then
			lowY = instance.AbsolutePosition.Y
		end
		if highY and highY < (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) then
			highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
		elseif not highY then
			highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
		end
		local children = instance:GetChildren()
		for i = 1, #children do
			drillDownSetHighLow(children[i])
		end
	end

	local function resetHighLow()
		local firstChildren = scrollingFrame:GetChildren()

		for i = 1, #firstChildren do
			drillDownSetHighLow(firstChildren[i])
		end
	end

	local function recalculate()
		internalChange = true

		local percentFrame = 0
		if scrollbar.Position.Y.Scale > 0 then
			if scrollbar.Visible then
				percentFrame = scrollbar.Position.Y.Scale/((scrollTrack.AbsoluteSize.Y - scrollbar.AbsoluteSize.Y)/scrollTrack.AbsoluteSize.Y)
			else
				percentFrame = 0
			end
		end
		if percentFrame > 0.99 then percentFrame = 1 end

		local hiddenYAmount = (scrollingFrame.AbsoluteSize.Y - (highY - lowY)) * percentFrame
		
		local guiChildren = scrollingFrame:GetChildren()
		for i = 1, #guiChildren do
			if guiChildren[i] ~= controlFrame then
				guiChildren[i].Position = UDim2.new(guiChildren[i].Position.X.Scale,guiChildren[i].Position.X.Offset,
					0, math.ceil(guiChildren[i].AbsolutePosition.Y) - math.ceil(lowY) + hiddenYAmount)
			end
		end

		lowY = nil
		highY = nil
		resetHighLow()
		internalChange = false
	end

	local function setSliderSizeAndPosition()
		if not highY or not lowY then return end

		local totalYSpan = math.abs(highY - lowY)
		if totalYSpan == 0 then
			scrollbar.Visible = false
			scrollDownButton.Visible = false
			scrollUpButton.Visible = false

			if dragCon then dragCon:disconnect() dragCon = nil end
			if upCon then upCon:disconnect() upCon = nil end
			return
		end

		local percentShown = scrollingFrame.AbsoluteSize.Y/totalYSpan
		if percentShown >= 1 then
			scrollbar.Visible = false
			scrollDownButton.Visible = false
			scrollUpButton.Visible = false
			recalculate()
		else
			scrollbar.Visible = true
			scrollDownButton.Visible = true
			scrollUpButton.Visible = true

			scrollbar.Size = UDim2.new(scrollbar.Size.X.Scale,scrollbar.Size.X.Offset,percentShown,0)
		end

		local percentPosition = (scrollingFrame.AbsolutePosition.Y - lowY)/totalYSpan
		scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,percentPosition,-scrollbar.AbsoluteSize.X/2)

		if scrollbar.AbsolutePosition.y < scrollTrack.AbsolutePosition.y then
			scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
		end

		if (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.Y) > (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
			local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
			scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
		end
	end
	
	local buttonScrollAmountPixels = 7
	local reentrancyGuardScrollUp = false
	local function doScrollUp()
		if reentrancyGuardScrollUp then return end
		
		reentrancyGuardScrollUp = true
			if positionScrollBar(0,scrollbar.AbsolutePosition.Y - buttonScrollAmountPixels,0) then
				recalculate()
			end
		reentrancyGuardScrollUp = false
	end
	
	local reentrancyGuardScrollDown = false
	local function doScrollDown()
		if reentrancyGuardScrollDown then return end
		
		reentrancyGuardScrollDown = true
			if positionScrollBar(0,scrollbar.AbsolutePosition.Y + buttonScrollAmountPixels,0) then
				recalculate()
			end
		reentrancyGuardScrollDown = false
	end

	local function scrollUp(mouseYPos)
		if scrollUpButton.Active then
			scrollStamp = tick()
			local current = scrollStamp
			local upCon
			upCon = mouseDrag.MouseButton1Up:connect(function()
				scrollStamp = tick()
				mouseDrag.Parent = nil
				upCon:disconnect()
			end)
			mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
			doScrollUp()
			wait(0.2)
			local t = tick()
			local w = 0.1
			while scrollStamp == current do
				doScrollUp()
				if mouseYPos and mouseYPos > scrollbar.AbsolutePosition.y then
					break
				end
				if not scrollUpButton.Active then break end
				if tick()-t > 5 then
					w = 0
				elseif tick()-t > 2 then
					w = 0.06
				end
				wait(w)
			end
		end
	end

	local function scrollDown(mouseYPos)
		if scrollDownButton.Active then
			scrollStamp = tick()
			local current = scrollStamp
			local downCon
			downCon = mouseDrag.MouseButton1Up:connect(function()
				scrollStamp = tick()
				mouseDrag.Parent = nil
				downCon:disconnect()
			end)
			mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
			doScrollDown()
			wait(0.2)
			local t = tick()
			local w = 0.1
			while scrollStamp == current do
				doScrollDown()
				if mouseYPos and mouseYPos < (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.x) then
					break
				end
				if not scrollDownButton.Active then break end
				if tick()-t > 5 then
					w = 0
				elseif tick()-t > 2 then
					w = 0.06
				end
				wait(w)
			end
		end
	end
	
	scrollbar.MouseButton1Down:connect(function(x,y)
		if scrollbar.Active then
			scrollStamp = tick()
			local mouseOffset = y - scrollbar.AbsolutePosition.y
			if dragCon then dragCon:disconnect() dragCon = nil end
			if upCon then upCon:disconnect() upCon = nil end
			local prevY = y
			local reentrancyGuardMouseScroll = false
			dragCon = mouseDrag.MouseMoved:connect(function(x,y)
				if reentrancyGuardMouseScroll then return end
				
				reentrancyGuardMouseScroll = true
					if positionScrollBar(x,y,mouseOffset) then
						recalculate()
					end
				reentrancyGuardMouseScroll = false
				
			end)
			upCon = mouseDrag.MouseButton1Up:connect(function()
				scrollStamp = tick()
				mouseDrag.Parent = nil
				dragCon:disconnect(); dragCon = nil
				upCon:disconnect(); drag = nil
			end)
			mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
		end
	end)

	local scrollMouseCount = 0

	scrollUpButton.MouseButton1Down:connect(function()
		scrollUp()
	end)
	scrollUpButton.MouseButton1Up:connect(function()
		scrollStamp = tick()
	end)

	scrollDownButton.MouseButton1Up:connect(function()
		scrollStamp = tick()
	end)
	scrollDownButton.MouseButton1Down:connect(function()
		 scrollDown()
	end)
		
	scrollbar.MouseButton1Up:connect(function()
		scrollStamp = tick()
	end)
	
	local function heightCheck(instance)
		if highY and (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) > highY then
			highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
		elseif not highY then
			highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
		end
		setSliderSizeAndPosition()
	end
	
	local function highLowRecheck()
		local oldLowY = lowY
		local oldHighY = highY
		lowY = nil
		highY = nil
		resetHighLow()

		if (lowY ~= oldLowY) or (highY ~= oldHighY) then
			setSliderSizeAndPosition()
		end
	end

	local function descendantChanged(this, prop)
		if internalChange then return end
		if not this.Visible then return end

		if prop == "Size" or prop == "Position" then
			wait()
			highLowRecheck()
		end
	end

	scrollingFrame.DescendantAdded:connect(function(instance)
		if not instance:IsA("GuiObject") then return end

		if instance.Visible then
			wait() -- wait a heartbeat for sizes to reconfig
			highLowRecheck()
		end

		descendantsChangeConMap[instance] = instance.Changed:connect(function(prop) descendantChanged(instance, prop) end)
	end)

	scrollingFrame.DescendantRemoving:connect(function(instance)
		if not instance:IsA("GuiObject") then return end
		if descendantsChangeConMap[instance] then
			descendantsChangeConMap[instance]:disconnect()
			descendantsChangeConMap[instance] = nil
		end
		wait() -- wait a heartbeat for sizes to reconfig
		highLowRecheck()
	end)
	
	scrollingFrame.Changed:connect(function(prop)
		if prop == "AbsoluteSize" then
			if not highY or not lowY then return end

			highLowRecheck()
			setSliderSizeAndPosition()
		end
	end)

	return scrollingFrame, controlFrame
end

t.CreateScrollingFrame = function(orderList,scrollStyle)
	local frame = Instance.new("Frame")
	frame.Name = "ScrollingFrame"
	frame.BackgroundTransparency = 1
	frame.Size = UDim2.new(1,0,1,0)
	
	local scrollUpButton = Instance.new("ImageButton")
	scrollUpButton.Name = "ScrollUpButton"
	scrollUpButton.BackgroundTransparency = 1
	scrollUpButton.Image = "rbxasset://textures/ui/scrollbuttonUp.png"
	scrollUpButton.Size = UDim2.new(0,17,0,17) 

	
	local scrollDownButton = Instance.new("ImageButton")
	scrollDownButton.Name = "ScrollDownButton"
	scrollDownButton.BackgroundTransparency = 1
	scrollDownButton.Image = "rbxasset://textures/ui/scrollbuttonDown.png"
	scrollDownButton.Size = UDim2.new(0,17,0,17) 
	
	local scrollbar = Instance.new("ImageButton")
	scrollbar.Name = "ScrollBar"
	scrollbar.Image = "rbxasset://textures/ui/scrollbar.png"
	scrollbar.BackgroundTransparency = 1
	scrollbar.Size = UDim2.new(0, 18, 0, 150)

	local scrollStamp = 0
		
	local scrollDrag = Instance.new("ImageButton")
	scrollDrag.Image = "https://www.roblox.com/asset/?id=61367186"
	scrollDrag.Size = UDim2.new(1, 0, 0, 16)
	scrollDrag.BackgroundTransparency = 1
	scrollDrag.Name = "ScrollDrag"
	scrollDrag.Active = true
	scrollDrag.Parent = scrollbar
	
	local mouseDrag = Instance.new("ImageButton")
	mouseDrag.Active = false
	mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
	mouseDrag.AutoButtonColor = false
	mouseDrag.BackgroundTransparency = 1
	mouseDrag.Name = "mouseDrag"
	mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
	mouseDrag.ZIndex = 10

	local style = "simple"
	if scrollStyle and tostring(scrollStyle) then
		style = scrollStyle
	end
	
	local scrollPosition = 1
	local rowSize = 0
	local howManyDisplayed = 0
		
	local layoutGridScrollBar = function()
		howManyDisplayed = 0
		local guiObjects = {}
		if orderList then
			for i, child in ipairs(orderList) do
				if child.Parent == frame then
					table.insert(guiObjects, child)
				end
			end
		else
			local children = frame:GetChildren()
			if children then
				for i, child in ipairs(children) do 
					if child:IsA("GuiObject") then
						table.insert(guiObjects, child)
					end
				end
			end
		end
		if #guiObjects == 0 then
			scrollUpButton.Active = false
			scrollDownButton.Active = false
			scrollDrag.Active = false
			scrollPosition = 1
			return
		end

		if scrollPosition > #guiObjects then
			scrollPosition = #guiObjects
		end
		
		if scrollPosition < 1 then scrollPosition = 1 end
		
		local totalPixelsY = frame.AbsoluteSize.Y
		local pixelsRemainingY = frame.AbsoluteSize.Y
		
		local totalPixelsX  = frame.AbsoluteSize.X
		
		local xCounter = 0
		local rowSizeCounter = 0
		local setRowSize = true

		local pixelsBelowScrollbar = 0
		local pos = #guiObjects
		
		local currentRowY = 0

		pos = scrollPosition
		--count up from current scroll position to fill out grid
		while pos <= #guiObjects and pixelsBelowScrollbar < totalPixelsY do
			xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
			--previous pos was the end of a row
			if xCounter >= totalPixelsX then
				pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
				currentRowY = 0
				xCounter = guiObjects[pos].AbsoluteSize.X
			end
			if guiObjects[pos].AbsoluteSize.Y > currentRowY then
				currentRowY = guiObjects[pos].AbsoluteSize.Y
			end
			pos = pos + 1
		end
		--Count wherever current row left off
		pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
		currentRowY = 0
		
		pos = scrollPosition - 1
		xCounter = 0
		
		--objects with varying X,Y dimensions can rarely cause minor errors
		--rechecking every new scrollPosition is necessary to avoid 100% of errors
		
		--count backwards from current scrollPosition to see if we can add more rows
		while pixelsBelowScrollbar + currentRowY < totalPixelsY and pos >= 1 do
			xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
			rowSizeCounter = rowSizeCounter + 1
			if xCounter >= totalPixelsX then
				rowSize = rowSizeCounter - 1
				rowSizeCounter = 0
				xCounter = guiObjects[pos].AbsoluteSize.X
				if pixelsBelowScrollbar + currentRowY <= totalPixelsY then
					--It fits, so back up our scroll position
					pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
					if scrollPosition <= rowSize then
						scrollPosition = 1 
						break
					else
						scrollPosition = scrollPosition - rowSize
					end
					currentRowY = 0
				else
					break
				end
			end
			
			if guiObjects[pos].AbsoluteSize.Y > currentRowY then
				currentRowY = guiObjects[pos].AbsoluteSize.Y
			end

			pos = pos - 1
		end
		
		--Do check last time if pos = 0
		if (pos == 0) and (pixelsBelowScrollbar + currentRowY <= totalPixelsY) then
			scrollPosition = 1
		end

		xCounter = 0
		--pos = scrollPosition
		rowSizeCounter = 0
		setRowSize = true
		local lastChildSize = 0
		
		local xOffset,yOffset = 0
		if guiObjects[1] then
			yOffset = math.ceil(math.floor(math.fmod(totalPixelsY,guiObjects[1].AbsoluteSize.X))/2)
			xOffset = math.ceil(math.floor(math.fmod(totalPixelsX,guiObjects[1].AbsoluteSize.Y))/2)
		end
		
		for i, child in ipairs(guiObjects) do
			if i < scrollPosition then
				--print("Hiding " .. child.Name)
				child.Visible = false
			else
				if pixelsRemainingY < 0 then
					--print("Out of Space " .. child.Name)
					child.Visible = false
				else
					--print("Laying out " .. child.Name)
					--GuiObject
					if setRowSize then rowSizeCounter = rowSizeCounter + 1 end
					if xCounter + child.AbsoluteSize.X >= totalPixelsX then
						if setRowSize then
							rowSize = rowSizeCounter - 1
							setRowSize = false
						end
						xCounter = 0
						pixelsRemainingY = pixelsRemainingY - child.AbsoluteSize.Y
					end
					child.Position = UDim2.new(child.Position.X.Scale,xCounter + xOffset, 0, totalPixelsY - pixelsRemainingY + yOffset)
					xCounter = xCounter + child.AbsoluteSize.X
					child.Visible = ((pixelsRemainingY - child.AbsoluteSize.Y) >= 0)
					if child.Visible then
						howManyDisplayed = howManyDisplayed + 1
					end
					lastChildSize = child.AbsoluteSize				
				end
			end
		end

		scrollUpButton.Active = (scrollPosition > 1)
		if lastChildSize == 0 then 
			scrollDownButton.Active = false
		else
			scrollDownButton.Active = ((pixelsRemainingY - lastChildSize.Y) < 0)
		end
		scrollDrag.Active = #guiObjects > howManyDisplayed
		scrollDrag.Visible = scrollDrag.Active
	end



	local layoutSimpleScrollBar = function()
		local guiObjects = {}	
		howManyDisplayed = 0
		
		if orderList then
			for i, child in ipairs(orderList) do
				if child.Parent == frame then
					table.insert(guiObjects, child)
				end
			end
		else
			local children = frame:GetChildren()
			if children then
				for i, child in ipairs(children) do 
					if child:IsA("GuiObject") then
						table.insert(guiObjects, child)
					end
				end
			end
		end
		if #guiObjects == 0 then
			scrollUpButton.Active = false
			scrollDownButton.Active = false
			scrollDrag.Active = false
			scrollPosition = 1
			return
		end

		if scrollPosition > #guiObjects then
			scrollPosition = #guiObjects
		end
		
		local totalPixels = frame.AbsoluteSize.Y
		local pixelsRemaining = frame.AbsoluteSize.Y

		local pixelsBelowScrollbar = 0
		local pos = #guiObjects
		while pixelsBelowScrollbar < totalPixels and pos >= 1 do
			if pos >= scrollPosition then
				pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
			else
				if pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y <= totalPixels then
					--It fits, so back up our scroll position
					pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
					if scrollPosition <= 1 then
						scrollPosition = 1
						break
					else
						--local ("Backing up ScrollPosition from -- " ..scrollPosition)
						scrollPosition = scrollPosition - 1
					end
				else
					break
				end
			end
			pos = pos - 1
		end

		pos = scrollPosition
		for i, child in ipairs(guiObjects) do
			if i < scrollPosition then
				--print("Hiding " .. child.Name)
				child.Visible = false
			else
				if pixelsRemaining < 0 then
					--print("Out of Space " .. child.Name)
					child.Visible = false
				else
					--print("Laying out " .. child.Name)
					--GuiObject
					child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
					pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
					if  (pixelsRemaining >= 0) then
						child.Visible = true
						howManyDisplayed = howManyDisplayed + 1
					else
						child.Visible = false
					end		
				end
			end
		end
		scrollUpButton.Active = (scrollPosition > 1)
		scrollDownButton.Active = (pixelsRemaining < 0)
		scrollDrag.Active = #guiObjects > howManyDisplayed
		scrollDrag.Visible = scrollDrag.Active
	end
	
		
	local moveDragger = function()	
		local guiObjects = 0
		local children = frame:GetChildren()
		if children then
			for i, child in ipairs(children) do 
				if child:IsA("GuiObject") then
					guiObjects = guiObjects + 1
				end
			end
		end
		
		if not scrollDrag.Parent then return end
		
		local dragSizeY = scrollDrag.Parent.AbsoluteSize.y * (1/(guiObjects - howManyDisplayed + 1))
		if dragSizeY < 16 then dragSizeY = 16 end
		scrollDrag.Size = UDim2.new(scrollDrag.Size.X.Scale,scrollDrag.Size.X.Offset,scrollDrag.Size.Y.Scale,dragSizeY)

		local relativeYPos = (scrollPosition - 1)/(guiObjects - (howManyDisplayed))
		if relativeYPos > 1 then relativeYPos = 1
		elseif relativeYPos < 0 then relativeYPos = 0 end
		local absYPos = 0
		
		if relativeYPos ~= 0 then
			absYPos = (relativeYPos * scrollbar.AbsoluteSize.y) - (relativeYPos * scrollDrag.AbsoluteSize.y)
		end
		
		scrollDrag.Position = UDim2.new(scrollDrag.Position.X.Scale,scrollDrag.Position.X.Offset,scrollDrag.Position.Y.Scale,absYPos)
	end

	local reentrancyGuard = false
	local recalculate = function()
		if reentrancyGuard then
			return
		end
		reentrancyGuard = true
		wait()
		local success, err = nil
		if style == "grid" then
			success, err = pcall(function() layoutGridScrollBar() end)
		elseif style == "simple" then
			success, err = pcall(function() layoutSimpleScrollBar() end)
		end
		if not success then print(err) end
		moveDragger()
		reentrancyGuard = false
	end
	
	local doScrollUp = function()
		scrollPosition = (scrollPosition) - rowSize
		if scrollPosition < 1 then scrollPosition = 1 end
		recalculate(nil)
	end
	
	local doScrollDown = function()
		scrollPosition = (scrollPosition) + rowSize
		recalculate(nil)
	end

	local scrollUp = function(mouseYPos)
		if scrollUpButton.Active then
			scrollStamp = tick()
			local current = scrollStamp
			local upCon
			upCon = mouseDrag.MouseButton1Up:connect(function()
				scrollStamp = tick()
				mouseDrag.Parent = nil
				upCon:disconnect()
			end)
			mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
			doScrollUp()
			wait(0.2)
			local t = tick()
			local w = 0.1
			while scrollStamp == current do
				doScrollUp()
				if mouseYPos and mouseYPos > scrollDrag.AbsolutePosition.y then
					break
				end
				if not scrollUpButton.Active then break end
				if tick()-t > 5 then
					w = 0
				elseif tick()-t > 2 then
					w = 0.06
				end
				wait(w)
			end
		end
	end

	local scrollDown = function(mouseYPos)
		if scrollDownButton.Active then
			scrollStamp = tick()
			local current = scrollStamp
			local downCon
			downCon = mouseDrag.MouseButton1Up:connect(function()
				scrollStamp = tick()
				mouseDrag.Parent = nil
				downCon:disconnect()
			end)
			mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
			doScrollDown()
			wait(0.2)
			local t = tick()
			local w = 0.1
			while scrollStamp == current do
				doScrollDown()
				if mouseYPos and mouseYPos < (scrollDrag.AbsolutePosition.y + scrollDrag.AbsoluteSize.x) then
					break
				end
				if not scrollDownButton.Active then break end
				if tick()-t > 5 then
					w = 0
				elseif tick()-t > 2 then
					w = 0.06
				end
				wait(w)
			end
		end
	end
	
	local y = 0
	scrollDrag.MouseButton1Down:connect(function(x,y)
		if scrollDrag.Active then
			scrollStamp = tick()
			local mouseOffset = y - scrollDrag.AbsolutePosition.y
			local dragCon
			local upCon
			dragCon = mouseDrag.MouseMoved:connect(function(x,y)
				local barAbsPos = scrollbar.AbsolutePosition.y
				local barAbsSize = scrollbar.AbsoluteSize.y
				
				local dragAbsSize = scrollDrag.AbsoluteSize.y
				local barAbsOne = barAbsPos + barAbsSize - dragAbsSize
				y = y - mouseOffset
				y = y < barAbsPos and barAbsPos or y > barAbsOne and barAbsOne or y
				y = y - barAbsPos
				
				local guiObjects = 0
				local children = frame:GetChildren()
				if children then
					for i, child in ipairs(children) do 
						if child:IsA("GuiObject") then
							guiObjects = guiObjects + 1
						end
					end
				end
				
				local doublePercent = y/(barAbsSize-dragAbsSize)
				local rowDiff = rowSize
				local totalScrollCount = guiObjects - (howManyDisplayed - 1)
				local newScrollPosition = math.floor((doublePercent * totalScrollCount) + 0.5) + rowDiff
				if newScrollPosition < scrollPosition then
					rowDiff = -rowDiff
				end
				
				if newScrollPosition < 1 then
					newScrollPosition = 1
				end
				
				scrollPosition = newScrollPosition
				recalculate(nil)
			end)
			upCon = mouseDrag.MouseButton1Up:connect(function()
				scrollStamp = tick()
				mouseDrag.Parent = nil
				dragCon:disconnect(); dragCon = nil
				upCon:disconnect(); drag = nil
			end)
			mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
		end
	end)

	local scrollMouseCount = 0

	scrollUpButton.MouseButton1Down:connect(
		function()
			scrollUp()
		end)
	scrollUpButton.MouseButton1Up:connect(function()
		scrollStamp = tick()
	end)


	scrollDownButton.MouseButton1Up:connect(function()
		scrollStamp = tick()
	end)
	scrollDownButton.MouseButton1Down:connect(
		function()
			scrollDown()	
		end)
		
	scrollbar.MouseButton1Up:connect(function()
		scrollStamp = tick()
	end)
	scrollbar.MouseButton1Down:connect(
		function(x,y)
			if y > (scrollDrag.AbsoluteSize.y + scrollDrag.AbsolutePosition.y) then
				scrollDown(y)
			elseif y < (scrollDrag.AbsolutePosition.y) then
				scrollUp(y)
			end
		end)


	frame.ChildAdded:connect(function()
		recalculate(nil)
	end)

	frame.ChildRemoved:connect(function()
		recalculate(nil)
	end)
	
	frame.Changed:connect(
		function(prop)
			if prop == "AbsoluteSize" then
				--Wait a heartbeat for it to sync in
				recalculate(nil)
			end
		end)
	frame.AncestryChanged:connect(function() recalculate(nil) end)

	return frame, scrollUpButton, scrollDownButton, recalculate, scrollbar
end
local function binaryGrow(min, max, fits)
	if min > max then
		return min
	end
	local biggestLegal = min

	while min <= max do
		local mid = min + math.floor((max - min) / 2)
		if fits(mid) and (biggestLegal == nil or biggestLegal < mid) then
			biggestLegal = mid
			
			--Try growing
			min = mid + 1
		else
			--Doesn't fit, shrink
			max = mid - 1
		end
	end
	return biggestLegal
end


local function binaryShrink(min, max, fits)
	if min > max then
		return min
	end
	local smallestLegal = max

	while min <= max do
		local mid = min + math.floor((max - min) / 2)
		if fits(mid) and (smallestLegal == nil or smallestLegal > mid) then
			smallestLegal = mid
			
			--It fits, shrink
			max = mid - 1			
		else
			--Doesn't fit, grow
			min = mid + 1
		end
	end
	return smallestLegal
end


local function getGuiOwner(instance)
	while instance ~= nil do
		if instance:IsA("ScreenGui") or instance:IsA("BillboardGui")  then
			return instance
		end
		instance = instance.Parent
	end
	return nil
end

t.AutoTruncateTextObject = function(textLabel)
	local text = textLabel.Text

	local fullLabel = textLabel:Clone()
	fullLabel.Name = "Full" .. textLabel.Name 
	fullLabel.BorderSizePixel = 0
	fullLabel.BackgroundTransparency = 0
	fullLabel.Text = text
	fullLabel.TextXAlignment = Enum.TextXAlignment.Center
	fullLabel.Position = UDim2.new(0,-3,0,0)
	fullLabel.Size = UDim2.new(0,100,1,0)
	fullLabel.Visible = false
	fullLabel.Parent = textLabel

	local shortText = nil
	local mouseEnterConnection = nil
	local mouseLeaveConnection= nil

	local checkForResize = function()
		if getGuiOwner(textLabel) == nil then
			return
		end
		textLabel.Text = text
		if textLabel.TextFits then 
			--Tear down the rollover if it is active
			if mouseEnterConnection then
				mouseEnterConnection:disconnect()
				mouseEnterConnection = nil
			end
			if mouseLeaveConnection then
				mouseLeaveConnection:disconnect()
				mouseLeaveConnection = nil
			end
		else
			local len = string.len(text)
			textLabel.Text = text .. "~"

			--Shrink the text
			local textSize = binaryGrow(0, len, 
				function(pos)
					if pos == 0 then
						textLabel.Text = "~"
					else
						textLabel.Text = string.sub(text, 1, pos) .. "~"
					end
					return textLabel.TextFits
				end)
			shortText = string.sub(text, 1, textSize) .. "~"
			textLabel.Text = shortText
			
			--Make sure the fullLabel fits
			if not fullLabel.TextFits then
				--Already too small, grow it really bit to start
				fullLabel.Size = UDim2.new(0, 10000, 1, 0)
			end
			
			--Okay, now try to binary shrink it back down
			local fullLabelSize = binaryShrink(textLabel.AbsoluteSize.X,fullLabel.AbsoluteSize.X, 
				function(size)
					fullLabel.Size = UDim2.new(0, size, 1, 0)
					return fullLabel.TextFits
				end)
			fullLabel.Size = UDim2.new(0,fullLabelSize+6,1,0)

			--Now setup the rollover effects, if they are currently off
			if mouseEnterConnection == nil then
				mouseEnterConnection = textLabel.MouseEnter:connect(
					function()
						fullLabel.ZIndex = textLabel.ZIndex + 1
						fullLabel.Visible = true
						--textLabel.Text = ""
					end)
			end
			if mouseLeaveConnection == nil then
				mouseLeaveConnection = textLabel.MouseLeave:connect(
					function()
						fullLabel.Visible = false
						--textLabel.Text = shortText
					end)
			end
		end
	end
	textLabel.AncestryChanged:connect(checkForResize)
	textLabel.Changed:connect(
		function(prop) 
			if prop == "AbsoluteSize" then 
				checkForResize() 	
			end 
		end)

	checkForResize()

	local function changeText(newText)
		text = newText
		fullLabel.Text = text
		checkForResize()
	end

	return textLabel, changeText
end

local function TransitionTutorialPages(fromPage, toPage, transitionFrame, currentPageValue)	
	if fromPage then
		fromPage.Visible = false
		if transitionFrame.Visible == false then
			transitionFrame.Size = fromPage.Size
			transitionFrame.Position = fromPage.Position
		end
	else
		if transitionFrame.Visible == false then
			transitionFrame.Size = UDim2.new(0.0,50,0.0,50)
			transitionFrame.Position = UDim2.new(0.5,-25,0.5,-25)
		end
	end
	transitionFrame.Visible = true
	currentPageValue.Value = nil

	local newSize, newPosition
	if toPage then
		--Make it visible so it resizes
		toPage.Visible = true

		newSize = toPage.Size
		newPosition = toPage.Position

		toPage.Visible = false
	else
		newSize = UDim2.new(0.0,50,0.0,50)
		newPosition = UDim2.new(0.5,-25,0.5,-25)
	end
	transitionFrame:TweenSizeAndPosition(newSize, newPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.3, true,
		function(state)
			if state == Enum.TweenStatus.Completed then
				transitionFrame.Visible = false
				if toPage then
					toPage.Visible = true
					currentPageValue.Value = toPage
				end
			end
		end)
end

t.CreateTutorial = function(name, tutorialKey, createButtons)
	local frame = Instance.new("Frame")
	frame.Name = "Tutorial-" .. name
	frame.BackgroundTransparency = 1
	frame.Size = UDim2.new(0.6, 0, 0.6, 0)
	frame.Position = UDim2.new(0.2, 0, 0.2, 0)

	local transitionFrame = Instance.new("Frame")
	transitionFrame.Name = "TransitionFrame"
	transitionFrame.Style = Enum.FrameStyle.RobloxRound
	transitionFrame.Size = UDim2.new(0.6, 0, 0.6, 0)
	transitionFrame.Position = UDim2.new(0.2, 0, 0.2, 0)
	transitionFrame.Visible = false
	transitionFrame.Parent = frame

	local currentPageValue = Instance.new("ObjectValue")
	currentPageValue.Name = "CurrentTutorialPage"
	currentPageValue.Value = nil
	currentPageValue.Parent = frame

	local boolValue = Instance.new("BoolValue")
	boolValue.Name = "Buttons"
	boolValue.Value = createButtons
	boolValue.Parent = frame

	local pages = Instance.new("Frame")
	pages.Name = "Pages"
	pages.BackgroundTransparency = 1
	pages.Size = UDim2.new(1,0,1,0)
	pages.Parent = frame

	local function getVisiblePageAndHideOthers()
		local visiblePage = nil
		local children = pages:GetChildren()
		if children then
			for i,child in ipairs(children) do
				if child.Visible then
					if visiblePage then
						child.Visible = false
					else
						visiblePage = child
					end
				end
			end
		end
		return visiblePage
	end

	local showTutorial = function(alwaysShow)
		if alwaysShow or UserSettings().GameSettings:GetTutorialState(tutorialKey) == false then
			print("Showing tutorial-",tutorialKey)
			local currentTutorialPage = getVisiblePageAndHideOthers()

			local firstPage = pages:FindFirstChild("TutorialPage1")
			if firstPage then
				TransitionTutorialPages(currentTutorialPage, firstPage, transitionFrame, currentPageValue)	
			else
				error("Could not find TutorialPage1")
			end
		end
	end

	local dismissTutorial = function()
		local currentTutorialPage = getVisiblePageAndHideOthers()

		if currentTutorialPage then
			TransitionTutorialPages(currentTutorialPage, nil, transitionFrame, currentPageValue)
		end

		UserSettings().GameSettings:SetTutorialState(tutorialKey, true)
	end

	local gotoPage = function(pageNum)
		local page = pages:FindFirstChild("TutorialPage" .. pageNum)
		local currentTutorialPage = getVisiblePageAndHideOthers()
		TransitionTutorialPages(currentTutorialPage, page, transitionFrame, currentPageValue)
	end

	return frame, showTutorial, dismissTutorial, gotoPage
end 

local function CreateBasicTutorialPage(name, handleResize, skipTutorial, giveDoneButton)
	local frame = Instance.new("Frame")
	frame.Name = "TutorialPage"
	frame.Style = Enum.FrameStyle.RobloxRound
	frame.Size = UDim2.new(0.6, 0, 0.6, 0)
	frame.Position = UDim2.new(0.2, 0, 0.2, 0)
	frame.Visible = false
	
	local frameHeader = Instance.new("TextLabel")
	frameHeader.Name = "Header"
	frameHeader.Text = name
	frameHeader.BackgroundTransparency = 1
	frameHeader.FontSize = Enum.FontSize.Size24
	frameHeader.Font = Enum.Font.ArialBold
	frameHeader.TextColor3 = Color3.new(1,1,1)
	frameHeader.TextXAlignment = Enum.TextXAlignment.Center
	frameHeader.TextWrap = true
	frameHeader.Size = UDim2.new(1,-55, 0, 22)
	frameHeader.Position = UDim2.new(0,0,0,0)
	frameHeader.Parent = frame

	local skipButton = Instance.new("ImageButton")
	skipButton.Name = "SkipButton"
	skipButton.AutoButtonColor = false
	skipButton.BackgroundTransparency = 1
	skipButton.Image = "rbxasset://textures/ui/closeButton.png"
	skipButton.MouseButton1Click:connect(function()
		skipTutorial()
	end)
	skipButton.MouseEnter:connect(function()
		skipButton.Image = "rbxasset://textures/ui/closeButton_dn.png"
	end)
	skipButton.MouseLeave:connect(function()
		skipButton.Image = "rbxasset://textures/ui/closeButton.png"
	end)
	skipButton.Size = UDim2.new(0, 25, 0, 25)
	skipButton.Position = UDim2.new(1, -25, 0, 0)
	skipButton.Parent = frame
	
	
	if giveDoneButton then
		local doneButton = Instance.new("TextButton")
		doneButton.Name = "DoneButton"
		doneButton.Style = Enum.ButtonStyle.RobloxButtonDefault
		doneButton.Text = "Done"
		doneButton.TextColor3 = Color3.new(1,1,1)
		doneButton.Font = Enum.Font.ArialBold
		doneButton.FontSize = Enum.FontSize.Size18
		doneButton.Size = UDim2.new(0,100,0,50)
		doneButton.Position = UDim2.new(0.5,-50,1,-50)
		
		if skipTutorial then
			doneButton.MouseButton1Click:connect(function() skipTutorial() end)
		end
		
		doneButton.Parent = frame
	end

	local innerFrame = Instance.new("Frame")
	innerFrame.Name = "ContentFrame"
	innerFrame.BackgroundTransparency = 1
	innerFrame.Position = UDim2.new(0,0,0,25)
	innerFrame.Parent = frame

	local nextButton = Instance.new("TextButton")
	nextButton.Name = "NextButton"
	nextButton.Text = "Next"
	nextButton.TextColor3 = Color3.new(1,1,1)
	nextButton.Font = Enum.Font.Arial
	nextButton.FontSize = Enum.FontSize.Size18
	nextButton.Style = Enum.ButtonStyle.RobloxButtonDefault
	nextButton.Size = UDim2.new(0,80, 0, 32)
	nextButton.Position = UDim2.new(0.5, 5, 1, -32)
	nextButton.Active = false
	nextButton.Visible = false
	nextButton.Parent = frame

	local prevButton = Instance.new("TextButton")
	prevButton.Name = "PrevButton"
	prevButton.Text = "Previous"
	prevButton.TextColor3 = Color3.new(1,1,1)
	prevButton.Font = Enum.Font.Arial
	prevButton.FontSize = Enum.FontSize.Size18
	prevButton.Style = Enum.ButtonStyle.RobloxButton
	prevButton.Size = UDim2.new(0,80, 0, 32)
	prevButton.Position = UDim2.new(0.5, -85, 1, -32)
	prevButton.Active = false
	prevButton.Visible = false
	prevButton.Parent = frame

	if giveDoneButton then
		innerFrame.Size = UDim2.new(1,0,1,-75)
	else
		innerFrame.Size = UDim2.new(1,0,1,-22)
	end

	local parentConnection = nil

	local function basicHandleResize()
		if frame.Visible and frame.Parent then
			local maxSize = math.min(frame.Parent.AbsoluteSize.X, frame.Parent.AbsoluteSize.Y)
			handleResize(200,maxSize)
		end
	end

	frame.Changed:connect(
		function(prop)
			if prop == "Parent" then
				if parentConnection ~= nil then
					parentConnection:disconnect()
					parentConnection = nil
				end
				if frame.Parent and frame.Parent:IsA("GuiObject") then
					parentConnection = frame.Parent.Changed:connect(
						function(parentProp)
							if parentProp == "AbsoluteSize" then
								wait()
								basicHandleResize()
							end
						end)
					basicHandleResize()
				end
			end

			if prop == "Visible" then 
				basicHandleResize()
			end
		end)

	return frame, innerFrame
end

t.CreateTextTutorialPage = function(name, text, skipTutorialFunc)
	local frame = nil
	local contentFrame = nil

	local textLabel = Instance.new("TextLabel")
	textLabel.BackgroundTransparency = 1
	textLabel.TextColor3 = Color3.new(1,1,1)
	textLabel.Text = text
	textLabel.TextWrap = true
	textLabel.TextXAlignment = Enum.TextXAlignment.Left
	textLabel.TextYAlignment = Enum.TextYAlignment.Center
	textLabel.Font = Enum.Font.Arial
	textLabel.FontSize = Enum.FontSize.Size14
	textLabel.Size = UDim2.new(1,0,1,0)

	local function handleResize(minSize, maxSize)
		size = binaryShrink(minSize, maxSize,
			function(size)
				frame.Size = UDim2.new(0, size, 0, size)
				return textLabel.TextFits
			end)
		frame.Size = UDim2.new(0, size, 0, size)
		frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
	end

	frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc)
	textLabel.Parent = contentFrame

	return frame
end

t.CreateImageTutorialPage = function(name, imageAsset, x, y, skipTutorialFunc, giveDoneButton)
	local frame = nil
	local contentFrame = nil

	local imageLabel = Instance.new("ImageLabel")
	imageLabel.BackgroundTransparency = 1
	imageLabel.Image = imageAsset
	imageLabel.Size = UDim2.new(0,x,0,y)
	imageLabel.Position = UDim2.new(0.5,-x/2,0.5,-y/2)

	local function handleResize(minSize, maxSize)
		size = binaryShrink(minSize, maxSize,
			function(size)
				return size >= x and size >= y
			end)
		if size >= x and size >= y then
			imageLabel.Size = UDim2.new(0,x, 0,y)
			imageLabel.Position = UDim2.new(0.5,-x/2, 0.5, -y/2)
		else
			if x > y then
				--X is limiter, so 
				imageLabel.Size = UDim2.new(1,0,y/x,0)
				imageLabel.Position = UDim2.new(0,0, 0.5 - (y/x)/2, 0)
			else
				--Y is limiter
				imageLabel.Size = UDim2.new(x/y,0,1, 0)
				imageLabel.Position = UDim2.new(0.5-(x/y)/2, 0, 0, 0)
			end
		end
		size = size + 50
		frame.Size = UDim2.new(0, size, 0, size)
		frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
	end

	frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc, giveDoneButton)
	imageLabel.Parent = contentFrame

	return frame
end

t.AddTutorialPage = function(tutorial, tutorialPage)
	local transitionFrame = tutorial.TransitionFrame
	local currentPageValue = tutorial.CurrentTutorialPage

	if not tutorial.Buttons.Value then
		tutorialPage.NextButton.Parent = nil
		tutorialPage.PrevButton.Parent = nil
	end

	local children = tutorial.Pages:GetChildren()
	if children and #children > 0 then
		tutorialPage.Name = "TutorialPage" .. (#children+1)
		local previousPage = children[#children]
		if not previousPage:IsA("GuiObject") then
			error("All elements under Pages must be GuiObjects")
		end

		if tutorial.Buttons.Value then
			if previousPage.NextButton.Active then
				error("NextButton already Active on previousPage, please only add pages with RbxGui.AddTutorialPage function")
			end
			previousPage.NextButton.MouseButton1Click:connect(
				function()
					TransitionTutorialPages(previousPage, tutorialPage, transitionFrame, currentPageValue)
				end)
			previousPage.NextButton.Active = true
			previousPage.NextButton.Visible = true

			if tutorialPage.PrevButton.Active then
				error("PrevButton already Active on tutorialPage, please only add pages with RbxGui.AddTutorialPage function")
			end
			tutorialPage.PrevButton.MouseButton1Click:connect(
				function()
					TransitionTutorialPages(tutorialPage, previousPage, transitionFrame, currentPageValue)
				end)
			tutorialPage.PrevButton.Active = true
			tutorialPage.PrevButton.Visible = true
		end

		tutorialPage.Parent = tutorial.Pages
	else
		--First child
		tutorialPage.Name = "TutorialPage1"
		tutorialPage.Parent = tutorial.Pages
	end
end 

t.CreateSetPanel = function(userIdsForSets, objectSelected, dialogClosed, size, position, showAdminCategories, useAssetVersionId)

	if not userIdsForSets then
		error("CreateSetPanel: userIdsForSets (first arg) is nil, should be a table of number ids")
	end
	if type(userIdsForSets) ~= "table" and type(userIdsForSets) ~= "userdata" then
		error("CreateSetPanel: userIdsForSets (first arg) is of type " ..type(userIdsForSets) .. ", should be of type table or userdata")
	end
	if not objectSelected then
		error("CreateSetPanel: objectSelected (second arg) is nil, should be a callback function!")
	end
	if type(objectSelected) ~= "function" then
		error("CreateSetPanel: objectSelected (second arg) is of type " .. type(objectSelected) .. ", should be of type function!")
	end
	if dialogClosed and type(dialogClosed) ~= "function" then
		error("CreateSetPanel: dialogClosed (third arg) is of type " .. type(dialogClosed) .. ", should be of type function!")
	end
	
	if showAdminCategories == nil then -- by default, don't show beta sets
		showAdminCategories = false
	end

	local arrayPosition = 1
	local insertButtons = {}
	local insertButtonCons = {}
	local contents = nil
	local setGui = nil

	-- used for water selections
	local waterForceDirection = "NegX"
	local waterForce = "None"
	local waterGui, waterTypeChangedEvent = nil
	
	local Data = {}
	Data.CurrentCategory = nil
	Data.Category = {}
	local SetCache = {}
	
	local userCategoryButtons = nil
	
	local buttonWidth = 64
	local buttonHeight = buttonWidth
	
	local SmallThumbnailUrl = nil
	local LargeThumbnailUrl = nil
	local BaseUrl = game:GetService("ContentProvider").BaseUrl:lower()
	local AssetGameUrl = string.gsub(BaseUrl, "www", "assetgame")
	
	if useAssetVersionId then
		LargeThumbnailUrl = AssetGameUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&wd=420&ht=420&assetversionid="
		SmallThumbnailUrl = AssetGameUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&wd=75&ht=75&assetversionid="
	else
		LargeThumbnailUrl = AssetGameUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&wd=420&ht=420&aid="
		SmallThumbnailUrl = AssetGameUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&wd=75&ht=75&aid="
	end
		
	local function drillDownSetZIndex(parent, index)
		local children = parent:GetChildren()
		for i = 1, #children do
			if children[i]:IsA("GuiObject") then
				children[i].ZIndex = index
			end
			drillDownSetZIndex(children[i], index)
		end
	end
	
	-- for terrain stamping
	local currTerrainDropDownFrame = nil
	local terrainShapes = {"Block","Vertical Ramp","Corner Wedge","Inverse Corner Wedge","Horizontal Ramp","Auto-Wedge"}
	local terrainShapeMap = {}
	for i = 1, #terrainShapes do
		terrainShapeMap[terrainShapes[i]] = i - 1
	end	
	terrainShapeMap[terrainShapes[#terrainShapes]] = 6

	local function createWaterGui()
		local waterForceDirections = {"NegX","X","NegY","Y","NegZ","Z"}
		local waterForces = {"None", "Small", "Medium", "Strong", "Max"}

		local waterFrame = Instance.new("Frame")
		waterFrame.Name = "WaterFrame"
		waterFrame.Style = Enum.FrameStyle.RobloxSquare
		waterFrame.Size = UDim2.new(0,150,0,110)
		waterFrame.Visible = false

		local waterForceLabel = Instance.new("TextLabel")
		waterForceLabel.Name = "WaterForceLabel"
		waterForceLabel.BackgroundTransparency = 1
		waterForceLabel.Size = UDim2.new(1,0,0,12)
		waterForceLabel.Font = Enum.Font.ArialBold
		waterForceLabel.FontSize = Enum.FontSize.Size12
		waterForceLabel.TextColor3 = Color3.new(1,1,1)
		waterForceLabel.TextXAlignment = Enum.TextXAlignment.Left
		waterForceLabel.Text = "Water Force"
		waterForceLabel.Parent = waterFrame

		local waterForceDirLabel = waterForceLabel:Clone()
		waterForceDirLabel.Name = "WaterForceDirectionLabel"
		waterForceDirLabel.Text = "Water Force Direction"
		waterForceDirLabel.Position = UDim2.new(0,0,0,50)
		waterForceDirLabel.Parent = waterFrame

		local waterTypeChangedEvent = Instance.new("BindableEvent",waterFrame)
		waterTypeChangedEvent.Name = "WaterTypeChangedEvent"

		local waterForceDirectionSelectedFunc = function(newForceDirection)
			waterForceDirection = newForceDirection
			waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
		end
		local waterForceSelectedFunc = function(newForce)
			waterForce = newForce
			waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
		end

		local waterForceDirectionDropDown, forceWaterDirectionSelection = t.CreateDropDownMenu(waterForceDirections, waterForceDirectionSelectedFunc)
		waterForceDirectionDropDown.Size = UDim2.new(1,0,0,25)
		waterForceDirectionDropDown.Position = UDim2.new(0,0,1,3)
		forceWaterDirectionSelection("NegX")
		waterForceDirectionDropDown.Parent = waterForceDirLabel

		local waterForceDropDown, forceWaterForceSelection = t.CreateDropDownMenu(waterForces, waterForceSelectedFunc)
		forceWaterForceSelection("None")
		waterForceDropDown.Size = UDim2.new(1,0,0,25)
		waterForceDropDown.Position = UDim2.new(0,0,1,3)
		waterForceDropDown.Parent = waterForceLabel

		return waterFrame, waterTypeChangedEvent
	end

	-- Helper Function that contructs gui elements
	local function createSetGui()
	
		local setGui = Instance.new("ScreenGui")
		setGui.Name = "SetGui"
		
		local setPanel = Instance.new("Frame")
		setPanel.Name = "SetPanel"
		setPanel.Active = true
		setPanel.BackgroundTransparency = 1
		if position then
			setPanel.Position = position
		else
			setPanel.Position = UDim2.new(0.2, 29, 0.1, 24)
		end
		if size then
			setPanel.Size = size
		else
			setPanel.Size = UDim2.new(0.6, -58, 0.64, 0)
		end
		setPanel.Style = Enum.FrameStyle.RobloxRound
		setPanel.ZIndex = 6
		setPanel.Parent = setGui
		
			-- Children of SetPanel
			local itemPreview = Instance.new("Frame")
			itemPreview.Name = "ItemPreview"
			itemPreview.BackgroundTransparency = 1
			itemPreview.Position = UDim2.new(0.8,5,0.085,0)
			itemPreview.Size = UDim2.new(0.21,0,0.9,0)
			itemPreview.ZIndex = 6
			itemPreview.Parent = setPanel
			
				-- Children of ItemPreview
				local textPanel = Instance.new("Frame")
				textPanel.Name = "TextPanel"
				textPanel.BackgroundTransparency = 1
				textPanel.Position = UDim2.new(0,0,0.45,0)
				textPanel.Size = UDim2.new(1,0,0.55,0)
				textPanel.ZIndex = 6
				textPanel.Parent = itemPreview
					
					-- Children of TextPanel
					local rolloverText = Instance.new("TextLabel")
					rolloverText.Name = "RolloverText"
					rolloverText.BackgroundTransparency = 1
					rolloverText.Size = UDim2.new(1,0,0,48)
					rolloverText.ZIndex = 6
					rolloverText.Font = Enum.Font.ArialBold
					rolloverText.FontSize = Enum.FontSize.Size24
					rolloverText.Text = ""
					rolloverText.TextColor3 = Color3.new(1,1,1)
					rolloverText.TextWrap = true
					rolloverText.TextXAlignment = Enum.TextXAlignment.Left
					rolloverText.TextYAlignment = Enum.TextYAlignment.Top
					rolloverText.Parent = textPanel
					
				local largePreview = Instance.new("ImageLabel")
				largePreview.Name = "LargePreview"
				largePreview.BackgroundTransparency = 1
				largePreview.Image = ""
				largePreview.Size = UDim2.new(1,0,0,170)
				largePreview.ZIndex = 6
				largePreview.Parent = itemPreview
				
			local sets = Instance.new("Frame")
			sets.Name = "Sets"
			sets.BackgroundTransparency = 1
			sets.Position = UDim2.new(0,0,0,5)
			sets.Size = UDim2.new(0.23,0,1,-5)
			sets.ZIndex = 6
			sets.Parent = setPanel
			
				-- Children of Sets
				local line = Instance.new("Frame")
				line.Name = "Line"
				line.BackgroundColor3 = Color3.new(1,1,1)
				line.BackgroundTransparency = 0.7
				line.BorderSizePixel = 0
				line.Position = UDim2.new(1,-3,0.06,0)
				line.Size = UDim2.new(0,3,0.9,0)
				line.ZIndex = 6
				line.Parent = sets
				
				local setsLists, controlFrame = t.CreateTrueScrollingFrame()
				setsLists.Size = UDim2.new(1,-6,0.94,0)
				setsLists.Position = UDim2.new(0,0,0.06,0)
				setsLists.BackgroundTransparency = 1
				setsLists.Name = "SetsLists"
				setsLists.ZIndex = 6
				setsLists.Parent = sets
				drillDownSetZIndex(controlFrame, 7)
					
				local setsHeader = Instance.new("TextLabel")
				setsHeader.Name = "SetsHeader"
				setsHeader.BackgroundTransparency = 1
				setsHeader.Size = UDim2.new(0,47,0,24)
				setsHeader.ZIndex = 6
				setsHeader.Font = Enum.Font.ArialBold
				setsHeader.FontSize = Enum.FontSize.Size24
				setsHeader.Text = "Sets"
				setsHeader.TextColor3 = Color3.new(1,1,1)
				setsHeader.TextXAlignment = Enum.TextXAlignment.Left
				setsHeader.TextYAlignment = Enum.TextYAlignment.Top
				setsHeader.Parent = sets
			
			local cancelButton = Instance.new("TextButton")
			cancelButton.Name = "CancelButton"
			cancelButton.Position = UDim2.new(1,-32,0,-2)
			cancelButton.Size = UDim2.new(0,34,0,34)
			cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault
			cancelButton.ZIndex = 6
			cancelButton.Text = ""
			cancelButton.Modal = true
			cancelButton.Parent = setPanel
			
				-- Children of Cancel Button
				local cancelImage = Instance.new("ImageLabel")
				cancelImage.Name = "CancelImage"
				cancelImage.BackgroundTransparency = 1
				cancelImage.Image = "https://www.roblox.com/asset/?id=54135717"
				cancelImage.Position = UDim2.new(0,-2,0,-2)
				cancelImage.Size = UDim2.new(0,16,0,16)
				cancelImage.ZIndex = 6
				cancelImage.Parent = cancelButton
					
		return setGui
	end
	
	local function createSetButton(text)
		local setButton = Instance.new("TextButton")
		
		if text then setButton.Text = text
		else setButton.Text = "" end
		
		setButton.AutoButtonColor = false
		setButton.BackgroundTransparency = 1
		setButton.BackgroundColor3 = Color3.new(1,1,1)
		setButton.BorderSizePixel = 0
		setButton.Size = UDim2.new(1,-5,0,18)
		setButton.ZIndex = 6
		setButton.Visible = false
		setButton.Font = Enum.Font.Arial
		setButton.FontSize = Enum.FontSize.Size18
		setButton.TextColor3 = Color3.new(1,1,1)
		setButton.TextXAlignment = Enum.TextXAlignment.Left
		
		return setButton
	end
	
	local function buildSetButton(name, setId, setImageId, i,  count)
		local button = createSetButton(name)
		button.Text = name
		button.Name = "SetButton"
		button.Visible = true
		
		local setValue = Instance.new("IntValue")
		setValue.Name = "SetId"
		setValue.Value = setId
		setValue.Parent = button

		local setName = Instance.new("StringValue")
		setName.Name = "SetName"
		setName.Value = name
		setName.Parent = button

		return button
	end
	
	local function processCategory(sets)
		local setButtons = {}
		local numSkipped = 0
		for i = 1, #sets do
			if not showAdminCategories and sets[i].Name == "Beta" then
				numSkipped = numSkipped + 1
			else
				setButtons[i - numSkipped] = buildSetButton(sets[i].Name, sets[i].CategoryId, sets[i].ImageAssetId, i - numSkipped, #sets)
			end
		end
		return setButtons
	end
	
	local function handleResize()
		wait() -- neccessary to insure heartbeat happened
		
		local itemPreview = setGui.SetPanel.ItemPreview
		
		itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
		itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
		itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
		itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
	end
	
	local function makeInsertAssetButton()
		local insertAssetButtonExample = Instance.new("Frame")
		insertAssetButtonExample.Name = "InsertAssetButtonExample"
		insertAssetButtonExample.Position = UDim2.new(0,128,0,64)
		insertAssetButtonExample.Size = UDim2.new(0,64,0,64)
		insertAssetButtonExample.BackgroundTransparency = 1
		insertAssetButtonExample.ZIndex = 6
		insertAssetButtonExample.Visible = false

		local assetId = Instance.new("IntValue")
		assetId.Name = "AssetId"
		assetId.Value = 0
		assetId.Parent = insertAssetButtonExample
		
		local assetName = Instance.new("StringValue")
		assetName.Name = "AssetName"
		assetName.Value = ""
		assetName.Parent = insertAssetButtonExample

		local button = Instance.new("TextButton")
		button.Name = "Button"
		button.Text = ""
		button.Style = Enum.ButtonStyle.RobloxButton
		button.Position = UDim2.new(0.025,0,0.025,0)
		button.Size = UDim2.new(0.95,0,0.95,0)
		button.ZIndex = 6
		button.Parent = insertAssetButtonExample

		local buttonImage = Instance.new("ImageLabel")
		buttonImage.Name = "ButtonImage"
		buttonImage.Image = ""
		buttonImage.Position = UDim2.new(0,-7,0,-7)
		buttonImage.Size = UDim2.new(1,14,1,14)
		buttonImage.BackgroundTransparency = 1
		buttonImage.ZIndex = 7
		buttonImage.Parent = button

		local configIcon = buttonImage:clone()
		configIcon.Name = "ConfigIcon"
		configIcon.Visible = false
		configIcon.Position = UDim2.new(1,-23,1,-24)
		configIcon.Size = UDim2.new(0,16,0,16)
		configIcon.Image = ""
		configIcon.ZIndex = 6
		configIcon.Parent = insertAssetButtonExample
		
		return insertAssetButtonExample
	end
	
	local function showLargePreview(insertButton)
		if insertButton:FindFirstChild("AssetId") then
			delay(0,function()
				game:GetService("ContentProvider"):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
				setGui.SetPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
			end)
		end
		if insertButton:FindFirstChild("AssetName") then
			setGui.SetPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
		end
	end
	
	local function selectTerrainShape(shape)
		if currTerrainDropDownFrame then
			objectSelected(tostring(currTerrainDropDownFrame.AssetName.Value), tonumber(currTerrainDropDownFrame.AssetId.Value), shape)
		end
	end
	
	local function createTerrainTypeButton(name, parent)
		local dropDownTextButton = Instance.new("TextButton")
		dropDownTextButton.Name = name .. "Button"
		dropDownTextButton.Font = Enum.Font.ArialBold
		dropDownTextButton.FontSize = Enum.FontSize.Size14
		dropDownTextButton.BorderSizePixel = 0
		dropDownTextButton.TextColor3 = Color3.new(1,1,1)
		dropDownTextButton.Text = name
		dropDownTextButton.TextXAlignment = Enum.TextXAlignment.Left
		dropDownTextButton.BackgroundTransparency = 1
		dropDownTextButton.ZIndex = parent.ZIndex + 1
		dropDownTextButton.Size = UDim2.new(0,parent.Size.X.Offset - 2,0,16)
		dropDownTextButton.Position = UDim2.new(0,1,0,0)

		dropDownTextButton.MouseEnter:connect(function()
			dropDownTextButton.BackgroundTransparency = 0
			dropDownTextButton.TextColor3 = Color3.new(0,0,0)
		end)

		dropDownTextButton.MouseLeave:connect(function()
			dropDownTextButton.BackgroundTransparency = 1
			dropDownTextButton.TextColor3 = Color3.new(1,1,1)
		end)

		dropDownTextButton.MouseButton1Click:connect(function()
			dropDownTextButton.BackgroundTransparency = 1
			dropDownTextButton.TextColor3 = Color3.new(1,1,1)
			if dropDownTextButton.Parent and dropDownTextButton.Parent:IsA("GuiObject") then
				dropDownTextButton.Parent.Visible = false
			end
			selectTerrainShape(terrainShapeMap[dropDownTextButton.Text])
		end)

		return dropDownTextButton
	end
	
	local function createTerrainDropDownMenu(zIndex)
		local dropDown = Instance.new("Frame")
		dropDown.Name = "TerrainDropDown"
		dropDown.BackgroundColor3 = Color3.new(0,0,0)
		dropDown.BorderColor3 = Color3.new(1,0,0)
		dropDown.Size = UDim2.new(0,200,0,0)
		dropDown.Visible = false
		dropDown.ZIndex = zIndex
		dropDown.Parent = setGui

		for i = 1, #terrainShapes do
			local shapeButton = createTerrainTypeButton(terrainShapes[i],dropDown)
			shapeButton.Position = UDim2.new(0,1,0,(i - 1) * (shapeButton.Size.Y.Offset))
			shapeButton.Parent = dropDown
			dropDown.Size = UDim2.new(0,200,0,dropDown.Size.Y.Offset + (shapeButton.Size.Y.Offset))
		end

		dropDown.MouseLeave:connect(function()
			dropDown.Visible = false
		end)
	end

	
	local function createDropDownMenuButton(parent)
		local dropDownButton = Instance.new("ImageButton")
		dropDownButton.Name = "DropDownButton"
		dropDownButton.Image = "https://www.roblox.com/asset/?id=67581509"
		dropDownButton.BackgroundTransparency = 1
		dropDownButton.Size = UDim2.new(0,16,0,16)
		dropDownButton.Position = UDim2.new(1,-24,0,6)
		dropDownButton.ZIndex = parent.ZIndex + 2
		dropDownButton.Parent = parent
		
		if not setGui:FindFirstChild("TerrainDropDown") then
			createTerrainDropDownMenu(8)
		end
		
		dropDownButton.MouseButton1Click:connect(function()
			setGui.TerrainDropDown.Visible = true
			setGui.TerrainDropDown.Position = UDim2.new(0,parent.AbsolutePosition.X,0,parent.AbsolutePosition.Y)
			currTerrainDropDownFrame = parent
		end)
	end
	
	local function buildInsertButton()
		local insertButton = makeInsertAssetButton()
		insertButton.Name = "InsertAssetButton"
		insertButton.Visible = true

		if Data.Category[Data.CurrentCategory].SetName == "High Scalability" then
			createDropDownMenuButton(insertButton)
		end

		local lastEnter = nil
		local mouseEnterCon = insertButton.MouseEnter:connect(function()
			lastEnter = insertButton
			delay(0.1,function()
				if lastEnter == insertButton then
					showLargePreview(insertButton)
				end
			end)
		end)
		return insertButton, mouseEnterCon
	end
	
	local function realignButtonGrid(columns)
		local x = 0
		local y = 0 
		for i = 1, #insertButtons do
			insertButtons[i].Position = UDim2.new(0, buttonWidth * x, 0, buttonHeight * y)
			x = x + 1
			if x >= columns then
				x = 0
				y = y + 1
			end
		end
	end

	local function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
		if visible then
			insertFrame.AssetName.Value = name
			insertFrame.AssetId.Value = assetId
			local newImageUrl = SmallThumbnailUrl  .. assetId
			if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
				delay(0,function()
					game:GetService("ContentProvider"):Preload(SmallThumbnailUrl  .. assetId)
					if insertFrame:findFirstChild("Button") then
						insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
					end
				end)
			end
			table.insert(insertButtonCons,
				insertFrame.Button.MouseButton1Click:connect(function()
					-- special case for water, show water selection gui
					local isWaterSelected = (name == "Water") and (Data.Category[Data.CurrentCategory].SetName == "High Scalability")
					waterGui.Visible = isWaterSelected
					if isWaterSelected then
						objectSelected(name, tonumber(assetId), nil)
					else
						objectSelected(name, tonumber(assetId))
					end
				end)
			)
			insertFrame.Visible = true
		else
			insertFrame.Visible = false
		end
	end
	
	local function loadSectionOfItems(setGui, rows, columns)
		local pageSize = rows * columns

		if arrayPosition > #contents then return end

		local origArrayPos = arrayPosition

		local yCopy = 0
		for i = 1, pageSize + 1 do 
			if arrayPosition >= #contents + 1 then
				break
			end

			local buttonCon
			insertButtons[arrayPosition], buttonCon = buildInsertButton()
			table.insert(insertButtonCons,buttonCon)
			insertButtons[arrayPosition].Parent = setGui.SetPanel.ItemsFrame
			arrayPosition = arrayPosition + 1
		end
		realignButtonGrid(columns)

		local indexCopy = origArrayPos
		for index = origArrayPos, arrayPosition do
			if insertButtons[index] then
				if contents[index] then

					-- we don't want water to have a drop down button
					if contents[index].Name == "Water" then
						if Data.Category[Data.CurrentCategory].SetName == "High Scalability" then
							insertButtons[index]:FindFirstChild("DropDownButton",true):Destroy()
						end
					end

					local assetId
					if useAssetVersionId then
						assetId = contents[index].AssetVersionId
					else
						assetId = contents[index].AssetId
					end
					setInsertButtonImageBehavior(insertButtons[index], true, contents[index].Name, assetId)
				else
					break
				end
			else
				break
			end
			indexCopy = index
		end
	end
	
	local function setSetIndex()
		Data.Category[Data.CurrentCategory].Index = 0

		rows = 7
		columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

		contents = Data.Category[Data.CurrentCategory].Contents
		if contents then
			-- remove our buttons and their connections
			for i = 1, #insertButtons do
				insertButtons[i]:remove()
			end
			for i = 1, #insertButtonCons do
				if insertButtonCons[i] then insertButtonCons[i]:disconnect() end
			end
			insertButtonCons = {}
			insertButtons = {}

			arrayPosition = 1
			loadSectionOfItems(setGui, rows, columns)
		end
	end
	
	local function selectSet(button, setName, setId, setIndex)
		if button and Data.Category[Data.CurrentCategory] ~= nil then
			if button ~= Data.Category[Data.CurrentCategory].Button then
				Data.Category[Data.CurrentCategory].Button = button

				if SetCache[setId] == nil then
					SetCache[setId] = game:GetService("InsertService"):GetCollection(setId)
				end
				Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

				Data.Category[Data.CurrentCategory].SetName = setName
				Data.Category[Data.CurrentCategory].SetId = setId
			end
			setSetIndex()
		end
	end
	
	local function selectCategoryPage(buttons, page)
		if buttons ~= Data.CurrentCategory then
			if Data.CurrentCategory then
				for key, button in pairs(Data.CurrentCategory) do
					button.Visible = false
				end
			end

			Data.CurrentCategory = buttons
			if Data.Category[Data.CurrentCategory] == nil then
				Data.Category[Data.CurrentCategory] = {}
				if #buttons > 0 then
					selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
				end
			else
				Data.Category[Data.CurrentCategory].Button = nil
				selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
			end
		end
	end
	
	local function selectCategory(category)
		selectCategoryPage(category, 0)
	end
	
	local function resetAllSetButtonSelection()
		local setButtons = setGui.SetPanel.Sets.SetsLists:GetChildren()
		for i = 1, #setButtons do
			if setButtons[i]:IsA("TextButton") then
				setButtons[i].Selected = false
				setButtons[i].BackgroundTransparency = 1
				setButtons[i].TextColor3 = Color3.new(1,1,1)
				setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
			end
		end
	end
	
	local function populateSetsFrame()
		local currRow = 0
		for i = 1, #userCategoryButtons do
			local button = userCategoryButtons[i]
			button.Visible = true
			button.Position = UDim2.new(0,5,0,currRow * button.Size.Y.Offset)
			button.Parent = setGui.SetPanel.Sets.SetsLists
			
			if i == 1 then -- we will have this selected by default, so show it
				button.Selected = true
				button.BackgroundColor3 = Color3.new(0,204/255,0)
				button.TextColor3 = Color3.new(0,0,0)
				button.BackgroundTransparency = 0
			end

			button.MouseEnter:connect(function()
				if not button.Selected then
					button.BackgroundTransparency = 0
					button.TextColor3 = Color3.new(0,0,0)
				end
			end)
			button.MouseLeave:connect(function()
				if not button.Selected then
					button.BackgroundTransparency = 1
					button.TextColor3 = Color3.new(1,1,1)
				end
			end)
			button.MouseButton1Click:connect(function()
				resetAllSetButtonSelection()
				button.Selected = not button.Selected
				button.BackgroundColor3 = Color3.new(0,204/255,0)
				button.TextColor3 = Color3.new(0,0,0)
				button.BackgroundTransparency = 0
				selectSet(button, button.Text, userCategoryButtons[i].SetId.Value, 0)
			end)

			currRow = currRow + 1
		end

		local buttons =  setGui.SetPanel.Sets.SetsLists:GetChildren()

		-- set first category as loaded for default
		if buttons then
			for i = 1, #buttons do
				if buttons[i]:IsA("TextButton") then
					selectSet(buttons[i], buttons[i].Text, userCategoryButtons[i].SetId.Value, 0)
					selectCategory(userCategoryButtons)
					break
				end
			end
		end
	end

	setGui = createSetGui()
	waterGui, waterTypeChangedEvent = createWaterGui()
	waterGui.Position = UDim2.new(0,55,0,0)
	waterGui.Parent = setGui
	setGui.Changed:connect(function(prop) -- this resizes the preview image to always be the right size
		if prop == "AbsoluteSize" then
			handleResize()
			setSetIndex()
		end
	end)
	
	local scrollFrame, controlFrame = t.CreateTrueScrollingFrame()
	scrollFrame.Size = UDim2.new(0.54,0,0.85,0)
	scrollFrame.Position = UDim2.new(0.24,0,0.085,0)
	scrollFrame.Name = "ItemsFrame"
	scrollFrame.ZIndex = 6
	scrollFrame.Parent = setGui.SetPanel
	scrollFrame.BackgroundTransparency = 1

	drillDownSetZIndex(controlFrame,7)

	controlFrame.Parent = setGui.SetPanel
	controlFrame.Position = UDim2.new(0.76, 5, 0, 0)

	local debounce = false
	controlFrame.ScrollBottom.Changed:connect(function(prop)
		if controlFrame.ScrollBottom.Value == true then
			if debounce then return end
			debounce = true
				loadSectionOfItems(setGui, rows, columns)
			debounce = false
		end
	end)

	local userData = {}
	for id = 1, #userIdsForSets do
		local newUserData = game:GetService("InsertService"):GetUserSets(userIdsForSets[id])
		if newUserData and #newUserData > 2 then
			-- start at #3 to skip over My Decals and My Models for each account
			for category = 3, #newUserData do
				if newUserData[category].Name == "High Scalability" then -- we want high scalability parts to show first
					table.insert(userData,1,newUserData[category])
				else
					table.insert(userData, newUserData[category])
				end
			end
		end
	
	end
	if userData then
		userCategoryButtons = processCategory(userData)
	end

	rows = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
	columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

	populateSetsFrame()

	setGui.SetPanel.CancelButton.MouseButton1Click:connect(function()
		setGui.SetPanel.Visible = false
		if dialogClosed then dialogClosed() end
	end)
	
	local setVisibilityFunction = function(visible)
		if visible then
			setGui.SetPanel.Visible = true
		else
			setGui.SetPanel.Visible = false
		end
	end
	
	local getVisibilityFunction = function()
		if setGui then
			if setGui:FindFirstChild("SetPanel") then
				return setGui.SetPanel.Visible
			end
		end
		
		return false
	end
	
	return setGui, setVisibilityFunction, getVisibilityFunction, waterTypeChangedEvent
end

t.CreateTerrainMaterialSelector = function(size,position)
	local terrainMaterialSelectionChanged = Instance.new("BindableEvent")
	terrainMaterialSelectionChanged.Name = "TerrainMaterialSelectionChanged"

	local selectedButton = nil

	local frame = Instance.new("Frame")
	frame.Name = "TerrainMaterialSelector"
	if size then
		frame.Size = size
	else
		frame.Size = UDim2.new(0, 245, 0, 230)
	end
	if position then
		frame.Position = position
	end
	frame.BorderSizePixel = 0
	frame.BackgroundColor3 = Color3.new(0,0,0)
	frame.Active = true

	terrainMaterialSelectionChanged.Parent = frame

	local waterEnabled = true -- todo: turn this on when water is ready

	local materialToImageMap = {}
	local materialNames = {"Grass", "Sand", "Brick", "Granite", "Asphalt", "Iron", "Aluminum", "Gold", "Plank", "Log", "Gravel", "Cinder Block", "Stone Wall", "Concrete", "Plastic (red)", "Plastic (blue)"}
	if waterEnabled then
		table.insert(materialNames,"Water")
	end
	local currentMaterial = 1

	function getEnumFromName(choice)
		if choice == "Grass" then return 1 end
		if choice == "Sand" then return 2 end 
		if choice == "Erase" then return 0 end
		if choice == "Brick" then return 3 end
		if choice == "Granite" then return 4 end
		if choice == "Asphalt" then return 5 end
		if choice == "Iron" then return 6 end
		if choice == "Aluminum" then return 7 end
		if choice == "Gold" then return 8 end
		if choice == "Plank" then return 9 end
		if choice == "Log" then return 10 end
		if choice == "Gravel" then return 11 end
		if choice == "Cinder Block" then return 12 end
		if choice == "Stone Wall" then return 13 end
		if choice == "Concrete" then return 14 end
		if choice == "Plastic (red)" then return 15 end
		if choice == "Plastic (blue)" then return 16 end
		if choice == "Water" then return 17 end
	end

	function getNameFromEnum(choice)
		if choice == Enum.CellMaterial.Grass or choice == 1 then return "Grass"end
		if choice == Enum.CellMaterial.Sand or choice == 2 then return "Sand" end 
		if choice == Enum.CellMaterial.Empty or choice == 0 then return "Erase" end
		if choice == Enum.CellMaterial.Brick or choice == 3 then return "Brick" end
		if choice == Enum.CellMaterial.Granite or choice == 4 then return "Granite" end
		if choice == Enum.CellMaterial.Asphalt or choice == 5 then return "Asphalt" end
		if choice == Enum.CellMaterial.Iron or choice == 6 then return "Iron" end
		if choice == Enum.CellMaterial.Aluminum or choice == 7 then return "Aluminum" end
		if choice == Enum.CellMaterial.Gold or choice == 8 then return "Gold" end
		if choice == Enum.CellMaterial.WoodPlank or choice == 9 then return "Plank" end
		if choice == Enum.CellMaterial.WoodLog or choice == 10 then return "Log" end
		if choice == Enum.CellMaterial.Gravel or choice == 11 then return "Gravel" end
		if choice == Enum.CellMaterial.CinderBlock or choice == 12 then return "Cinder Block" end
		if choice == Enum.CellMaterial.MossyStone or choice == 13 then return "Stone Wall" end
		if choice == Enum.CellMaterial.Cement or choice == 14 then return "Concrete" end
		if choice == Enum.CellMaterial.RedPlastic or choice == 15 then return "Plastic (red)" end
		if choice == Enum.CellMaterial.BluePlastic or choice == 16 then return "Plastic (blue)" end

		if waterEnabled then
			if choice == Enum.CellMaterial.Water or choice == 17 then return "Water" end
		end
	end


	local function updateMaterialChoice(choice)
		currentMaterial = getEnumFromName(choice)
		terrainMaterialSelectionChanged:Fire(currentMaterial)
	end

	-- we so need a better way to do this
	for i,v in pairs(materialNames) do
		materialToImageMap[v] = {}
		if v == "Grass" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=56563112"
		elseif v == "Sand" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=62356652"
		elseif v == "Brick" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=65961537"
		elseif v == "Granite" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532153"
		elseif v == "Asphalt" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532038"
		elseif v == "Iron" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532093"
		elseif v == "Aluminum" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67531995"
		elseif v == "Gold" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532118"
		elseif v == "Plastic (red)" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67531848"
		elseif v == "Plastic (blue)" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67531924"
		elseif v == "Plank" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532015"
		elseif v == "Log" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532051"
		elseif v == "Gravel" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532206"
		elseif v == "Cinder Block" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532103"
		elseif v == "Stone Wall" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67531804"
		elseif v == "Concrete" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532059"
		elseif v == "Water" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=81407474"
		else materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=66887593" -- fill in the rest here!!
		end
	end

	local scrollFrame, scrollUp, scrollDown, recalculateScroll = t.CreateScrollingFrame(nil,"grid")
	scrollFrame.Size = UDim2.new(0.85,0,1,0)
	scrollFrame.Position = UDim2.new(0,0,0,0)
	scrollFrame.Parent = frame

	scrollUp.Parent = frame
	scrollUp.Visible = true
	scrollUp.Position = UDim2.new(1,-19,0,0)

	scrollDown.Parent = frame
	scrollDown.Visible = true
	scrollDown.Position = UDim2.new(1,-19,1,-17)

	local function goToNewMaterial(buttonWrap, materialName)
		updateMaterialChoice(materialName)
		buttonWrap.BackgroundTransparency = 0
		selectedButton.BackgroundTransparency = 1
		selectedButton = buttonWrap
	end

	local function createMaterialButton(name)	
		local buttonWrap = Instance.new("TextButton")
		buttonWrap.Text = ""
		buttonWrap.Size = UDim2.new(0,32,0,32)
		buttonWrap.BackgroundColor3 = Color3.new(1,1,1)
		buttonWrap.BorderSizePixel = 0
		buttonWrap.BackgroundTransparency = 1
		buttonWrap.AutoButtonColor = false
		buttonWrap.Name = tostring(name)
		
		local imageButton = Instance.new("ImageButton")
		imageButton.AutoButtonColor = false
		imageButton.BackgroundTransparency = 1
		imageButton.Size = UDim2.new(0,30,0,30)
		imageButton.Position = UDim2.new(0,1,0,1)
		imageButton.Name = tostring(name)
		imageButton.Parent = buttonWrap
		imageButton.Image = materialToImageMap[name].Regular

		local enumType = Instance.new("NumberValue")
		enumType.Name = "EnumType"
		enumType.Parent = buttonWrap
		enumType.Value = 0
		
		imageButton.MouseEnter:connect(function()
			buttonWrap.BackgroundTransparency = 0
		end)
		imageButton.MouseLeave:connect(function()
			if selectedButton ~= buttonWrap then
				buttonWrap.BackgroundTransparency = 1
			end
		end)
		imageButton.MouseButton1Click:connect(function()
			if selectedButton ~= buttonWrap then
				goToNewMaterial(buttonWrap, tostring(name))
			end
		end)
		
		return buttonWrap 
	end

	for i = 1, #materialNames do
		local imageButton = createMaterialButton(materialNames[i])
		
		if materialNames[i] == "Grass" then -- always start with grass as the default
			selectedButton = imageButton
			imageButton.BackgroundTransparency = 0
		end
		
		imageButton.Parent = scrollFrame
	end

	local forceTerrainMaterialSelection = function(newMaterialType)
		if not newMaterialType then return end
		if currentMaterial == newMaterialType then return end

		local matName = getNameFromEnum(newMaterialType)
		local buttons = scrollFrame:GetChildren()
		for i = 1, #buttons do
			if buttons[i].Name == "Plastic (blue)" and matName == "Plastic (blue)" then goToNewMaterial(buttons[i],matName) return end
			if buttons[i].Name == "Plastic (red)" and matName == "Plastic (red)" then goToNewMaterial(buttons[i],matName) return end
			if string.find(buttons[i].Name, matName) then
				goToNewMaterial(buttons[i],matName)
				return
			end
		end
	end

	frame.Changed:connect(function ( prop )
		if prop == "AbsoluteSize" then
			recalculateScroll()
		end
	end)

	recalculateScroll()
	return frame, terrainMaterialSelectionChanged, forceTerrainMaterialSelection
end

t.CreateLoadingFrame = function(name,size,position)
	game:GetService("ContentProvider"):Preload("https://www.roblox.com/asset/?id=35238053")

	local loadingFrame = Instance.new("Frame")
	loadingFrame.Name = "LoadingFrame"
	loadingFrame.Style = Enum.FrameStyle.RobloxRound

	if size then loadingFrame.Size = size
	else loadingFrame.Size = UDim2.new(0,300,0,160) end
	if position then loadingFrame.Position = position 
	else loadingFrame.Position = UDim2.new(0.5, -150, 0.5,-80) end

	local loadingBar = Instance.new("Frame")
	loadingBar.Name = "LoadingBar"
	loadingBar.BackgroundColor3 = Color3.new(0,0,0)
	loadingBar.BorderColor3 = Color3.new(79/255,79/255,79/255)
	loadingBar.Position = UDim2.new(0,0,0,41)
	loadingBar.Size = UDim2.new(1,0,0,30)
	loadingBar.Parent = loadingFrame

		local loadingGreenBar = Instance.new("ImageLabel")
		loadingGreenBar.Name = "LoadingGreenBar"
		loadingGreenBar.Image = "https://www.roblox.com/asset/?id=35238053"
		loadingGreenBar.Position = UDim2.new(0,0,0,0)
		loadingGreenBar.Size = UDim2.new(0,0,1,0)
		loadingGreenBar.Visible = false
		loadingGreenBar.Parent = loadingBar

		local loadingPercent = Instance.new("TextLabel")
		loadingPercent.Name = "LoadingPercent"
		loadingPercent.BackgroundTransparency = 1
		loadingPercent.Position = UDim2.new(0,0,1,0)
		loadingPercent.Size = UDim2.new(1,0,0,14)
		loadingPercent.Font = Enum.Font.Arial
		loadingPercent.Text = "0%"
		loadingPercent.FontSize = Enum.FontSize.Size14
		loadingPercent.TextColor3 = Color3.new(1,1,1)
		loadingPercent.Parent = loadingBar

	local cancelButton = Instance.new("TextButton")
	cancelButton.Name = "CancelButton"
	cancelButton.Position = UDim2.new(0.5,-60,1,-40)
	cancelButton.Size = UDim2.new(0,120,0,40)
	cancelButton.Font = Enum.Font.Arial
	cancelButton.FontSize = Enum.FontSize.Size18
	cancelButton.TextColor3 = Color3.new(1,1,1)
	cancelButton.Text = "Cancel"
	cancelButton.Style = Enum.ButtonStyle.RobloxButton
	cancelButton.Parent = loadingFrame

	local loadingName = Instance.new("TextLabel")
	loadingName.Name = "loadingName"
	loadingName.BackgroundTransparency = 1
	loadingName.Size = UDim2.new(1,0,0,18)
	loadingName.Position = UDim2.new(0,0,0,2)
	loadingName.Font = Enum.Font.Arial
	loadingName.Text = name
	loadingName.TextColor3 = Color3.new(1,1,1)
	loadingName.TextStrokeTransparency = 1
	loadingName.FontSize = Enum.FontSize.Size18
	loadingName.Parent = loadingFrame

	local cancelButtonClicked = Instance.new("BindableEvent")
	cancelButtonClicked.Name = "CancelButtonClicked"
	cancelButtonClicked.Parent = cancelButton
	cancelButton.MouseButton1Click:connect(function()
		cancelButtonClicked:Fire()
	end)

	local updateLoadingGuiPercent = function(percent, tweenAction, tweenLength)
		if percent and type(percent) ~= "number" then
			error("updateLoadingGuiPercent expects number as argument, got",type(percent),"instead")
		end

		local newSize = nil
		if percent < 0 then
			newSize = UDim2.new(0,0,1,0)
		elseif percent > 1 then
			newSize = UDim2.new(1,0,1,0)
		else
			newSize = UDim2.new(percent,0,1,0)
		end

		if tweenAction then
			if not tweenLength then
				error("updateLoadingGuiPercent is set to tween new percentage, but got no tween time length! Please pass this in as third argument")
			end

			if (newSize.X.Scale > 0) then
				loadingGreenBar.Visible = true
				loadingGreenBar:TweenSize(	newSize,
											Enum.EasingDirection.Out,
											Enum.EasingStyle.Quad,
											tweenLength,
											true)
			else
				loadingGreenBar:TweenSize(	newSize,
											Enum.EasingDirection.Out,
											Enum.EasingStyle.Quad,
											tweenLength,
											true,
											function() 
												if (newSize.X.Scale < 0) then
													loadingGreenBar.Visible = false
												end
											end)
			end

		else
			loadingGreenBar.Size = newSize
			loadingGreenBar.Visible = (newSize.X.Scale > 0)
		end
	end

	loadingGreenBar.Changed:connect(function(prop)
		if prop == "Size" then
			loadingPercent.Text = tostring( math.ceil(loadingGreenBar.Size.X.Scale * 100) ) .. "%"
		end
	end)

	return loadingFrame, updateLoadingGuiPercent, cancelButtonClicked
end

t.CreatePluginFrame = function (name,size,position,scrollable,parent)
	local function createMenuButton(size,position,text,fontsize,name,parent)
		local button = Instance.new("TextButton",parent)
		button.AutoButtonColor = false
		button.Name = name
		button.BackgroundTransparency = 1
		button.Position = position
		button.Size = size
		button.Font = Enum.Font.ArialBold
		button.FontSize = fontsize
		button.Text =  text
		button.TextColor3 = Color3.new(1,1,1)
		button.BorderSizePixel = 0
		button.BackgroundColor3 = Color3.new(20/255,20/255,20/255)

		button.MouseEnter:connect(function ( )
			if button.Selected then return end
			button.BackgroundTransparency = 0
		end)
		button.MouseLeave:connect(function ( )
			if button.Selected then return end
			button.BackgroundTransparency = 1
		end)

		return button

	end

	local dragBar = Instance.new("Frame",parent)
	dragBar.Name = tostring(name) .. "DragBar"
	dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
	dragBar.BorderColor3 = Color3.new(0,0,0)
	if size then
		dragBar.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,20)  + UDim2.new(0,20,0,0)
	else
		dragBar.Size = UDim2.new(0,183,0,20)
	end
	if position then
		dragBar.Position = position
	end
	dragBar.Active = true
	dragBar.Draggable = true
	--dragBar.Visible = false
	dragBar.MouseEnter:connect(function (  )
		dragBar.BackgroundColor3 = Color3.new(49/255,49/255,49/255)
	end)
	dragBar.MouseLeave:connect(function (  )
		dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
	end)

	-- plugin name label
	local pluginNameLabel = Instance.new("TextLabel",dragBar)
	pluginNameLabel.Name = "BarNameLabel"
	pluginNameLabel.Text = " " .. tostring(name)
	pluginNameLabel.TextColor3 = Color3.new(1,1,1)
	pluginNameLabel.TextStrokeTransparency = 0
	pluginNameLabel.Size = UDim2.new(1,0,1,0)
	pluginNameLabel.Font = Enum.Font.ArialBold
	pluginNameLabel.FontSize = Enum.FontSize.Size18
	pluginNameLabel.TextXAlignment = Enum.TextXAlignment.Left
	pluginNameLabel.BackgroundTransparency = 1

	-- close button
	local closeButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-16,0.5,-8),"X",Enum.FontSize.Size14,"CloseButton",dragBar)
	local closeEvent = Instance.new("BindableEvent")
	closeEvent.Name = "CloseEvent"
	closeEvent.Parent = closeButton
	closeButton.MouseButton1Click:connect(function ()
		closeEvent:Fire()
		closeButton.BackgroundTransparency = 1
	end)

	-- help button
	local helpButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-51,0.5,-8),"?",Enum.FontSize.Size14,"HelpButton",dragBar)
	local helpFrame = Instance.new("Frame",dragBar)
	helpFrame.Name = "HelpFrame"
	helpFrame.BackgroundColor3 = Color3.new(0,0,0)
	helpFrame.Size = UDim2.new(0,300,0,552)
	helpFrame.Position = UDim2.new(1,5,0,0)
	helpFrame.Active = true
	helpFrame.BorderSizePixel = 0
	helpFrame.Visible = false

	helpButton.MouseButton1Click:connect(function(  )
		helpFrame.Visible = not helpFrame.Visible
		if helpFrame.Visible then
			helpButton.Selected = true
			helpButton.BackgroundTransparency = 0
			local screenGui = getLayerCollectorAncestor(helpFrame)
			if screenGui then
				if helpFrame.AbsolutePosition.X + helpFrame.AbsoluteSize.X > screenGui.AbsoluteSize.X then --position on left hand side
					helpFrame.Position = UDim2.new(0,-5 - helpFrame.AbsoluteSize.X,0,0)
				else -- position on right hand side
					helpFrame.Position = UDim2.new(1,5,0,0)
				end
			else
				helpFrame.Position = UDim2.new(1,5,0,0)
			end
		else
			helpButton.Selected = false
			helpButton.BackgroundTransparency = 1
		end
	end)

	local minimizeButton = createMenuButton(UDim2.new(0,16,0,17),UDim2.new(1,-34,0.5,-8),"-",Enum.FontSize.Size14,"MinimizeButton",dragBar)
	minimizeButton.TextYAlignment = Enum.TextYAlignment.Top

	local minimizeFrame = Instance.new("Frame",dragBar)
	minimizeFrame.Name = "MinimizeFrame"
	minimizeFrame.BackgroundColor3 = Color3.new(73/255,73/255,73/255)
	minimizeFrame.BorderColor3 = Color3.new(0,0,0)
	minimizeFrame.Position = UDim2.new(0,0,1,0)
	if size then
		minimizeFrame.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,50) + UDim2.new(0,20,0,0)
	else
		minimizeFrame.Size = UDim2.new(0,183,0,50)
	end
	minimizeFrame.Visible = false

	local minimizeBigButton = Instance.new("TextButton",minimizeFrame)
	minimizeBigButton.Position = UDim2.new(0.5,-50,0.5,-20)
	minimizeBigButton.Name = "MinimizeButton"
	minimizeBigButton.Size = UDim2.new(0,100,0,40)
	minimizeBigButton.Style = Enum.ButtonStyle.RobloxButton
	minimizeBigButton.Font = Enum.Font.ArialBold
	minimizeBigButton.FontSize = Enum.FontSize.Size18
	minimizeBigButton.TextColor3 = Color3.new(1,1,1)
	minimizeBigButton.Text = "Show"

	local separatingLine = Instance.new("Frame",dragBar)
	separatingLine.Name = "SeparatingLine"
	separatingLine.BackgroundColor3 = Color3.new(115/255,115/255,115/255)
	separatingLine.BorderSizePixel = 0
	separatingLine.Position = UDim2.new(1,-18,0.5,-7)
	separatingLine.Size = UDim2.new(0,1,0,14)

	local otherSeparatingLine = separatingLine:clone()
	otherSeparatingLine.Position = UDim2.new(1,-35,0.5,-7)
	otherSeparatingLine.Parent = dragBar

	local widgetContainer = Instance.new("Frame",dragBar)
	widgetContainer.Name = "WidgetContainer"
	widgetContainer.BackgroundTransparency = 1
	widgetContainer.Position = UDim2.new(0,0,1,0)
	widgetContainer.BorderColor3 = Color3.new(0,0,0)
	if not scrollable then
		widgetContainer.BackgroundTransparency = 0
		widgetContainer.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
	end

	if size then
		if scrollable then
			widgetContainer.Size = size
		else
			widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,size.Y.Scale,size.Y.Offset)
		end
	else
		if scrollable then
			widgetContainer.Size = UDim2.new(0,163,0,400)
		else
			widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,0,400)
		end
	end
	if position then
		widgetContainer.Position = position + UDim2.new(0,0,0,20)
	end

	local frame,control,verticalDragger = nil
	if scrollable then
		--frame for widgets
		frame,control = t.CreateTrueScrollingFrame()
		frame.Size = UDim2.new(1, 0, 1, 0)
		frame.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
		frame.BorderColor3 = Color3.new(0,0,0)
		frame.Active = true
		frame.Parent = widgetContainer
		control.Parent = dragBar
		control.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
		control.BorderSizePixel = 0
		control.BackgroundTransparency = 0
		control.Position = UDim2.new(1,-21,1,1)
		if size then
			control.Size = UDim2.new(0,21,size.Y.Scale,size.Y.Offset)
		else
			control.Size = UDim2.new(0,21,0,400)
		end
		control:FindFirstChild("ScrollDownButton").Position = UDim2.new(0,0,1,-20)

		local fakeLine = Instance.new("Frame",control)
		fakeLine.Name = "FakeLine"
		fakeLine.BorderSizePixel = 0
		fakeLine.BackgroundColor3 = Color3.new(0,0,0)
		fakeLine.Size = UDim2.new(0,1,1,1)
		fakeLine.Position = UDim2.new(1,0,0,0)

		verticalDragger = Instance.new("TextButton",widgetContainer)
		verticalDragger.ZIndex = 2
		verticalDragger.AutoButtonColor = false
		verticalDragger.Name = "VerticalDragger"
		verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
		verticalDragger.BorderColor3 = Color3.new(0,0,0)
		verticalDragger.Size = UDim2.new(1,20,0,20)
		verticalDragger.Position = UDim2.new(0,0,1,0)
		verticalDragger.Active = true
		verticalDragger.Text = ""

		local scrubFrame = Instance.new("Frame",verticalDragger)
		scrubFrame.Name = "ScrubFrame"
		scrubFrame.BackgroundColor3 = Color3.new(1,1,1)
		scrubFrame.BorderSizePixel = 0
		scrubFrame.Position = UDim2.new(0.5,-5,0.5,0)
		scrubFrame.Size = UDim2.new(0,10,0,1)
		scrubFrame.ZIndex = 5
		local scrubTwo = scrubFrame:clone()
		scrubTwo.Position = UDim2.new(0.5,-5,0.5,-2)
		scrubTwo.Parent = verticalDragger
		local scrubThree = scrubFrame:clone()
		scrubThree.Position = UDim2.new(0.5,-5,0.5,2)
		scrubThree.Parent = verticalDragger

		local areaSoak = Instance.new("TextButton",getLayerCollectorAncestor(parent))
		areaSoak.Name = "AreaSoak"
		areaSoak.Size = UDim2.new(1,0,1,0)
		areaSoak.BackgroundTransparency = 1
		areaSoak.BorderSizePixel = 0
		areaSoak.Text = ""
		areaSoak.ZIndex = 10
		areaSoak.Visible = false
		areaSoak.Active = true

		local draggingVertical = false
		local startYPos = nil
		verticalDragger.MouseEnter:connect(function ()
			verticalDragger.BackgroundColor3 = Color3.new(60/255,60/255,60/255)
		end)
		verticalDragger.MouseLeave:connect(function ()
			verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
		end)
		verticalDragger.MouseButton1Down:connect(function(x,y)
			draggingVertical = true
			areaSoak.Visible = true
			startYPos = y
		end)
		areaSoak.MouseButton1Up:connect(function (  )
			draggingVertical = false
			areaSoak.Visible = false
		end)
		areaSoak.MouseMoved:connect(function(x,y)
			if not draggingVertical then return end

			local yDelta = y - startYPos
			if not control.ScrollDownButton.Visible and yDelta > 0 then
				return
			end

			if (widgetContainer.Size.Y.Offset + yDelta) < 150 then
				widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,150)
				control.Size = UDim2.new (0,21,0,150)
				return 
			end 

			startYPos = y

			if widgetContainer.Size.Y.Offset + yDelta >= 0 then
				widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,widgetContainer.Size.Y.Offset + yDelta)
				control.Size = UDim2.new(0,21,0,control.Size.Y.Offset + yDelta )
			end
		end)
	end

	local function switchMinimize()
		minimizeFrame.Visible = not minimizeFrame.Visible
		if scrollable then
			frame.Visible = not frame.Visible
			verticalDragger.Visible = not verticalDragger.Visible
			control.Visible = not control.Visible
		else
			widgetContainer.Visible = not widgetContainer.Visible
		end

		if minimizeFrame.Visible then
			minimizeButton.Text = "+"
		else
			minimizeButton.Text = "-"
		end
	end

	minimizeBigButton.MouseButton1Click:connect(function (  )
		switchMinimize()
	end)

	minimizeButton.MouseButton1Click:connect(function(  )
		switchMinimize()
	end)

	if scrollable then
		return dragBar, frame, helpFrame, closeEvent
	else
		return dragBar, widgetContainer, helpFrame, closeEvent
	end
end

t.Help = 
	function(funcNameOrFunc) 
		--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
		if funcNameOrFunc == "CreatePropertyDropDownMenu" or funcNameOrFunc == t.CreatePropertyDropDownMenu then
			return "Function CreatePropertyDropDownMenu.  " ..
				   "Arguments: (instance, propertyName, enumType).  " .. 
				   "Side effect: returns a container with a drop-down-box that is linked to the 'property' field of 'instance' which is of type 'enumType'" 
		end 
		if funcNameOrFunc == "CreateDropDownMenu" or funcNameOrFunc == t.CreateDropDownMenu then
			return "Function CreateDropDownMenu.  " .. 
			       "Arguments: (items, onItemSelected).  " .. 
				   "Side effect: Returns 2 results, a container to the gui object and a 'updateSelection' function for external updating.  The container is a drop-down-box created around a list of items" 
		end 
		if funcNameOrFunc == "CreateMessageDialog" or funcNameOrFunc == t.CreateMessageDialog then
			return "Function CreateMessageDialog.  " .. 
			       "Arguments: (title, message, buttons). " .. 
			       "Side effect: Returns a gui object of a message box with 'title' and 'message' as passed in.  'buttons' input is an array of Tables contains a 'Text' and 'Function' field for the text/callback of each button"
		end		
		if funcNameOrFunc == "CreateStyledMessageDialog" or funcNameOrFunc == t.CreateStyledMessageDialog then
			return "Function CreateStyledMessageDialog.  " .. 
			       "Arguments: (title, message, style, buttons). " .. 
			       "Side effect: Returns a gui object of a message box with 'title' and 'message' as passed in.  'buttons' input is an array of Tables contains a 'Text' and 'Function' field for the text/callback of each button, 'style' is a string, either Error, Notify or Confirm"
		end
		if funcNameOrFunc == "GetFontHeight" or funcNameOrFunc == t.GetFontHeight then
			return "Function GetFontHeight.  " .. 
			       "Arguments: (font, fontSize). " .. 
			       "Side effect: returns the size in pixels of the given font + fontSize"
		end
		if funcNameOrFunc == "LayoutGuiObjects" or funcNameOrFunc == t.LayoutGuiObjects then
		
		end
		if funcNameOrFunc == "CreateScrollingFrame" or funcNameOrFunc == t.CreateScrollingFrame then
			return "Function CreateScrollingFrame.  " .. 
			   "Arguments: (orderList, style) " .. 
			   "Side effect: returns 4 objects, (scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction).  'scrollFrame' can be filled with GuiObjects.  It will lay them out and allow scrollUpButton/scrollDownButton to interact with them.  Orderlist is optional (and specifies the order to layout the children.  Without orderlist, it uses the children order. style is also optional, and allows for a 'grid' styling if style is passed 'grid' as a string.  recalculateFunction can be called when a relayout is needed (when orderList changes)"
		end
		if funcNameOrFunc == "CreateTrueScrollingFrame" or funcNameOrFunc == t.CreateTrueScrollingFrame then
			return "Function CreateTrueScrollingFrame.  " .. 
			   "Arguments: (nil) " .. 
			   "Side effect: returns 2 objects, (scrollFrame, controlFrame).  'scrollFrame' can be filled with GuiObjects, and they will be clipped if not inside the frame's bounds. controlFrame has children scrollup and scrolldown, as well as a slider.  controlFrame can be parented to any guiobject and it will readjust itself to fit."
		end
		if funcNameOrFunc == "AutoTruncateTextObject" or funcNameOrFunc == t.AutoTruncateTextObject then
			return "Function AutoTruncateTextObject.  " .. 
			   "Arguments: (textLabel) " .. 
			   "Side effect: returns 2 objects, (textLabel, changeText).  The 'textLabel' input is modified to automatically truncate text (with ellipsis), if it gets too small to fit.  'changeText' is a function that can be used to change the text, it takes 1 string as an argument"
		end
		if funcNameOrFunc == "CreateSlider" or funcNameOrFunc == t.CreateSlider then
			return "Function CreateSlider.  " ..
				"Arguments: (steps, width, position) " ..
				"Side effect: returns 2 objects, (sliderGui, sliderPosition).  The 'steps' argument specifies how many different positions the slider can hold along the bar.  'width' specifies in pixels how wide the bar should be (modifiable afterwards if desired). 'position' argument should be a UDim2 for slider positioning. 'sliderPosition' is an IntValue whose current .Value specifies the specific step the slider is currently on."
		end
		if funcNameOrFunc == "CreateSliderNew" or funcNameOrFunc == t.CreateSliderNew then
			return "Function CreateSliderNew.  " ..
				"Arguments: (steps, width, position) " ..
				"Side effect: returns 2 objects, (sliderGui, sliderPosition).  The 'steps' argument specifies how many different positions the slider can hold along the bar.  'width' specifies in pixels how wide the bar should be (modifiable afterwards if desired). 'position' argument should be a UDim2 for slider positioning. 'sliderPosition' is an IntValue whose current .Value specifies the specific step the slider is currently on."
		end
		if funcNameOrFunc == "CreateLoadingFrame" or funcNameOrFunc == t.CreateLoadingFrame then
			return "Function CreateLoadingFrame.  " ..
				"Arguments: (name, size, position) " ..
				"Side effect: Creates a gui that can be manipulated to show progress for a particular action.  Name appears above the loading bar, and size and position are udim2 values (both size and position are optional arguments).  Returns 3 arguments, the first being the gui created. The second being updateLoadingGuiPercent, which is a bindable function.  This function takes one argument (two optionally), which should be a number between 0 and 1, representing the percentage the loading gui should be at.  The second argument to this function is a boolean value that if set to true will tween the current percentage value to the new percentage value, therefore our third argument is how long this tween should take. Our third returned argument is a BindableEvent, that when fired means that someone clicked the cancel button on the dialog."
		end
		if funcNameOrFunc == "CreateTerrainMaterialSelector" or funcNameOrFunc == t.CreateTerrainMaterialSelector then
			return "Function CreateTerrainMaterialSelector.  " ..
				"Arguments: (size, position) " ..
				"Side effect: Size and position are UDim2 values that specifies the selector's size and position.  Both size and position are optional arguments. This method returns 3 objects (terrainSelectorGui, terrainSelected, forceTerrainSelection).  terrainSelectorGui is just the gui object that we generate with this function, parent it as you like. TerrainSelected is a BindableEvent that is fired whenever a new terrain type is selected in the gui.  ForceTerrainSelection is a function that takes an argument of Enum.CellMaterial and will force the gui to show that material as currently selected."
		end
	end
	
return t

end;
};
G2L_MODULES[G2L["123"]] = {
Closure = function()
    local script = G2L["123"];local t = {}

-- Do a line/plane intersection.  The line starts at the camera.  The plane is at y == 0, normal(0, 1, 0)
--
-- vectorPos - End point of the line.
--
-- Return:
-- cellPos - The terrain cell intersection point if there is one, vectorPos if there isn't.
-- hit - Whether there was a plane intersection.  Value is true if there was, false if not.
function PlaneIntersection(vectorPos)
	local hit = false
	local currCamera = game:GetService("Workspace").CurrentCamera
	local startPos = Vector3.new(currCamera.CoordinateFrame.p.X, currCamera.CoordinateFrame.p.Y, currCamera.CoordinateFrame.p.Z)
	local endPos = Vector3.new(vectorPos.X, vectorPos.Y, vectorPos.Z)
	local normal = Vector3.new(0, 1, 0)
	local p3 = Vector3.new(0, 0, 0)
	local startEndDot = normal:Dot(endPos - startPos)
	local cellPos = vectorPos
	if startEndDot ~= 0  then
		local t = normal:Dot(p3 - startPos) / startEndDot
		if(t >=0 and t <=1) then
			local intersection = ((endPos - startPos) * t) + startPos
			cellPos = game:GetService("Workspace").Terrain:WorldToCell(intersection)
			hit = true
		end
	end

	return cellPos, hit
end


-- Purpose:
-- Checks for terrain touched by the mouse hit.
-- Will do a plane intersection if no terrain is touched.
--
-- mouse - Mouse to check the .hit for.
--
-- Return:
-- cellPos - Cell position hit.  Nil if none.
function GetTerrainForMouse(mouse)
	-- There was no target, so all it could be is a plane intersection.
	-- Check for a plane intersection.  If there isn't one then nothing will get hit.
	local cell = game:GetService("Workspace").Terrain:WorldToCellPreferSolid(Vector3.new(mouse.hit.x, mouse.hit.y, mouse.hit.z))
	local planeLoc = nil
	local hit = nil
	-- If nothing was hit, do the plane intersection.
	if 0 == game:GetService("Workspace").Terrain:GetCell(cell.X, cell.Y, cell.Z).Value then
		cell = nil
		planeLoc, hit = PlaneIntersection(Vector3.new(mouse.hit.x, mouse.hit.y, mouse.hit.z))
		if hit then
			cell = planeLoc
		end
	end
	return cell
end

-- setup helper functions
local insertBoundingBoxOverlapVector = Vector3.new(.3, .3, .3) -- we can still stamp if our character extrudes into the target stamping space by .3 or fewer units

-- rotates a model by yAngle radians about the global y-axis
local function rotatePartAndChildren(part, rotCF, offsetFromOrigin)
	-- rotate this thing, if it's a part
	if part:IsA("BasePart") then
		part.CFrame = (rotCF * (part.CFrame - offsetFromOrigin)) + offsetFromOrigin
	end

	-- recursively do the same to all children
	local partChildren = part:GetChildren()
	for c = 1, #partChildren do rotatePartAndChildren(partChildren[c], rotCF, offsetFromOrigin) end
end

local function modelRotate(model, yAngle)
	local rotCF = CFrame.Angles(0, yAngle, 0)
	local offsetFromOrigin = model:GetModelCFrame().p

	rotatePartAndChildren(model, rotCF, offsetFromOrigin)
end


local function collectParts(object, baseParts, scripts, decals)
	if object:IsA("BasePart") then
		baseParts[#baseParts+1] = object
	elseif object:IsA("Script") then
		scripts[#scripts+1] = object
	elseif object:IsA("Decal") then
		decals[#decals+1] = object
	end

	for index,child in pairs(object:GetChildren()) do
		collectParts(child, baseParts, scripts, decals)
	end
end

local function clusterPartsInRegion(startVector, endVector)
	local cluster = game:GetService("Workspace"):FindFirstChild("Terrain")

	local startCell = cluster:WorldToCell(startVector)
	local endCell = cluster:WorldToCell(endVector)

	local startX = startCell.X
	local startY = startCell.Y
	local startZ = startCell.Z

	local endX = endCell.X
	local endY = endCell.Y
	local endZ = endCell.Z

	if startX < cluster.MaxExtents.Min.X then startX = cluster.MaxExtents.Min.X end
	if startY < cluster.MaxExtents.Min.Y then startY = cluster.MaxExtents.Min.Y end
	if startZ < cluster.MaxExtents.Min.Z then startZ = cluster.MaxExtents.Min.Z end

	if endX > cluster.MaxExtents.Max.X then endX = cluster.MaxExtents.Max.X end
	if endY > cluster.MaxExtents.Max.Y then endY = cluster.MaxExtents.Max.Y end
	if endZ > cluster.MaxExtents.Max.Z then endZ = cluster.MaxExtents.Max.Z end

	for x = startX, endX do
		for y = startY, endY do
			for z = startZ, endZ do
				if (cluster:GetCell(x, y, z).Value) > 0 then return true end
			end
		end
	end

	return false
end

local function findSeatsInModel(parent, seatTable)
	if not parent then return end

	if parent.className == "Seat" or parent.className == "VehicleSeat" then
		table.insert(seatTable, parent)
	end
	local myChildren = parent:GetChildren()
	for j = 1, #myChildren do
		findSeatsInModel(myChildren[j], seatTable)
	end
end

local function setSeatEnabledStatus(model, isEnabled)
	local seatList = {}
	findSeatsInModel(model, seatList)

	if isEnabled then
		-- remove any welds called "SeatWeld" in seats
		for i = 1, #seatList do
			local nextSeat = seatList[i]:FindFirstChild("SeatWeld")
			while nextSeat do nextSeat:Remove() nextSeat = seatList[i]:FindFirstChild("SeatWeld") end
		end
	else
		-- put a weld called "SeatWeld" in every seat
		--   this tricks it into thinking there's already someone sitting there, and it won't make you sit XD
		for i = 1, #seatList do
			local fakeWeld = Instance.new("Weld")
			fakeWeld.Name = "SeatWeld"
			fakeWeld.Parent = seatList[i]
		end
	end
end

local function autoAlignToFace(parts)
	local aatf = parts:FindFirstChild("AutoAlignToFace")
	if aatf then return aatf.Value else return false end
end

local function getClosestAlignedWorldDirection(aVector3InWorld)
	local xDir = Vector3.new(1,0,0)
	local yDir = Vector3.new(0,1,0)
	local zDir = Vector3.new(0,0,1)
	local xDot = aVector3InWorld.x * xDir.x + aVector3InWorld.y * xDir.y + aVector3InWorld.z * xDir.z
	local yDot = aVector3InWorld.x * yDir.x + aVector3InWorld.y * yDir.y + aVector3InWorld.z * yDir.z
	local zDot = aVector3InWorld.x * zDir.x + aVector3InWorld.y * zDir.y + aVector3InWorld.z * zDir.z

	if math.abs(xDot) > math.abs(yDot) and math.abs(xDot) > math.abs(zDot) then
		if xDot > 0 then
			return 0
		else
			return 3
		end
	elseif math.abs(yDot) > math.abs(xDot) and math.abs(yDot) > math.abs(zDot) then
		if yDot > 0 then
			return 1
		else
			return 4
		end
	else
		if zDot > 0 then
			return 2
		else
			return 5
		end
	end
end

local function positionPartsAtCFrame3(aCFrame, currentParts)
	local insertCFrame = nil
	if not currentParts then return currentParts end
	if currentParts and (currentParts:IsA("Model") or currentParts:IsA("Tool")) then
		insertCFrame = currentParts:GetModelCFrame()
		currentParts:TranslateBy(aCFrame.p - insertCFrame.p)
	else
		currentParts.CFrame = aCFrame
	end
	return currentParts
end

local function calcRayHitTime(rayStart, raySlope, intersectionPlane)
	if math.abs(raySlope) < .01 then return 0 end -- 0 slope -->  we just say intersection time is 0, and sidestep this dimension
	return (intersectionPlane - rayStart) / raySlope
end

local function modelTargetSurface(partOrModel, rayStart, rayEnd)
	if not partOrModel then
		return 0
	end

	local modelCFrame = nil
	local modelSize = nil
	if partOrModel:IsA("Model") then
		modelCFrame = partOrModel:GetModelCFrame()
		modelSize = partOrModel:GetModelSize()
	else
		modelCFrame = partOrModel.CFrame
		modelSize = partOrModel.Size
	end

	local mouseRayStart = modelCFrame:pointToObjectSpace(rayStart)
	local mouseRayEnd = modelCFrame:pointToObjectSpace(rayEnd)
	local mouseSlope = mouseRayEnd - mouseRayStart

	local xPositive = 1
	local yPositive = 1
	local zPositive = 1
	if mouseSlope.X > 0 then xPositive = -1 end
	if mouseSlope.Y > 0 then yPositive = -1 end
	if mouseSlope.Z > 0 then zPositive = -1 end

	-- find which surface the transformed mouse ray hits (using modelSize):
	local xHitTime = calcRayHitTime(mouseRayStart.X, mouseSlope.X, modelSize.X/2 * xPositive)
	local yHitTime = calcRayHitTime(mouseRayStart.Y, mouseSlope.Y, modelSize.Y/2 * yPositive)
	local zHitTime = calcRayHitTime(mouseRayStart.Z, mouseSlope.Z, modelSize.Z/2 * zPositive)

	local hitFace = 0

	--if xHitTime >= 0 and yHitTime >= 0 and zHitTime >= 0 then
	if xHitTime > yHitTime then
		if xHitTime > zHitTime then
			-- xFace is hit
			hitFace = 1*xPositive
		else
			-- zFace is hit
			hitFace = 3*zPositive
		end
	else
		if yHitTime > zHitTime then
			-- yFace is hit
			hitFace = 2*yPositive
		else
			-- zFace is hit
			hitFace = 3*zPositive
		end
	end

	return hitFace
end

local function getBoundingBox2(partOrModel)

	-- for models, the bounding box is defined as the minimum and maximum individual part bounding boxes
	-- relative to the first part's coordinate frame.
	local minVec = Vector3.new(math.huge, math.huge, math.huge)
	local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

	if partOrModel:IsA("Terrain") then
		minVec = Vector3.new(-2, -2, -2)
		maxVec = Vector3.new(2, 2, 2)
	elseif partOrModel:IsA("BasePart") then
		minVec = -0.5 * partOrModel.Size
		maxVec = -minVec
	else
		maxVec = partOrModel:GetModelSize()*0.5
		minVec = -maxVec
	end

	-- Adjust bounding box to reflect what the model or part author wants in  terms of justification
	local justifyValue = partOrModel:FindFirstChild("Justification")
	if justifyValue ~= nil then
		-- find the multiple of 4 that contains the model
		local justify = justifyValue.Value
		local two = Vector3.new(2, 2, 2)
		local actualBox = maxVec - minVec - Vector3.new(0.01, 0.01, 0.01)
		local containingGridBox = Vector3.new(4 * math.ceil(actualBox.x/4), 4 * math.ceil(actualBox.y/4), 4 * math.ceil(actualBox.z/4))
		local adjustment = containingGridBox - actualBox
		minVec = minVec - 0.5 * adjustment * justify
		maxVec = maxVec + 0.5 * adjustment * (two - justify)
	end

	return minVec, maxVec
end

local function getBoundingBoxInWorldCoordinates(partOrModel)
	local minVec = Vector3.new(math.huge, math.huge, math.huge)
	local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

	if partOrModel:IsA("BasePart") and not partOrModel:IsA("Terrain") then
		local vec1 = partOrModel.CFrame:pointToWorldSpace(-0.5 * partOrModel.Size)
		local vec2 = partOrModel.CFrame:pointToWorldSpace(0.5 * partOrModel.Size)
		minVec = Vector3.new(math.min(vec1.X, vec2.X), math.min(vec1.Y, vec2.Y), math.min(vec1.Z, vec2.Z))
		maxVec = Vector3.new(math.max(vec1.X, vec2.X), math.max(vec1.Y, vec2.Y), math.max(vec1.Z, vec2.Z))
	elseif partOrModel:IsA("Terrain") then
		-- we shouldn't have to deal with this case
		--minVec = Vector3.new(-2, -2, -2)
		--maxVec = Vector3.new(2, 2, 2)
	else
		local vec1 = partOrModel:GetModelCFrame():pointToWorldSpace(-0.5 * partOrModel:GetModelSize())
		local vec2 = partOrModel:GetModelCFrame():pointToWorldSpace(0.5 * partOrModel:GetModelSize())
		minVec = Vector3.new(math.min(vec1.X, vec2.X), math.min(vec1.Y, vec2.Y), math.min(vec1.Z, vec2.Z))
		maxVec = Vector3.new(math.max(vec1.X, vec2.X), math.max(vec1.Y, vec2.Y), math.max(vec1.Z, vec2.Z))
	end

	return minVec, maxVec
end

local function getTargetPartBoundingBox(targetPart)
	if targetPart.Parent:FindFirstChild("RobloxModel") ~= nil then
		return getBoundingBox2(targetPart.Parent)
	else
		return getBoundingBox2(targetPart)
	end
end

local function getMouseTargetCFrame(targetPart)
	if targetPart.Parent:FindFirstChild("RobloxModel") ~= nil then
		if targetPart.Parent:IsA("Tool") then return targetPart.Parent.Handle.CFrame
		else return targetPart.Parent:GetModelCFrame() end
	else
		return targetPart.CFrame
	end
end

local function isBlocker(part) -- returns whether or not we want to cancel the stamp because we're blocked by this part
	if not part then return false end
	if not part.Parent then return false end
	if part:FindFirstChild("Humanoid") then return false end
	if part:FindFirstChild("RobloxStamper") or part:FindFirstChild("RobloxModel") then return true end
	if part:IsA("Part") and not part.CanCollide then return false end
	if part == game:GetService("Lighting") then return false end
	return isBlocker(part.Parent)
end

-- helper function to determine if a character can be pushed upwards by a certain amount
-- character is 5 studs tall, we'll check a 1.5 x 1.5 x 4.5 box around char, with center .5 studs below torsocenter
local function spaceAboveCharacter(charTorso, newTorsoY, stampData)
	local partsAboveChar = game:GetService("Workspace"):FindPartsInRegion3(
		Region3.new(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75),
		Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)),
		charTorso.Parent,
		100)

	for j = 1, #partsAboveChar do
		if partsAboveChar[j].CanCollide and not partsAboveChar[j]:IsDescendantOf(stampData.CurrentParts) then return false end
	end

	if clusterPartsInRegion(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75),
		Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)) then
			return false
	end

	return true
end


local function findConfigAtMouseTarget(Mouse, stampData)
	-- *Critical Assumption* :
	--				This function assumes the target CF axes are orthogonal with the target bounding box faces
	--				And, it assumes the insert CF axes are orthongonal with the insert bounding box faces
	--				Therefore, insertion will not work with angled faces on wedges or other "non-block" parts, nor
	--				will it work for parts in a model that are not orthogonally aligned with the model's CF.

	if not Mouse then return nil end -- This can happen sometimes, return if so
	if not stampData then error("findConfigAtMouseTarget: stampData is nil") return nil end
	if not stampData["CurrentParts"] then return nil end

	local grid = 4.0
	local admissibleConfig = false
	local targetConfig = CFrame.new(0,0,0)

	local minBB, maxBB = getBoundingBox2(stampData.CurrentParts)
	local diagBB = maxBB - minBB

	local insertCFrame
	if stampData.CurrentParts:IsA("Model") or stampData.CurrentParts:IsA("Tool") then
		insertCFrame = stampData.CurrentParts:GetModelCFrame()
	else
		insertCFrame = stampData.CurrentParts.CFrame
	end

	if Mouse then
		if stampData.CurrentParts:IsA("Tool") then
			Mouse.TargetFilter = stampData.CurrentParts.Handle
		else
			Mouse.TargetFilter = stampData.CurrentParts
		end
	end

	local hitPlane = false
	local targetPart = nil
	local success = pcall(function() targetPart = Mouse.Target end)

	if not success then-- or targetPart == nil then
		return admissibleConfig, targetConfig
	end

	local mouseHitInWorld = Vector3.new(0, 0, 0)
	if Mouse then
		mouseHitInWorld = Vector3.new(Mouse.Hit.x, Mouse.Hit.y, Mouse.Hit.z)
	end

	local cellPos = nil

	-- Nothing was hit, so check for the default plane.
	if nil == targetPart then
		cellPos = GetTerrainForMouse(Mouse)
		if nil == cellPos then
			hitPlane = false
			return admissibleConfig, targetConfig
		else
			targetPart = game:GetService("Workspace").Terrain
			hitPlane = true
			-- Take into account error that will occur.
			cellPos = Vector3.new(cellPos.X - 1, cellPos.Y, cellPos.Z)
			mouseHitInWorld = game:GetService("Workspace").Terrain:CellCenterToWorld(cellPos.x, cellPos.y, cellPos.z)
		end
	end

	-- test mouse hit location
	local minBBTarget, maxBBTarget = getTargetPartBoundingBox(targetPart)
	local diagBBTarget = maxBBTarget - minBBTarget
	local targetCFrame = getMouseTargetCFrame(targetPart)

	if targetPart:IsA("Terrain") then
		local cluster = game:GetService("Workspace"):FindFirstChild("Terrain")
		local cellID = cluster:WorldToCellPreferSolid(mouseHitInWorld)
		if hitPlane then
			cellID = cellPos
		end

		targetCFrame = CFrame.new(game:GetService("Workspace").Terrain:CellCenterToWorld(cellID.x, cellID.y, cellID.z))
	end

	local mouseHitInTarget = targetCFrame:pointToObjectSpace(mouseHitInWorld)
	local targetVectorInWorld = Vector3.new(0,0,0)
	if Mouse then
		-- DON'T WANT THIS IN TERMS OF THE MODEL CFRAME!  (.TargetSurface is in terms of the part CFrame, so this would break, right?  [HotThoth])
		--   (ideally, we would want to make the Mouse.TargetSurface a model-targetsurface instead, but for testing will be using the converse)
		--targetVectorInWorld = targetCFrame:vectorToWorldSpace(Vector3.FromNormalId(Mouse.TargetSurface))
		targetVectorInWorld = targetPart.CFrame:vectorToWorldSpace(Vector3.FromNormalId(Mouse.TargetSurface))   -- better, but model cframe would be best
		--[[if targetPart.Parent:IsA("Model") then
			local hitFace = modelTargetSurface(targetPart.Parent, Mouse.Hit.p, workspace.CurrentCamera.CoordinateFrame.p)  -- best, if you get it right
			local WORLD_AXES = {Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1)}
			if hitFace > 0 then
				targetVectorInWorld = targetCFrame:vectorToWorldSpace(WORLD_AXES[hitFace])
			elseif hitFace < 0 then
				targetVectorInWorld = targetCFrame:vectorToWorldSpace(-WORLD_AXES[-hitFace])
			end
		end]]
	end

	local targetRefPointInTarget
	local clampToSurface
	local insertRefPointInInsert

	if getClosestAlignedWorldDirection(targetVectorInWorld) == 0 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
		clampToSurface = Vector3.new(0,1,1)
	elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 3 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
		clampToSurface = Vector3.new(0,1,1)
	elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 1 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
		clampToSurface = Vector3.new(1,0,1)
	elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 4 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
		clampToSurface = Vector3.new(1,0,1)
	elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 2 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
		clampToSurface = Vector3.new(1,1,0)
	else
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
		clampToSurface = Vector3.new(1,1,0)
	end

	targetRefPointInTarget = targetRefPointInTarget * (0.5 * diagBBTarget) + 0.5 * (maxBBTarget + minBBTarget)
	insertRefPointInInsert = insertRefPointInInsert * (0.5 * diagBB) + 0.5 * (maxBB + minBB)

	-- To Do: For cases that are not aligned to the world grid, account for the minimal rotation
	-- needed to bring the Insert part(s) into alignment with the Target Part
	-- Apply the rotation here

	local delta = mouseHitInTarget - targetRefPointInTarget
	local deltaClamped = Vector3.new(grid * math.modf(delta.x/grid), grid * math.modf(delta.y/grid), grid * math.modf(delta.z/grid))
	deltaClamped = deltaClamped * clampToSurface
	local targetTouchInTarget = deltaClamped + targetRefPointInTarget

	local TargetTouchRelToWorld = targetCFrame:pointToWorldSpace(targetTouchInTarget)
	local InsertTouchInWorld = insertCFrame:vectorToWorldSpace(insertRefPointInInsert)
	local posInsertOriginInWorld = TargetTouchRelToWorld - InsertTouchInWorld

	local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = insertCFrame:components()
	targetConfig = CFrame.new(posInsertOriginInWorld.x, posInsertOriginInWorld.y, posInsertOriginInWorld.z, R00, R01, R02, R10, R11, R12, R20, R21, R22)
	admissibleConfig = true

	return admissibleConfig, targetConfig, getClosestAlignedWorldDirection(targetVectorInWorld)
end

local function truncateToCircleEighth(bigValue, littleValue)
	local big = math.abs(bigValue)
	local little = math.abs(littleValue)
	local hypotenuse = math.sqrt(big*big + little*little)
	local frac = little / hypotenuse

	local bigSign = 1
	local littleSign = 1
	if bigValue < 0 then bigSign = -1 end
	if littleValue < 0 then littleSign = -1 end

	if frac > .382683432 then
		-- between 22.5 and 45 degrees, so truncate to 45-degree tilt
		return .707106781 * hypotenuse * bigSign, .707106781 * hypotenuse * littleSign
	else
		-- between 0 and 22.5 degrees, so truncate to 0-degree tilt
		return hypotenuse * bigSign, 0
	end
end


local function saveTheWelds(object, manualWeldTable, manualWeldParentTable)
	if object:IsA("ManualWeld") or object:IsA("Rotate") then
		table.insert(manualWeldTable, object)
		table.insert(manualWeldParentTable, object.Parent)
	else
		local children = object:GetChildren()
		for i = 1, #children do
			saveTheWelds(children[i], manualWeldTable, manualWeldParentTable)
		end
	end
end

local function restoreTheWelds(manualWeldTable, manualWeldParentTable)
	for i = 1, #manualWeldTable do
		manualWeldTable[i].Parent = manualWeldParentTable[i]
	end
end

t.CanEditRegion = function(partOrModel, EditRegion) -- todo: use model and stamper metadata
	if not EditRegion then return true, false end

	local minBB, maxBB = getBoundingBoxInWorldCoordinates(partOrModel)

	if minBB.X < EditRegion.CFrame.p.X - EditRegion.Size.X/2 or
		minBB.Y < EditRegion.CFrame.p.Y - EditRegion.Size.Y/2 or
		minBB.Z < EditRegion.CFrame.p.Z - EditRegion.Size.Z/2 then
			return false, false
	end

	if maxBB.X > EditRegion.CFrame.p.X + EditRegion.Size.X/2 or
		maxBB.Y > EditRegion.CFrame.p.Y + EditRegion.Size.Y/2 or
		maxBB.Z > EditRegion.CFrame.p.Z + EditRegion.Size.Z/2 then
			return false, false
	end

	return true, false
end

t.GetStampModel = function(assetId, terrainShape, useAssetVersionId)
	if assetId == 0 then
		return nil, "No Asset"
	end
	if assetId < 0 then
		return nil, "Negative Asset"
	end

	local function UnlockInstances(object)
		if object:IsA("BasePart") then
			object.Locked = false
		end
		for index,child in pairs(object:GetChildren()) do
			UnlockInstances(child)
		end
	end

	local function getClosestColorToTerrainMaterial(terrainValue)
		if terrainValue == 1 then
			return BrickColor.new("Bright green")
		elseif terrainValue == 2 then
			return BrickColor.new("Bright yellow")
		elseif terrainValue == 3 then
			return BrickColor.new("Bright red")
		elseif terrainValue == 4 then
			return BrickColor.new("Sand red")
		elseif terrainValue == 5 then
			return BrickColor.new("Black")
		elseif terrainValue == 6 then
			return BrickColor.new("Dark stone grey")
		elseif terrainValue == 7 then
			return BrickColor.new("Sand blue")
		elseif terrainValue == 8 then
			return BrickColor.new("Deep orange")
		elseif terrainValue == 9 then
			return BrickColor.new("Dark orange")
		elseif terrainValue == 10 then
			return BrickColor.new("Reddish brown")
		elseif terrainValue == 11 then
			return BrickColor.new("Light orange")
		elseif terrainValue == 12 then
			return BrickColor.new("Light stone grey")
		elseif terrainValue == 13 then
			return BrickColor.new("Sand green")
		elseif terrainValue == 14 then
			return BrickColor.new("Medium stone grey")
		elseif terrainValue == 15 then
			return BrickColor.new("Really red")
		elseif terrainValue == 16 then
			return BrickColor.new("Really blue")
		elseif terrainValue == 17 then
			return BrickColor.new("Bright blue")
		else
			return BrickColor.new("Bright green")
		end
	end

	local function setupFakeTerrainPart(cellMat, cellType, cellOrient)
		local newTerrainPiece = nil
		if (cellType == 1 or cellType == 4) then newTerrainPiece = Instance.new("WedgePart")
		elseif (cellType == 2) then newTerrainPiece = Instance.new("CornerWedgePart")
		else newTerrainPiece = Instance.new("Part") end
		newTerrainPiece.Name = "MegaClusterCube"
		newTerrainPiece.Size = Vector3.new(4, 4, 4)
		newTerrainPiece.BottomSurface = "Smooth"
		newTerrainPiece.TopSurface = "Smooth"

		-- can add decals or textures here if feeling particularly adventurous...  for now, can make a table of look-up colors
		newTerrainPiece.BrickColor = getClosestColorToTerrainMaterial(cellMat)

		local sideways = 0
		local flipped = math.pi
		if cellType == 4 then sideways = -math.pi/2 end
		if cellType == 2 or cellType == 3 then flipped = 0 end
		newTerrainPiece.CFrame = CFrame.Angles(0, math.pi/2*cellOrient + flipped, sideways)

		if cellType == 3 then
			local inverseCornerWedgeMesh = Instance.new("SpecialMesh")
			inverseCornerWedgeMesh.MeshType = "FileMesh"
			inverseCornerWedgeMesh.MeshId = "https://www.roblox.com/asset/?id=66832495"
			inverseCornerWedgeMesh.Scale = Vector3.new(2, 2, 2)
			inverseCornerWedgeMesh.Parent = newTerrainPiece
		end

		local materialTag = Instance.new("Vector3Value")
		materialTag.Value = Vector3.new(cellMat, cellType, cellOrient)
		materialTag.Name = "ClusterMaterial"
		materialTag.Parent = newTerrainPiece

		return newTerrainPiece
	end

	-- This call will cause a "wait" until the data comes back
	-- below we wait a max of 8 seconds before deciding to bail out on loading
	local root
	local loader
	loading = true
	if useAssetVersionId then
		loader = coroutine.create(function()
			root = game:GetService("InsertService"):LoadAssetVersion(assetId)
			loading = false
		end)
		coroutine.resume(loader)
	else
		loader = coroutine.create(function()
			root = game:GetService("InsertService"):LoadAsset(assetId)
			loading = false
		end)
		coroutine.resume(loader)
	end

	local lastGameTime = 0
	local totalTime = 0
	local maxWait = 8
	while loading and totalTime < maxWait do
		lastGameTime = tick()
		wait(1)
		totalTime = totalTime + tick() - lastGameTime
	end
	loading = false

	if totalTime >= maxWait then
		return nil, "Load Time Fail"
	end


	if root == nil then
		return nil, "Load Asset Fail"
	end

	if not root:IsA("Model") then
		return nil, "Load Type Fail"
	end

	local instances = root:GetChildren()
	if #instances == 0 then
		return nil, "Empty Model Fail"
	end

	--Unlock all parts that are inserted, to make sure they are editable
	UnlockInstances(root)

	--Continue the insert process
	root = root:GetChildren()[1]

	--Examine the contents and decide what it looks like
	for pos, instance in pairs(instances) do
		if instance:IsA("Team") then
			instance.Parent = game:GetService("Teams")
		elseif instance:IsA("Sky") then
			local lightingService = game:GetService("Lighting")
			for index,child in pairs(lightingService:GetChildren()) do
				if child:IsA("Sky") then
					child:Remove();
				end
			end
			instance.Parent = lightingService
			return
		end
	end

	-- ...and tag all inserted models for subsequent origin identification
	-- if no RobloxModel tag already exists, then add it.
	if root:FindFirstChild("RobloxModel") == nil then
		local stringTag = Instance.new("BoolValue", root)
		stringTag.Name = "RobloxModel"

		if root:FindFirstChild("RobloxStamper") == nil then
			local stringTag2 = Instance.new("BoolValue", root)
			stringTag2.Name = "RobloxStamper"
		end
	end

	if terrainShape then
		if root.Name == "MegaClusterCube" then
			if (terrainShape == 6) then -- insert an autowedging tag
				local autowedgeTag = Instance.new("BoolValue")
				autowedgeTag.Name = "AutoWedge"
				autowedgeTag.Parent = root
			else
				local clusterTag = root:FindFirstChild("ClusterMaterial")
				if clusterTag then
					if clusterTag:IsA("Vector3Value") then
						root = setupFakeTerrainPart(clusterTag.Value.X, terrainShape, clusterTag.Value.Z)
					else
						root = setupFakeTerrainPart(clusterTag.Value, terrainShape, 0)
					end
				else
					root = setupFakeTerrainPart(1, terrainShape, 0)
				end
			end
		end
	end

	return root
end



t.SetupStamperDragger = function(modelToStamp, Mouse, StampInModel, AllowedStampRegion, StampFailedFunc)
	if not modelToStamp then
		error("SetupStamperDragger: modelToStamp (first arg) is nil!  Should be a stamper model")
		return nil
	end
	if not modelToStamp:IsA("Model") and not modelToStamp:IsA("BasePart") then
		error("SetupStamperDragger: modelToStamp (first arg) is neither a Model or Part!")
		return nil
	end
	if not Mouse then
		error("SetupStamperDragger: Mouse (second arg) is nil!  Should be a mouse object")
		return nil
	end
	if not Mouse:IsA("Mouse") then
		error("SetupStamperDragger: Mouse (second arg) is not of type Mouse!")
		return nil
	end

	local stampInModel = nil
	local allowedStampRegion = nil
	local stampFailedFunc = nil
	if StampInModel then
		if not StampInModel:IsA("Model") then
			error("SetupStamperDragger: StampInModel (optional third arg) is not of type 'Model'")
			return nil
		end
		if not AllowedStampRegion then
			error("SetupStamperDragger: AllowedStampRegion (optional fourth arg) is nil when StampInModel (optional third arg) is defined")
			return nil
		end
		stampFailedFunc = StampFailedFunc
		stampInModel = StampInModel
		allowedStampRegion = AllowedStampRegion
	end

	-- Init all state variables
	local gInitial90DegreeRotations = 0
	local stampData = nil
	local mouseTarget = nil

	local errorBox = Instance.new("SelectionBox")
	errorBox.Color = BrickColor.new("Bright red")
	errorBox.Transparency = 0
	errorBox.Archivable = false

	-- for megacluster MEGA STAMPING
	local adornPart = Instance.new("Part")
	adornPart.Parent = nil
	adornPart.Size = Vector3.new(4, 4, 4)
	adornPart.CFrame = CFrame.new()
	adornPart.Archivable = false

	local adorn = Instance.new("SelectionBox")
	adorn.Color = BrickColor.new("Toothpaste")
	adorn.Adornee = adornPart
	adorn.Visible = true
	adorn.Transparency = 0
	adorn.Name = "HighScalabilityStamperLine"
	adorn.Archivable = false

	local HighScalabilityLine = {}
	HighScalabilityLine.Start = nil
	HighScalabilityLine.End = nil
	HighScalabilityLine.Adorn = adorn
	HighScalabilityLine.AdornPart = adornPart
	HighScalabilityLine.InternalLine = nil
	HighScalabilityLine.NewHint = true

	HighScalabilityLine.MorePoints = {nil, nil}
	HighScalabilityLine.MoreLines = {nil, nil}
	HighScalabilityLine.Dimensions = 1

	local control = {}
	local movingLock = false
	local stampUpLock = false
	local unstampableSurface = false
	local mouseCons = {}
	local keyCon = nil

	local stamped = Instance.new("BoolValue")
	stamped.Archivable = false
	stamped.Value = false

	local lastTarget = {}
	lastTarget.TerrainOrientation = 0
	lastTarget.CFrame = 0

	local cellInfo = {}
	cellInfo.Material = 1
	cellInfo.clusterType = 0
	cellInfo.clusterOrientation = 0

	local function isMegaClusterPart()
		if not stampData then return false end
		if not stampData.CurrentParts then return false end

		return ( stampData.CurrentParts:FindFirstChild("ClusterMaterial",true) or (stampData.CurrentParts.Name == "MegaClusterCube") )
	end

	local function DoHighScalabilityRegionSelect()
		local megaCube = stampData.CurrentParts:FindFirstChild("MegaClusterCube")
		if not megaCube then
			if not stampData.CurrentParts.Name == "MegaClusterCube" then
				return
			else
				megaCube = stampData.CurrentParts
			end
		end

		HighScalabilityLine.End = megaCube.CFrame.p
		local line = nil
		local line2 = Vector3.new(0, 0, 0)
		local line3 = Vector3.new(0, 0, 0)

		if HighScalabilityLine.Dimensions == 1 then
			-- extract the line from these positions and limit to a 2D plane made from 2 of the world axes
			--   then use dominating axis to limit line to be at 45-degree intervals
			--   will use this internal representation of the line for the actual stamping
			line = (HighScalabilityLine.End - HighScalabilityLine.Start)

			if math.abs(line.X) < math.abs(line.Y) then
				if math.abs(line.X) < math.abs(line.Z) then
					-- limit to Y/Z plane, domination unknown
					local newY, newZ
					if (math.abs(line.Y) > math.abs(line.Z)) then
						newY, newZ = truncateToCircleEighth(line.Y, line.Z)
					else
						newZ, newY = truncateToCircleEighth(line.Z, line.Y)
					end
					line = Vector3.new(0, newY, newZ)
				else
					-- limit to X/Y plane, with Y dominating
					local newY, newX = truncateToCircleEighth(line.Y, line.X)
					line = Vector3.new(newX, newY, 0)
				end
			else
				if math.abs(line.Y) < math.abs(line.Z) then
					-- limit to X/Z plane, domination unknown
					local newX, newZ
					if math.abs(line.X) > math.abs(line.Z) then
						newX, newZ = truncateToCircleEighth(line.X, line.Z)
					else
						newZ, newX = truncateToCircleEighth(line.Z, line.X)
					end
					line = Vector3.new(newX, 0, newZ)
				else
					-- limit to X/Y plane, with X dominating
					local newX, newY = truncateToCircleEighth(line.X, line.Y)
					line = Vector3.new(newX, newY, 0)
				end
			end
			HighScalabilityLine.InternalLine = line

		elseif HighScalabilityLine.Dimensions == 2 then
			line = HighScalabilityLine.MoreLines[1]
			line2 = HighScalabilityLine.End - HighScalabilityLine.MorePoints[1]

			-- take out any component of line2 along line1, so you get perpendicular to line1 component
			line2 = line2 - line.unit*line.unit:Dot(line2)

			local tempCFrame = CFrame.new(HighScalabilityLine.Start, HighScalabilityLine.Start + line)

			-- then zero out whichever is the smaller component
			local yAxis = tempCFrame:vectorToWorldSpace(Vector3.new(0, 1, 0))
			local xAxis = tempCFrame:vectorToWorldSpace(Vector3.new(1, 0, 0))

			local xComp = xAxis:Dot(line2)
			local yComp = yAxis:Dot(line2)

			if math.abs(yComp) > math.abs(xComp) then
				line2 = line2 - xAxis * xComp
			else
				line2 = line2 - yAxis * yComp
			end

			HighScalabilityLine.InternalLine = line2

		elseif HighScalabilityLine.Dimensions == 3 then
			line  = HighScalabilityLine.MoreLines[1]
			line2 = HighScalabilityLine.MoreLines[2]
			line3 = HighScalabilityLine.End - HighScalabilityLine.MorePoints[2]

			-- zero out all components of previous lines
			line3 = line3 - line.unit * line.unit:Dot(line3)
			line3 = line3 - line2.unit * line2.unit:Dot(line3)

			HighScalabilityLine.InternalLine = line3
		end

		-- resize the "line" graphic to be the correct size and orientation
		local tempCFrame = CFrame.new(HighScalabilityLine.Start, HighScalabilityLine.Start + line)

		if HighScalabilityLine.Dimensions == 1 then  -- faster calculation for line
			HighScalabilityLine.AdornPart.Size = Vector3.new(4, 4, line.magnitude + 4)
			HighScalabilityLine.AdornPart.CFrame = tempCFrame + tempCFrame:vectorToWorldSpace(Vector3.new(2, 2, 2) - HighScalabilityLine.AdornPart.Size/2)
		else
			local boxSize = tempCFrame:vectorToObjectSpace(line + line2 + line3)
			HighScalabilityLine.AdornPart.Size = Vector3.new(4, 4, 4) + Vector3.new(math.abs(boxSize.X), math.abs(boxSize.Y), math.abs(boxSize.Z))
			HighScalabilityLine.AdornPart.CFrame = tempCFrame + tempCFrame:vectorToWorldSpace(boxSize/2)
		end

		-- make player able to see this ish

		local gui = nil
		if game:GetService("Players")["LocalPlayer"] then
			gui = game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui")
			if gui and gui:IsA("PlayerGui") then
				if HighScalabilityLine.Dimensions == 1 and line.magnitude > 3 then -- don't show if mouse hasn't moved enough
					HighScalabilityLine.Adorn.Parent = gui
				elseif HighScalabilityLine.Dimensions > 1 then
					HighScalabilityLine.Adorn.Parent = gui
				end
			end
		end

		if gui == nil then -- we are in studio
			gui = game:GetService("CoreGui")
			if HighScalabilityLine.Dimensions == 1 and line.magnitude > 3 then -- don't show if mouse hasn't moved enough
				HighScalabilityLine.Adorn.Parent = gui
			elseif HighScalabilityLine.Dimensions > 1 then
				HighScalabilityLine.Adorn.Parent = gui
			end
		end
	end


	local function DoStamperMouseMove(Mouse)
		if not Mouse then
			error("Error: RbxStamper.DoStamperMouseMove: Mouse is nil")
			return
		end
		if not Mouse:IsA("Mouse") then
			error("Error: RbxStamper.DoStamperMouseMove: Mouse is of type", Mouse.className,"should be of type Mouse")
			return
		end

		-- There wasn't a target (no part or terrain), so check for plane intersection.
		if not Mouse.Target then
			local cellPos = GetTerrainForMouse(Mouse)
			if nil == cellPos then
				return
			end
		end

		if not stampData then
			return
		end

		-- don't move with dragger - will move in one step on mouse down
		-- draw ghost at acceptable positions
		local configFound, targetCFrame, targetSurface = findConfigAtMouseTarget(Mouse, stampData)
		if not configFound then
			error("RbxStamper.DoStamperMouseMove No configFound, returning")
			return
		end

		local numRotations = 0 -- update this according to how many rotations you need to get it to target surface
		if autoAlignToFace(stampData.CurrentParts) and targetSurface ~= 1 and targetSurface ~= 4 then -- pre-rotate the flag or portrait so it's aligned correctly
			if		targetSurface == 3 then numRotations = 0 - gInitial90DegreeRotations + autoAlignToFace(stampData.CurrentParts)
			elseif	targetSurface == 0 then numRotations = 2 - gInitial90DegreeRotations + autoAlignToFace(stampData.CurrentParts)
			elseif	targetSurface == 5 then numRotations = 3 - gInitial90DegreeRotations + autoAlignToFace(stampData.CurrentParts)
			elseif	targetSurface == 2 then numRotations = 1 - gInitial90DegreeRotations + autoAlignToFace(stampData.CurrentParts)
			end
		end

		local ry = math.pi/2
		gInitial90DegreeRotations = gInitial90DegreeRotations + numRotations
		if stampData.CurrentParts:IsA("Model") or stampData.CurrentParts:IsA("Tool") then
			--stampData.CurrentParts:Rotate(0, ry*numRotations, 0)
			modelRotate(stampData.CurrentParts, ry*numRotations)
		else
			stampData.CurrentParts.CFrame = CFrame.fromEulerAnglesXYZ(0, ry*numRotations, 0) * stampData.CurrentParts.CFrame
		end

		-- CODE TO CHECK FOR DRAGGING GHOST PART INTO A COLLIDING STATE
		local minBB, maxBB = getBoundingBoxInWorldCoordinates(stampData.CurrentParts)

		-- need to offset by distance to be dragged
		local currModelCFrame = nil
		if stampData.CurrentParts:IsA("Model") then
			currModelCFrame = stampData.CurrentParts:GetModelCFrame()
		else
			currModelCFrame = stampData.CurrentParts.CFrame
		end

		minBB = minBB + targetCFrame.p - currModelCFrame.p
		maxBB = maxBB + targetCFrame.p - currModelCFrame.p

		-- don't drag into terrain
		if clusterPartsInRegion(minBB + insertBoundingBoxOverlapVector, maxBB - insertBoundingBoxOverlapVector) then
			if lastTarget.CFrame then
				if (stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)) then
					local theClusterMaterial = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
					if theClusterMaterial:IsA("Vector3Value") then
						local stampClusterMaterial = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
						if stampClusterMaterial then
							stampClusterMaterial = theClusterMaterial
						end
					end
				end
			end
			return
		end

		-- if we are stamping a terrain part, make sure it goes on the grid! Otherwise preview block could be placed off grid, but stamped on grid
		if isMegaClusterPart() then
			local cellToStamp = game:GetService("Workspace").Terrain:WorldToCell(targetCFrame.p)
			local newCFramePosition = game:GetService("Workspace").Terrain:CellCenterToWorld(cellToStamp.X, cellToStamp.Y, cellToStamp.Z)
			local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = targetCFrame:components()
			targetCFrame = CFrame.new(newCFramePosition.X,newCFramePosition.Y,newCFramePosition.Z,R00, R01, R02, R10, R11, R12, R20, R21, R22)
		end

		positionPartsAtCFrame3(targetCFrame, stampData.CurrentParts)
		lastTarget.CFrame = targetCFrame  -- successful positioning, so update 'dat cframe
		if stampData.CurrentParts:FindFirstChild("ClusterMaterial", true) then
			local clusterMat = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
			if clusterMat:IsA("Vector3Value") then
				lastTarget.TerrainOrientation = clusterMat.Value.Z
			end
		end


		-- auto break joints code
		if Mouse and Mouse.Target and Mouse.Target.Parent then
			local modelInfo = Mouse.Target:FindFirstChild("RobloxModel")
			if not modelInfo then modelInfo = Mouse.Target.Parent:FindFirstChild("RobloxModel") end

			local myModelInfo = stampData.CurrentParts:FindFirstChild("UnstampableFaces")

			--if (modelInfo and modelInfo.Parent:FindFirstChild("UnstampableFaces")) or (modelInfo and myModelInfo) then  -- need better targetSurface calcs
			if (true) then
				local breakingFaces = ""
				local myBreakingFaces = ""
				if modelInfo and modelInfo.Parent:FindFirstChild("UnstampableFaces") then breakingFaces = modelInfo.Parent.UnstampableFaces.Value end
				if myModelInfo then myBreakingFaces = myModelInfo.Value end
				local hitFace = 0

				if modelInfo then hitFace = modelTargetSurface(modelInfo.Parent, game:GetService("Workspace").CurrentCamera.CoordinateFrame.p, Mouse.Hit.p) end

				-- are we stamping TO an unstampable surface?
				for bf in string.gmatch(breakingFaces, "[^,]+") do
					if hitFace == tonumber(bf) then
						-- return before we hit the JointsService code below!
						unstampableSurface = true
						game:GetService("JointsService"):ClearJoinAfterMoveJoints() -- clear the JointsService cache
						return
					end
				end

				-- now we have to cast the ray back in the other direction to find the surface we're stamping FROM
				hitFace = modelTargetSurface(stampData.CurrentParts, Mouse.Hit.p, game:GetService("Workspace").CurrentCamera.CoordinateFrame.p)

				-- are we stamping WITH an unstampable surface?
				for bf in string.gmatch(myBreakingFaces, "[^,]+") do
					if hitFace == tonumber(bf) then
						unstampableSurface = true
						game:GetService("JointsService"):ClearJoinAfterMoveJoints() -- clear the JointsService cache
						return
					end
				end

				-- just need to match breakingFace against targetSurface using rotation supplied by modelCFrame
				-- targetSurface: 1 is top, 4 is bottom,
			end
		end

		-- to show joints during the mouse move
		unstampableSurface = false
		game:GetService("JointsService"):SetJoinAfterMoveInstance(stampData.CurrentParts)

		-- most common mouse inactive error occurs here, so check mouse active one more time in a pcall
		if not pcall(function()
				if Mouse and Mouse.Target and Mouse.Target.Parent:FindFirstChild("RobloxModel") == nil then
					return
				else
					return
				end
			end)
		then
			error("Error: RbxStamper.DoStamperMouseMove Mouse is nil on second check")
			game:GetService("JointsService"):ClearJoinAfterMoveJoints()
			Mouse = nil
			return
		end

		if Mouse and Mouse.Target and Mouse.Target.Parent:FindFirstChild("RobloxModel") == nil then
			game:GetService("JointsService"):SetJoinAfterMoveTarget(Mouse.Target)
		else
			game:GetService("JointsService"):SetJoinAfterMoveTarget(nil)
		end
		game:GetService("JointsService"):ShowPermissibleJoints()

		-- here we allow for a line of high-scalability parts
		if isMegaClusterPart() and HighScalabilityLine and HighScalabilityLine.Start then
				DoHighScalabilityRegionSelect()
		end
	end

	local function setupKeyListener(key, Mouse)
		if control and control["Paused"] then return end -- don't do this if we have no stamp

		key = string.lower(key)
		if key == 'r' and not autoAlignToFace(stampData.CurrentParts) then -- rotate the model
			gInitial90DegreeRotations = gInitial90DegreeRotations + 1

			-- Update orientation value if this is a fake terrain part
			local clusterValues = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
			if clusterValues and clusterValues:IsA("Vector3Value") then
				clusterValues.Value = Vector3.new(clusterValues.Value.X, clusterValues.Value.Y, (clusterValues.Value.Z + 1) % 4)
			end

			-- Rotate the parts or all the parts in the model
			local ry = math.pi/2
			if stampData.CurrentParts:IsA("Model") or stampData.CurrentParts:IsA("Tool") then
				--stampData.CurrentParts:Rotate(0, ry, 0)
				modelRotate(stampData.CurrentParts, ry)
			else
				stampData.CurrentParts.CFrame = CFrame.fromEulerAnglesXYZ(0, ry, 0) * stampData.CurrentParts.CFrame
			end

			-- After rotating, update the position
			configFound, targetCFrame = findConfigAtMouseTarget(Mouse, stampData)
			if configFound then
				positionPartsAtCFrame3(targetCFrame, stampData.CurrentParts)

				-- update everything else in MouseMove
				DoStamperMouseMove(Mouse)
			end
		elseif key == 'c' then -- try to expand our high scalability dragger dimension
			if HighScalabilityLine.InternalLine and HighScalabilityLine.InternalLine.magnitude > 0 and HighScalabilityLine.Dimensions < 3 then
				HighScalabilityLine.MorePoints[HighScalabilityLine.Dimensions] = HighScalabilityLine.End
				HighScalabilityLine.MoreLines[HighScalabilityLine.Dimensions] = HighScalabilityLine.InternalLine
				HighScalabilityLine.Dimensions = HighScalabilityLine.Dimensions + 1
				HighScalabilityLine.NewHint = true
			end
		end
	end

	keyCon = Mouse.KeyDown:connect(function(key) -- init key connection (keeping code close to func)
		setupKeyListener(key, Mouse)
	end)

	local function resetHighScalabilityLine()
		if HighScalabilityLine then
			HighScalabilityLine.Start = nil
			HighScalabilityLine.End = nil
			HighScalabilityLine.InternalLine = nil
			HighScalabilityLine.NewHint = true
		end
	end

	local function flashRedBox()
		local gui = game:GetService("CoreGui")
		if game:GetService("Players") then
			if game:GetService("Players")["LocalPlayer"] then
				if game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui") then
					gui = game:GetService("Players").LocalPlayer.PlayerGui
				end
			end
		end
		if not stampData["ErrorBox"] then return end

		stampData.ErrorBox.Parent = gui
		if stampData.CurrentParts:IsA("Tool") then
			stampData.ErrorBox.Adornee = stampData.CurrentParts.Handle
		else
			stampData.ErrorBox.Adornee = stampData.CurrentParts
		end

		delay(0,function()
			for i = 1, 3 do
				if stampData["ErrorBox"] then stampData.ErrorBox.Visible = true end
				wait(0.13)
				if stampData["ErrorBox"] then stampData.ErrorBox.Visible = false end
				wait(0.13)
			end
			if stampData["ErrorBox"] then
				stampData.ErrorBox.Adornee = nil
				stampData.ErrorBox.Parent = nil
			end
		end)
	end

	local function DoStamperMouseDown(Mouse)
		if not Mouse then
			error("Error: RbxStamper.DoStamperMouseDown: Mouse is nil")
			return
		end
		if not Mouse:IsA("Mouse") then
			error("Error: RbxStamper.DoStamperMouseDown: Mouse is of type", Mouse.className,"should be of type Mouse")
			return
		end
		if not stampData then
			return
		end

		if isMegaClusterPart() then
			if Mouse and HighScalabilityLine then
				local megaCube = stampData.CurrentParts:FindFirstChild("MegaClusterCube", true)
				local terrain = game:GetService("Workspace").Terrain
				if megaCube then
					HighScalabilityLine.Dimensions = 1
					local tempCell = terrain:WorldToCell(megaCube.CFrame.p)
					HighScalabilityLine.Start = terrain:CellCenterToWorld(tempCell.X, tempCell.Y, tempCell.Z)
					return
				else
					HighScalabilityLine.Dimensions = 1
					local tempCell = terrain:WorldToCell(stampData.CurrentParts.CFrame.p)
					HighScalabilityLine.Start = terrain:CellCenterToWorld(tempCell.X, tempCell.Y, tempCell.Z)
					return
				end
			end
		end
	end

	local function loadSurfaceTypes(part, surfaces)
		part.TopSurface = surfaces[1]
		part.BottomSurface = surfaces[2]
		part.LeftSurface = surfaces[3]
		part.RightSurface = surfaces[4]
		part.FrontSurface = surfaces[5]
		part.BackSurface = surfaces[6]
	end

	local function saveSurfaceTypes(part, myTable)
		local tempTable = {}
		tempTable[1] = part.TopSurface
		tempTable[2] = part.BottomSurface
		tempTable[3] = part.LeftSurface
		tempTable[4] = part.RightSurface
		tempTable[5] = part.FrontSurface
		tempTable[6] = part.BackSurface

		myTable[part] = tempTable
	end

	local function makeSurfaceUnjoinable(part, surface)
		-- TODO: FILL OUT!
	end

	local function prepareModel(model)
		if not model then return nil end

		local gDesiredTrans = 0.7
		local gStaticTrans = 1

		local clone = model:Clone()
		local scripts = {}
		local parts = {}
		local decals = {}

		stampData = {}
		stampData.DisabledScripts = {}
		stampData.TransparencyTable = {}
		stampData.MaterialTable = {}
		stampData.CanCollideTable = {}
		stampData.AnchoredTable = {}
		stampData.ArchivableTable = {}
		stampData.DecalTransparencyTable = {}
		stampData.SurfaceTypeTable = {}

		collectParts(clone, parts, scripts, decals)

		if #parts <= 0 then return nil, "no parts found in modelToStamp" end

		for index,script in pairs(scripts) do
			if not(script.Disabled) then
				script.Disabled = true
				stampData.DisabledScripts[#stampData.DisabledScripts + 1] = script
			end
		end
		for index, part in pairs(parts) do
			stampData.TransparencyTable[part] = part.Transparency
			part.Transparency = gStaticTrans + (1 - gStaticTrans) * part.Transparency
			stampData.MaterialTable[part] = part.Material
			part.Material = Enum.Material.Plastic
			stampData.CanCollideTable[part] = part.CanCollide
			part.CanCollide = false
			stampData.AnchoredTable[part] = part.Anchored
			part.Anchored = true
			stampData.ArchivableTable[part] = part.Archivable
			part.Archivable = false

			saveSurfaceTypes(part, stampData.SurfaceTypeTable)

			local fadeInDelayTime = 0.5
			local transFadeInTime = 0.5
			delay(0,function()
				wait(fadeInDelayTime) -- give it some time to be completely transparent

				local begTime = tick()
				local currTime = begTime
				while (currTime - begTime) < transFadeInTime and part and part:IsA("BasePart") and part.Transparency > gDesiredTrans do
					local newTrans = 1 - (((currTime - begTime)/transFadeInTime) * (gStaticTrans - gDesiredTrans))
					if stampData["TransparencyTable"] and stampData.TransparencyTable[part] then
						part.Transparency = newTrans + (1 - newTrans) * stampData.TransparencyTable[part]
					end
					wait(0.03)
					currTime = tick()
				end
				if part and part:IsA("BasePart") then
					if stampData["TransparencyTable"] and stampData.TransparencyTable[part] then
						part.Transparency = gDesiredTrans + (1 - gDesiredTrans) * stampData.TransparencyTable[part]
					end
				end
			end)
		end

		for index, decal in pairs(decals) do
			stampData.DecalTransparencyTable[decal] = decal.Transparency
			decal.Transparency = gDesiredTrans + (1 - gDesiredTrans) * decal.Transparency
		end

		-- disable all seats
		setSeatEnabledStatus(clone, true)
		setSeatEnabledStatus(clone, false)

		stampData.CurrentParts = clone

		-- if auto-alignable, we enforce a pre-rotation to the canonical "0-frame"
		if autoAlignToFace(clone) then
			stampData.CurrentParts:ResetOrientationToIdentity()
			gInitial90DegreeRotations = 0
		else -- pre-rotate if necessary
			local ry = gInitial90DegreeRotations * math.pi/2
			if stampData.CurrentParts:IsA("Model") or stampData.CurrentParts:IsA("Tool") then
				--stampData.CurrentParts:Rotate(0, ry, 0)
				modelRotate(stampData.CurrentParts, ry)
			else
				stampData.CurrentParts.CFrame = CFrame.fromEulerAnglesXYZ(0, ry, 0) * stampData.CurrentParts.CFrame
			end
		end

		-- since we're cloning the old model instead of the new one, we will need to update the orientation based on the original value AND how many more
		--  rotations we expect since then [either that or we need to store the just-stamped clusterMaterial.Value.Z somewhere].  This should fix the terrain rotation
		--  issue (fingers crossed) [HotThoth]

		local clusterMaterial = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
		if clusterMaterial and clusterMaterial:IsA("Vector3Value") then
			clusterMaterial.Value = Vector3.new(clusterMaterial.Value.X, clusterMaterial.Value.Y, (clusterMaterial.Value.Z + gInitial90DegreeRotations) % 4)
		end

		-- After rotating, update the position
		local configFound, targetCFrame = findConfigAtMouseTarget(Mouse, stampData)
		if configFound then
			stampData.CurrentParts = positionPartsAtCFrame3(targetCFrame, stampData.CurrentParts)
		end

		-- to show joints during the mouse move
		game:GetService("JointsService"):SetJoinAfterMoveInstance(stampData.CurrentParts)

		return clone, parts
	end

	local function checkTerrainBlockCollisions(cellPos, checkHighScalabilityStamp)
		local cellCenterToWorld = game:GetService("Workspace").Terrain.CellCenterToWorld
		local cellCenter = cellCenterToWorld(game:GetService("Workspace").Terrain, cellPos.X, cellPos.Y, cellPos.Z)
		local cellBlockingParts = game:GetService("Workspace"):FindPartsInRegion3(Region3.new(cellCenter - Vector3.new(2, 2, 2) + insertBoundingBoxOverlapVector, cellCenter + Vector3.new(2, 2, 2) - insertBoundingBoxOverlapVector), stampData.CurrentParts,	100)

		local skipThisCell = false

		for b = 1, #cellBlockingParts do
			if isBlocker(cellBlockingParts[b]) then skipThisCell = true break end
		end

		if not skipThisCell then
			-- pop players up above any set cells
			local alreadyPushedUp = {}
			-- if no blocking model below, then see if stamping on top of a character
			for b = 1, #cellBlockingParts do
				if	cellBlockingParts[b].Parent and
					not alreadyPushedUp[cellBlockingParts[b].Parent] and
					cellBlockingParts[b].Parent:FindFirstChild("Humanoid") and
					cellBlockingParts[b].Parent:FindFirstChild("Humanoid"):IsA("Humanoid") then
				-----------------------------------------------------------------------------------
						local blockingPersonTorso = cellBlockingParts[b].Parent:FindFirstChild("Torso")
						alreadyPushedUp[cellBlockingParts[b].Parent] = true

						if blockingPersonTorso then
							-- if so, let's push the person upwards so they pop on top of the stamped model/part (but only if there's space above them)
							local newY = cellCenter.Y + 5
							if spaceAboveCharacter(blockingPersonTorso, newY, stampData) then
								blockingPersonTorso.CFrame = blockingPersonTorso.CFrame + Vector3.new(0, newY - blockingPersonTorso.CFrame.p.Y, 0)
							else
								-- if no space, we just skip this one
								skipThisCell = true
								break
							end
						end
				-----------------------------------------------------------------------------------
				end
			end
		end

		if not skipThisCell then  -- if we STILL aren't skipping...  then we're good to go!
			local canSetCell = true

			if checkHighScalabilityStamp then -- check to see if cell is in region, if not we'll skip set
				if allowedStampRegion then
					local cellPos = cellCenterToWorld(game:GetService("Workspace").Terrain, cellPos.X, cellPos.Y, cellPos.Z)
					if cellPos.X + 2 > allowedStampRegion.CFrame.p.X + allowedStampRegion.Size.X/2 then
						canSetCell = false
					elseif cellPos.X - 2 < allowedStampRegion.CFrame.p.X - allowedStampRegion.Size.X/2 then
						canSetCell = false
					elseif cellPos.Y + 2 > allowedStampRegion.CFrame.p.Y + allowedStampRegion.Size.Y/2 then
						canSetCell = false
					elseif cellPos.Y - 2 < allowedStampRegion.CFrame.p.Y - allowedStampRegion.Size.Y/2 then
						canSetCell = false
					elseif cellPos.Z + 2 > allowedStampRegion.CFrame.p.Z + allowedStampRegion.Size.Z/2 then
						canSetCell = false
					elseif cellPos.Z - 2 < allowedStampRegion.CFrame.p.Z - allowedStampRegion.Size.Z/2 then
						canSetCell = false
					end
				end
			end

			return canSetCell
		end
		return false
	end


	local function ResolveMegaClusterStamp(checkHighScalabilityStamp)
		local cellSet = false

		local cluser = game:GetService("Workspace").Terrain

		local line = HighScalabilityLine.InternalLine
		local cMax = game:GetService("Workspace").Terrain.MaxExtents.Max
		local cMin = game:GetService("Workspace").Terrain.MaxExtents.Min

		local clusterMaterial = 1 -- default is grass
		local clusterType = 0 -- default is brick
		local clusterOrientation = 0 -- default is 0 rotation

		local autoWedgeClusterParts = false
		if stampData.CurrentParts:FindFirstChild("AutoWedge") then autoWedgeClusterParts = true end

		if stampData.CurrentParts:FindFirstChild("ClusterMaterial", true) then
			clusterMaterial = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
			if clusterMaterial:IsA("Vector3Value") then
				clusterType = clusterMaterial.Value.Y
				clusterOrientation = clusterMaterial.Value.Z
				clusterMaterial = clusterMaterial.Value.X
			elseif clusterMaterial:IsA("IntValue") then
				clusterMaterial = clusterMaterial.Value
			end
		end

		if HighScalabilityLine.Adorn.Parent and HighScalabilityLine.Start and ((HighScalabilityLine.Dimensions > 1) or (line and line.magnitude > 0)) then
			local startCell = game:GetService("Workspace").Terrain:WorldToCell(HighScalabilityLine.Start)
			local xInc = {0,0,0}
			local yInc = {0,0,0}
			local zInc = {0,0,0}

			local cluster = game:GetService("Workspace").Terrain

			local incrementVect = {nil, nil, nil}
			local stepVect = {Vector3.new(0, 0, 0), Vector3.new(0, 0, 0), Vector3.new(0, 0, 0)}

			local worldAxes = {Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1)}

			local lines = {}
			if HighScalabilityLine.Dimensions > 1 then table.insert(lines, HighScalabilityLine.MoreLines[1]) end
			if line and line.magnitude > 0 then table.insert(lines, line) end
			if HighScalabilityLine.Dimensions > 2 then table.insert(lines, HighScalabilityLine.MoreLines[2]) end

			for i = 1, #lines do
				lines[i] = Vector3.new(math.floor(lines[i].X+.5), math.floor(lines[i].Y+.5), math.floor(lines[i].Z+.5)) -- round to integers

				if lines[i].X > 0 then xInc[i] = 1 elseif lines[i].X < 0 then xInc[i] = -1 end
				if lines[i].Y > 0 then yInc[i] = 1 elseif lines[i].Y < 0 then yInc[i] = -1 end
				if lines[i].Z > 0 then zInc[i] = 1 elseif lines[i].Z < 0 then zInc[i] = -1 end

				incrementVect[i] = Vector3.new(xInc[i], yInc[i], zInc[i])
				if incrementVect[i].magnitude < .9 then incrementVect[i] = nil end
			end


			if not lines[2] then lines[2] = Vector3.new(0, 0, 0) end
			if not lines[3] then lines[3] = Vector3.new(0, 0, 0) end

			local waterForceTag = stampData.CurrentParts:FindFirstChild("WaterForceTag", true)
			local waterForceDirectionTag = stampData.CurrentParts:FindFirstChild("WaterForceDirectionTag", true)

			while (stepVect[3].magnitude*4 <= lines[3].magnitude) do
				local outerStepVectIndex = 1
				while outerStepVectIndex < 4 do
					stepVect[2] = Vector3.new(0, 0, 0)
					while (stepVect[2].magnitude*4 <= lines[2].magnitude) do
						local innerStepVectIndex = 1
						while innerStepVectIndex < 4 do
							stepVect[1] = Vector3.new(0, 0, 0)
							while (stepVect[1].magnitude*4 <= lines[1].magnitude) do
								local stepVectSum = stepVect[1] + stepVect[2] + stepVect[3]
								local cellPos = Vector3int16.new(startCell.X + stepVectSum.X, startCell.Y + stepVectSum.Y, startCell.Z + stepVectSum.Z)
								if cellPos.X >= cMin.X and cellPos.Y >= cMin.Y and cellPos.Z >= cMin.Z and cellPos.X < cMax.X and cellPos.Y < cMax.Y and cellPos.Z < cMax.Z then
									-- check if overlaps player or part
									local okToStampTerrainBlock = checkTerrainBlockCollisions(cellPos, checkHighScalabilityStamp)

									if okToStampTerrainBlock then
										if waterForceTag then
											cluster:SetWaterCell(cellPos.X, cellPos.Y, cellPos.Z, Enum.WaterForce[waterForceTag.Value], Enum.WaterDirection[waterForceDirectionTag.Value])
										else
											cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, clusterMaterial, clusterType, clusterOrientation)
										end
										cellSet = true

										-- auto-wedge it?
										if (autoWedgeClusterParts) then
											game:GetService("Workspace").Terrain:AutowedgeCells(Region3int16.new(Vector3int16.new(cellPos.x - 1, cellPos.y - 1, cellPos.z - 1),
												Vector3int16.new(cellPos.x + 1, cellPos.y + 1, cellPos.z + 1)))
										end
									end
								end
								stepVect[1] = stepVect[1] + incrementVect[1]
							end
							if incrementVect[2] then
								while innerStepVectIndex < 4 and worldAxes[innerStepVectIndex]:Dot(incrementVect[2]) == 0 do
									innerStepVectIndex = innerStepVectIndex + 1
								end
								if innerStepVectIndex < 4 then
									stepVect[2] = stepVect[2] + worldAxes[innerStepVectIndex] * worldAxes[innerStepVectIndex]:Dot(incrementVect[2])
								end
								innerStepVectIndex = innerStepVectIndex + 1
							else
								stepVect[2] = Vector3.new(1, 0, 0)
								innerStepVectIndex = 4 -- skip all remaining loops
							end
							if (stepVect[2].magnitude*4 > lines[2].magnitude) then innerStepVectIndex = 4 end
						end
					end
					if incrementVect[3] then
						while outerStepVectIndex < 4 and worldAxes[outerStepVectIndex]:Dot(incrementVect[3]) == 0 do
							outerStepVectIndex = outerStepVectIndex + 1
						end
						if outerStepVectIndex < 4 then
							stepVect[3] = stepVect[3] + worldAxes[outerStepVectIndex] * worldAxes[outerStepVectIndex]:Dot(incrementVect[3])
						end
						outerStepVectIndex = outerStepVectIndex + 1
					else -- skip all remaining loops
						stepVect[3] = Vector3.new(1, 0, 0) outerStepVectIndex = 4
					end
					if (stepVect[3].magnitude*4 > lines[3].magnitude) then outerStepVectIndex = 4 end
				end
			end
		end

		-- and also get rid of any HighScalabilityLine stuff if it's there
		HighScalabilityLine.Start = nil
		HighScalabilityLine.Adorn.Parent = nil

		-- Mark for undo.
		if cellSet then
			stampData.CurrentParts.Parent = nil
			pcall(function() game:GetService("ChangeHistoryService"): SetWaypoint("StamperMulti") end)
		end

		return cellSet
	end

	local function DoStamperMouseUp(Mouse)
		if not Mouse then
			error("Error: RbxStamper.DoStamperMouseUp: Mouse is nil")
			return false
		end
		if not Mouse:IsA("Mouse") then
			error("Error: RbxStamper.DoStamperMouseUp: Mouse is of type", Mouse.className,"should be of type Mouse")
			return false
		end

		if not stampData.Dragger then
			error("Error: RbxStamper.DoStamperMouseUp: stampData.Dragger is nil")
			return false
		end

		if not HighScalabilityLine then
			return false
		end

		local checkHighScalabilityStamp = nil
		if stampInModel then
			local canStamp = nil
			local isHSLPart = isMegaClusterPart()

			if isHSLPart and
				HighScalabilityLine and
				HighScalabilityLine.Start and
				HighScalabilityLine.InternalLine and
				HighScalabilityLine.InternalLine.magnitude > 0 then -- we have an HSL line, test later
					canStamp = true
					checkHighScalabilityStamp = true
			else
				canStamp, checkHighScalabilityStamp = t.CanEditRegion(stampData.CurrentParts, allowedStampRegion)
			end

			if not canStamp then
				if stampFailedFunc then
					stampFailedFunc()
				end
				return false
			end
		end

		-- if unstampable face, then don't let us stamp there!
		if unstampableSurface then
			flashRedBox()
			return false
		end

		-- recheck if we can stamp, as we just moved part
		local canStamp, checkHighScalabilityStamp = t.CanEditRegion(stampData.CurrentParts, allowedStampRegion)
		if not canStamp then
			if stampFailedFunc then
				stampFailedFunc()
			end
			return false
		end

		-- Prevent part from being stamped on top of a player

		local minBB, maxBB = getBoundingBoxInWorldCoordinates(stampData.CurrentParts)

		-- HotThoth's note:  Now that above CurrentParts positioning has been commented out, to be truly correct, we would need to use the
		--                     value of configFound from the previous onStamperMouseMove call which moved the CurrentParts
		--                     Shouldn't this be true when lastTargetCFrame has been set and false otherwise?
		configFound, targetCFrame = findConfigAtMouseTarget(Mouse, stampData)

		if configFound and not HighScalabilityLine.Adorn.Parent then
			if clusterPartsInRegion(minBB + insertBoundingBoxOverlapVector, maxBB - insertBoundingBoxOverlapVector) then
				flashRedBox()
				return false
			end

			local blockingParts = game:GetService("Workspace"):FindPartsInRegion3(Region3.new(minBB + insertBoundingBoxOverlapVector,
																	maxBB - insertBoundingBoxOverlapVector),
																	stampData.CurrentParts,
																	100)


			for b = 1, #blockingParts do
				if isBlocker(blockingParts[b]) then
					flashRedBox()
					return false
				end
			end

			local alreadyPushedUp = {}
				-- if no blocking model below, then see if stamping on top of a character
				for b = 1, #blockingParts do
					if	blockingParts[b].Parent and
						not alreadyPushedUp[blockingParts[b].Parent] and
						blockingParts[b].Parent:FindFirstChild("Humanoid") and
						blockingParts[b].Parent:FindFirstChild("Humanoid"):IsA("Humanoid") then
					---------------------------------------------------------------------------
							local blockingPersonTorso = blockingParts[b].Parent:FindFirstChild("Torso")
							alreadyPushedUp[blockingParts[b].Parent] = true

							if blockingPersonTorso then
								-- if so, let's push the person upwards so they pop on top of the stamped model/part (but only if there's space above them)
								local newY = maxBB.Y + 3
								if spaceAboveCharacter(blockingPersonTorso, newY, stampData) then
									blockingPersonTorso.CFrame = blockingPersonTorso.CFrame + Vector3.new(0, newY - blockingPersonTorso.CFrame.p.Y, 0)
								else
									-- if no space, we just error
									flashRedBox()
									return false
								end
							end
					---------------------------------------------------------------------------
					end
				end

		elseif (not configFound) and not (HighScalabilityLine.Start and HighScalabilityLine.Adorn.Parent) then -- if no config then only stamp if it's a real HSL!
			resetHighScalabilityLine()
			return false
		end

		-- something will be stamped!  so set the "StampedSomething" toggle to true
		if game:GetService("Players")["LocalPlayer"] then
			if game:GetService("Players").LocalPlayer["Character"] then
				local localChar = game:GetService("Players").LocalPlayer.Character
				local stampTracker = localChar:FindFirstChild("StampTracker")
				if stampTracker and not stampTracker.Value then
					stampTracker.Value = true
				end
			end
		end

		-- if we drew a line of mega parts, stamp them out
		if HighScalabilityLine.Start and HighScalabilityLine.Adorn.Parent and isMegaClusterPart() then
			if ResolveMegaClusterStamp(checkHighScalabilityStamp) or checkHighScalabilityStamp then
				-- kill the ghost part
				stampData.CurrentParts.Parent = nil
				return true
			end
		end

		-- not High-Scalability-Line-Based, so behave normally [and get rid of any HSL stuff]
		HighScalabilityLine.Start = nil
		HighScalabilityLine.Adorn.Parent = nil

		local cluster = game:GetService("Workspace").Terrain

		-- if target point is in cluster, just use cluster:SetCell
		if isMegaClusterPart() then
			-- if targetCFrame is inside cluster, just set that cell to 1 and return
			--local cellPos = cluster:WorldToCell(targetCFrame.p)

			local cellPos
			if stampData.CurrentParts:IsA("Model") then cellPos = cluster:WorldToCell(stampData.CurrentParts:GetModelCFrame().p)
			else cellPos = cluster:WorldToCell(stampData.CurrentParts.CFrame.p) end

			local cMax = game:GetService("Workspace").Terrain.MaxExtents.Max
			local cMin = game:GetService("Workspace").Terrain.MaxExtents.Min

			if checkTerrainBlockCollisions(cellPos, false) then

				local clusterValues = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
				local waterForceTag = stampData.CurrentParts:FindFirstChild("WaterForceTag", true)
				local waterForceDirectionTag = stampData.CurrentParts:FindFirstChild("WaterForceDirectionTag", true)

				if cellPos.X >= cMin.X and cellPos.Y >= cMin.Y and cellPos.Z >= cMin.Z and cellPos.X < cMax.X and cellPos.Y < cMax.Y and cellPos.Z < cMax.Z then

					if waterForceTag then
						cluster:SetWaterCell(cellPos.X, cellPos.Y, cellPos.Z, Enum.WaterForce[waterForceTag.Value], Enum.WaterDirection[waterForceDirectionTag.Value])
					elseif not clusterValues then
						cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, cellInfo.Material, cellInfo.clusterType, gInitial90DegreeRotations % 4)
					elseif clusterValues:IsA("Vector3Value") then
						cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, clusterValues.Value.X, clusterValues.Value.Y, clusterValues.Value.Z)
					else
						cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, clusterValues.Value, 0, 0)
					end

					local autoWedgeClusterParts = false
					if stampData.CurrentParts:FindFirstChild("AutoWedge") then autoWedgeClusterParts = true end

					-- auto-wedge it
					if (autoWedgeClusterParts) then
						game:GetService("Workspace").Terrain:AutowedgeCells(
							Region3int16.new(
								Vector3int16.new(cellPos.x - 1, cellPos.y - 1, cellPos.z - 1),
								Vector3int16.new(cellPos.x + 1, cellPos.y + 1, cellPos.z + 1)
							)
						)
					end

					-- kill the ghost part
					stampData.CurrentParts.Parent = nil

					-- Mark for undo.  It has to happen here or the selection display will come back also.
					pcall(function() game:GetService("ChangeHistoryService"):SetWaypoint("StamperSingle") end)
					return true
				end
			else
				-- you tried to stamp a HSL-single part where one does not belong!
				flashRedBox()
				return false
			end
		end

		local function getPlayer()
			if game:GetService("Players")["LocalPlayer"] then
				return game:GetService("Players").LocalPlayer
			end
			return nil
		end


		-- Post process: after positioning the part or model, restore transparency, material, anchored and collide states and create joints
		if stampData.CurrentParts:IsA("Model") or stampData.CurrentParts:IsA("Tool") then
			if stampData.CurrentParts:IsA("Model") then
				-- Tyler's magical hack-code for allowing/preserving clones of both Surface and Manual Welds...  just don't ask X<
				local manualWeldTable = {}
				local manualWeldParentTable = {}
				saveTheWelds(stampData.CurrentParts, manualWeldTable, manualWeldParentTable)
				stampData.CurrentParts:BreakJoints()
				stampData.CurrentParts:MakeJoints()
				restoreTheWelds(manualWeldTable, manualWeldParentTable)
			end

			-- if it's a model, we also want to fill in the playerID and playerName tags, if it has those (e.g. for the friend-only door)
			local playerIdTag = stampData.CurrentParts:FindFirstChild("PlayerIdTag")
			local playerNameTag = stampData.CurrentParts:FindFirstChild("PlayerNameTag")
			if playerIdTag ~= nil then
				local tempPlayerValue = getPlayer()
				if tempPlayerValue ~= nil then playerIdTag.Value = tempPlayerValue.UserId end
			end
			if playerNameTag ~= nil then
				if game:GetService("Players")["LocalPlayer"] then
					local tempPlayerValue = game:GetService("Players").LocalPlayer
					if tempPlayerValue ~= nil then playerNameTag.Value = tempPlayerValue.Name end
				end
			end
			-- ...and tag all inserted models for subsequent origin identification
			-- if no RobloxModel tag already exists, then add it.
			if stampData.CurrentParts:FindFirstChild("RobloxModel") == nil then
				local stringTag = Instance.new("BoolValue", stampData.CurrentParts)
				stringTag.Name = "RobloxModel"

				if stampData.CurrentParts:FindFirstChild("RobloxStamper") == nil then
					local stringTag2 = Instance.new("BoolValue", stampData.CurrentParts)
					stringTag2.Name = "RobloxStamper"
				end
			end

		else
			stampData.CurrentParts:BreakJoints()
			if stampData.CurrentParts:FindFirstChild("RobloxStamper") == nil then
				local stringTag2 = Instance.new("BoolValue", stampData.CurrentParts)
				stringTag2.Name = "RobloxStamper"
			end
		end

		-- make sure all the joints are activated before restoring anchor states
		game:GetService("JointsService"):CreateJoinAfterMoveJoints()

		-- Restore the original properties for all parts being stamped
		for part, transparency in pairs(stampData.TransparencyTable) do
			part.Transparency = transparency
		end
		for part, archivable in pairs(stampData.ArchivableTable) do
			part.Archivable = archivable
		end
		for part, material in pairs(stampData.MaterialTable) do
			part.Material = material
		end
		for part, collide in pairs(stampData.CanCollideTable) do
			part.CanCollide = collide
		end
		for part, anchored in pairs(stampData.AnchoredTable) do
			part.Anchored = anchored
		end
		for decal, transparency in pairs(stampData.DecalTransparencyTable) do
			decal.Transparency = transparency
		end

		for part, surfaces in pairs(stampData.SurfaceTypeTable) do
			loadSurfaceTypes(part, surfaces)
		end

		if isMegaClusterPart() then
			stampData.CurrentParts.Transparency = 0
		end

		-- re-enable all seats
		setSeatEnabledStatus(stampData.CurrentParts, true)

		stampData.TransparencyTable = nil
		stampData.ArchivableTable = nil
		stampData.MaterialTable = nil
		stampData.CanCollideTable = nil
		stampData.AnchoredTable = nil
		stampData.SurfaceTypeTable = nil

		-- ...and tag all inserted models for subsequent origin identification
		-- if no RobloxModel tag already exists, then add it.
		if stampData.CurrentParts:FindFirstChild("RobloxModel") == nil then
			local stringTag = Instance.new("BoolValue", stampData.CurrentParts)
			stringTag.Name = "RobloxModel"
		end

		--Re-enable the scripts
		for index,script in pairs(stampData.DisabledScripts) do
			script.Disabled = false
		end

		--Now that they are all marked enabled, reinsert them into the world so they start running
		for index,script in pairs(stampData.DisabledScripts) do
			local oldParent = script.Parent
			script.Parent = nil
			script:Clone().Parent = oldParent
		end

		-- clear out more data
		stampData.DisabledScripts = nil
		stampData.Dragger = nil
		stampData.CurrentParts = nil

		pcall(function() game:GetService("ChangeHistoryService"): SetWaypoint("StampedObject") end)
		return true
	end

	local function pauseStamper()
		for i = 1, #mouseCons do -- stop the mouse from doing anything
			mouseCons[i]:disconnect()
			mouseCons[i] = nil
		end
		mouseCons = {}

		if stampData and stampData.CurrentParts then -- remove our ghost part
			stampData.CurrentParts.Parent = nil
			stampData.CurrentParts:Remove()
		end

		resetHighScalabilityLine()

		game:GetService("JointsService"):ClearJoinAfterMoveJoints()
	end


	local function prepareUnjoinableSurfaces(modelCFrame, parts, whichSurface)
		local AXIS_VECTORS = {Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1)}  -- maybe last one is negative?  TODO: check this!
		local isPositive = 1
		if whichSurface < 0 then isPositive = isPositive * -1 whichSurface = whichSurface*-1 end
		local surfaceNormal = isPositive * modelCFrame:vectorToWorldSpace(AXIS_VECTORS[whichSurface])

		for i = 1, #parts do
			local currPart = parts[i]

			-- now just need to find which surface of currPart most closely match surfaceNormal and then set that to Unjoinable
			local surfaceNormalInLocalCoords = currPart.CFrame:vectorToObjectSpace(surfaceNormal)
			if math.abs(surfaceNormalInLocalCoords.X) > math.abs(surfaceNormalInLocalCoords.Y) then
				if math.abs(surfaceNormalInLocalCoords.X) > math.abs(surfaceNormalInLocalCoords.Z) then
					if surfaceNormalInLocalCoords.X > 0 then currPart.RightSurface = "Unjoinable" else currPart.LeftSurface = "Unjoinable" end
				else
					if surfaceNormalInLocalCoords.Z > 0 then currPart.BackSurface = "Unjoinable" else currPart.FrontSurface = "Unjoinable" end
				end
			else
				if math.abs(surfaceNormalInLocalCoords.Y) > math.abs(surfaceNormalInLocalCoords.Z) then
					if surfaceNormalInLocalCoords.Y > 0 then currPart.TopSurface = "Unjoinable" else currPart.BottomSurface = "Unjoinable" end
				else
					if surfaceNormalInLocalCoords.Z > 0 then currPart.BackSurface = "Unjoinable" else currPart.FrontSurface = "Unjoinable" end
				end
			end
		end
	end

	local function resumeStamper()
		local clone, parts = prepareModel(modelToStamp)

		if not clone or not parts then
			return
		end

		-- if we have unjoinable faces, then we want to change those surfaces to be Unjoinable
		local unjoinableTag = clone:FindFirstChild("UnjoinableFaces", true)
		if unjoinableTag then
			for unjoinableSurface in string.gmatch(unjoinableTag.Value, "[^,]*") do
				if tonumber(unjoinableSurface) then
					if clone:IsA("Model") then
						prepareUnjoinableSurfaces(clone:GetModelCFrame(), parts, tonumber(unjoinableSurface))
					else
						prepareUnjoinableSurfaces(clone.CFrame, parts, tonumber(unjoinableSurface))
					end
				end
			end
		end

		stampData.ErrorBox = errorBox
		if stampInModel then
			clone.Parent = stampInModel
		else
			clone.Parent = game:GetService("Workspace")
		end

		if clone:FindFirstChild("ClusterMaterial", true) then -- extract all info from vector
			local clusterMaterial = clone:FindFirstChild("ClusterMaterial", true)
			if (clusterMaterial:IsA("Vector3Value")) then
				cellInfo.Material = clusterMaterial.Value.X
				cellInfo.clusterType = clusterMaterial.Value.Y
				cellInfo.clusterOrientation = clusterMaterial.Value.Z
			elseif clusterMaterial:IsA("IntValue") then
				cellInfo.Material = clusterMaterial.Value
			end
		end

		pcall(function() mouseTarget = Mouse.Target end)

		if mouseTarget and mouseTarget.Parent:FindFirstChild("RobloxModel") == nil then
			game:GetService("JointsService"):SetJoinAfterMoveTarget(mouseTarget)
		else
			game:GetService("JointsService"):SetJoinAfterMoveTarget(nil)
		end
		game:GetService("JointsService"):ShowPermissibleJoints()

		for index, object in pairs(stampData.DisabledScripts) do
			if object.Name == "GhostRemovalScript" then
				object.Parent = stampData.CurrentParts
			end
		end

		stampData.Dragger = Instance.new("Dragger")

		--Begin a movement by faking a MouseDown signal
		stampData.Dragger:MouseDown(parts[1], Vector3.new(0,0,0), parts)
		stampData.Dragger:MouseUp()

		DoStamperMouseMove(Mouse)

		table.insert(mouseCons,Mouse.Move:connect(function()
			if movingLock or stampUpLock then return end
			movingLock = true
				DoStamperMouseMove(Mouse)
			movingLock = false
		end))

		table.insert(mouseCons,Mouse.Button1Down:connect(function()
			DoStamperMouseDown(Mouse)
		end))

		table.insert(mouseCons,Mouse.Button1Up:connect(function()
			stampUpLock = true
				while movingLock do wait() end
				stamped.Value = DoStamperMouseUp(Mouse)
				resetHighScalabilityLine()
			stampUpLock = false
		end))

		stamped.Value = false
	end

	local function resetStamperState(newModelToStamp)

		-- if we have a new model, swap it out
		if newModelToStamp then
			if not newModelToStamp:IsA("Model") and not newModelToStamp:IsA("BasePart") then
				error("resetStamperState: newModelToStamp (first arg) is not nil, but not a model or part!")
			end
			modelToStamp = newModelToStamp
		end

		-- first clear our state
		pauseStamper()
		-- now lets load in the new model
		resumeStamper()

	end

	-- load the model initially
	resetStamperState()


	-- setup the control table we pass back to the user
	control.Stamped = stamped -- BoolValue that fires when user stamps
	control.Paused = false

	control.LoadNewModel = function(newStampModel) -- allows us to specify a new stamper model to be used with this stamper
		if newStampModel and not newStampModel:IsA("Model") and not newStampModel:IsA("BasePart") then
			error("Control.LoadNewModel: newStampModel (first arg) is not a Model or Part!")
			return nil
		end
		resetStamperState(newStampModel)
	end

	control.ReloadModel = function() -- will automatically set stamper to get a new model of current model and start stamping with new model
		resetStamperState()
	end

	control.Pause = function() -- temporarily stops stamping, use resume to start up again
		if not control.Paused then
			pauseStamper()
			control.Paused = true
		else
			print("RbxStamper Warning: Tried to call Control.Pause() when already paused")
		end
	end

	control.Resume = function() -- resumes stamping, if currently paused
		if control.Paused then
			resumeStamper()
			control.Paused = false
		else
			print("RbxStamper Warning: Tried to call Control.Resume() without Pausing First")
		end
	end

	control.ResetRotation = function() -- resets the model rotation so new models are at default orientation
		-- gInitial90DegreeRotations = 0
		-- Note:  This function will not always work quite the way we want it to; we will have to build this out further so it works with
		--        High-Scalability and with the new model orientation setting methods (model:ResetOrientationToIdentity())  [HotThoth]
	end

	control.Destroy = function() -- Stops current Stamp operation and destroys control construct
		for i = 1, #mouseCons do
			mouseCons[i]:disconnect()
			mouseCons[i] = nil
		end

		if keyCon then
			keyCon:disconnect()
		end

		game:GetService("JointsService"):ClearJoinAfterMoveJoints()

		if adorn then adorn:Destroy() end
		if adornPart then adornPart:Destroy() end
		if errorBox then errorBox:Destroy() end
		if stampData then
			if stampData["Dragger"] then
				stampData.Dragger:Destroy()
			end
			if stampData.CurrentParts then
				stampData.CurrentParts:Destroy()
			end
		end
		if control and control["Stamped"] then
			control.Stamped:Destroy()
		end
		control = nil
	end

	return control
end

t.Help =
	function(funcNameOrFunc)
		--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
		if funcNameOrFunc == "GetStampModel" or funcNameOrFunc == t.GetStampModel then
			return "Function GetStampModel.  Arguments: assetId, useAssetVersionId.  assetId is the asset to load in, define useAssetVersionId as true if assetId is a version id instead of a relative assetId.  Side effect: returns a model of the assetId, or a string with error message if something fails"
		end
		if funcNameOrFunc == "SetupStamperDragger" or funcNameOrFunc == t.SetupStamperDragger then
			return "Function SetupStamperDragger. Side Effect: Creates 4x4 stamping mechanism for building out parts quickly. Arguments: ModelToStamp, Mouse, LegalStampCheckFunction. ModelToStamp should be a Model or Part, preferrably loaded from RbxStamper.GetStampModel and should have extents that are multiples of 4.  Mouse should be a mouse object (obtained from things such as Tool.OnEquipped), used to drag parts around 'stamp' them out. LegalStampCheckFunction is optional, used as a callback with a table argument (table is full of instances about to be stamped). Function should return either true or false, false stopping the stamp action."
		end
	end

return t

end;
};
G2L_MODULES[G2L["124"]] = {
Closure = function()
    local script = G2L["124"];local t = {}

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------JSON Functions Begin----------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

 --JSON Encoder and Parser for Lua 5.1
 --
 --Copyright 2007 Shaun Brown  (http://www.chipmunkav.com)
 --All Rights Reserved.
 
 --Permission is hereby granted, free of charge, to any person 
 --obtaining a copy of this software to deal in the Software without 
 --restriction, including without limitation the rights to use, 
 --copy, modify, merge, publish, distribute, sublicense, and/or 
 --sell copies of the Software, and to permit persons to whom the 
 --Software is furnished to do so, subject to the following conditions:
 
 --The above copyright notice and this permission notice shall be 
 --included in all copies or substantial portions of the Software.
 --If you find this software useful please give www.chipmunkav.com a mention.

 --THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 --EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
 --OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 --IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
 --ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
 --CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
 --CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
local string = string
local math = math
local table = table
local error = error
local tonumber = tonumber
local tostring = tostring
local type = type
local setmetatable = setmetatable
local pairs = pairs
local ipairs = ipairs
local assert = assert


local StringBuilder = {
	buffer = {}
}

function StringBuilder:New()
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.buffer = {}
	return o
end

function StringBuilder:Append(s)
	self.buffer[#self.buffer+1] = s
end

function StringBuilder:ToString()
	return table.concat(self.buffer)
end

local JsonWriter = {
	backslashes = {
		['\b'] = "\\b",
		['\t'] = "\\t",	
		['\n'] = "\\n", 
		['\f'] = "\\f",
		['\r'] = "\\r", 
		['"']  = "\\\"", 
		['\\'] = "\\\\", 
		['/']  = "\\/"
	}
}

function JsonWriter:New()
	local o = {}
	o.writer = StringBuilder:New()
	setmetatable(o, self)
	self.__index = self
	return o
end

function JsonWriter:Append(s)
	self.writer:Append(s)
end

function JsonWriter:ToString()
	return self.writer:ToString()
end

function JsonWriter:Write(o)
	local t = type(o)
	if t == "nil" then
		self:WriteNil()
	elseif t == "boolean" then
		self:WriteString(o)
	elseif t == "number" then
		self:WriteString(o)
	elseif t == "string" then
		self:ParseString(o)
	elseif t == "table" then
		self:WriteTable(o)
	elseif t == "function" then
		self:WriteFunction(o)
	elseif t == "thread" then
		self:WriteError(o)
	elseif t == "userdata" then
		self:WriteError(o)
	end
end

function JsonWriter:WriteNil()
	self:Append("null")
end

function JsonWriter:WriteString(o)
	self:Append(tostring(o))
end

function JsonWriter:ParseString(s)
	self:Append('"')
	self:Append(string.gsub(s, "[%z%c\\\"/]", function(n)
		local c = self.backslashes[n]
		if c then return c end
		return string.format("\\u%.4X", string.byte(n))
	end))
	self:Append('"')
end

function JsonWriter:IsArray(t)
	local count = 0
	local isindex = function(k) 
		if type(k) == "number" and k > 0 then
			if math.floor(k) == k then
				return true
			end
		end
		return false
	end
	for k,v in pairs(t) do
		if not isindex(k) then
			return false, '{', '}'
		else
			count = math.max(count, k)
		end
	end
	return true, '[', ']', count
end

function JsonWriter:WriteTable(t)
	local ba, st, et, n = self:IsArray(t)
	self:Append(st)	
	if ba then		
		for i = 1, n do
			self:Write(t[i])
			if i < n then
				self:Append(',')
			end
		end
	else
		local first = true;
		for k, v in pairs(t) do
			if not first then
				self:Append(',')
			end
			first = false;			
			self:ParseString(k)
			self:Append(':')
			self:Write(v)			
		end
	end
	self:Append(et)
end

function JsonWriter:WriteError(o)
	error(string.format(
		"Encoding of %s unsupported", 
		tostring(o)))
end

function JsonWriter:WriteFunction(o)
	if o == Null then 
		self:WriteNil()
	else
		self:WriteError(o)
	end
end

local StringReader = {
	s = "",
	i = 0
}

function StringReader:New(s)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.s = s or o.s
	return o	
end

function StringReader:Peek()
	local i = self.i + 1
	if i <= #self.s then
		return string.sub(self.s, i, i)
	end
	return nil
end

function StringReader:Next()
	self.i = self.i+1
	if self.i <= #self.s then
		return string.sub(self.s, self.i, self.i)
	end
	return nil
end

function StringReader:All()
	return self.s
end

local JsonReader = {
	escapes = {
		['t'] = '\t',
		['n'] = '\n',
		['f'] = '\f',
		['r'] = '\r',
		['b'] = '\b',
	}
}

function JsonReader:New(s)
	local o = {}
	o.reader = StringReader:New(s)
	setmetatable(o, self)
	self.__index = self
	return o;
end

function JsonReader:Read()
	self:SkipWhiteSpace()
	local peek = self:Peek()
	if peek == nil then
		error(string.format(
			"Nil string: '%s'", 
			self:All()))
	elseif peek == '{' then
		return self:ReadObject()
	elseif peek == '[' then
		return self:ReadArray()
	elseif peek == '"' then
		return self:ReadString()
	elseif string.find(peek, "[%+%-%d]") then
		return self:ReadNumber()
	elseif peek == 't' then
		return self:ReadTrue()
	elseif peek == 'f' then
		return self:ReadFalse()
	elseif peek == 'n' then
		return self:ReadNull()
	elseif peek == '/' then
		self:ReadComment()
		return self:Read()
	else
		return nil
	end
end
		
function JsonReader:ReadTrue()
	self:TestReservedWord{'t','r','u','e'}
	return true
end

function JsonReader:ReadFalse()
	self:TestReservedWord{'f','a','l','s','e'}
	return false
end

function JsonReader:ReadNull()
	self:TestReservedWord{'n','u','l','l'}
	return nil
end

function JsonReader:TestReservedWord(t)
	for i, v in ipairs(t) do
		if self:Next() ~= v then
			 error(string.format(
				"Error reading '%s': %s", 
				table.concat(t), 
				self:All()))
		end
	end
end

function JsonReader:ReadNumber()
        local result = self:Next()
        local peek = self:Peek()
        while peek ~= nil and string.find(
		peek, 
		"[%+%-%d%.eE]") do
            result = result .. self:Next()
            peek = self:Peek()
	end
	result = tonumber(result)
	if result == nil then
	        error(string.format(
			"Invalid number: '%s'", 
			result))
	else
		return result
	end
end

function JsonReader:ReadString()
	local result = ""
	assert(self:Next() == '"')
        while self:Peek() ~= '"' do
		local ch = self:Next()
		if ch == '\\' then
			ch = self:Next()
			if self.escapes[ch] then
				ch = self.escapes[ch]
			end
		end
                result = result .. ch
	end
        assert(self:Next() == '"')
	local fromunicode = function(m)
		return string.char(tonumber(m, 16))
	end
	return string.gsub(
		result, 
		"u%x%x(%x%x)", 
		fromunicode)
end

function JsonReader:ReadComment()
        assert(self:Next() == '/')
        local second = self:Next()
        if second == '/' then
            self:ReadSingleLineComment()
        elseif second == '*' then
            self:ReadBlockComment()
        else
            error(string.format(
		"Invalid comment: %s", 
		self:All()))
	end
end

function JsonReader:ReadBlockComment()
	local done = false
	while not done do
		local ch = self:Next()		
		if ch == '*' and self:Peek() == '/' then
			done = true
                end
		if not done and 
			ch == '/' and 
			self:Peek() == "*" then
                    error(string.format(
			"Invalid comment: %s, '/*' illegal.",  
			self:All()))
		end
	end
	self:Next()
end

function JsonReader:ReadSingleLineComment()
	local ch = self:Next()
	while ch ~= '\r' and ch ~= '\n' do
		ch = self:Next()
	end
end

function JsonReader:ReadArray()
	local result = {}
	assert(self:Next() == '[')
	local done = false
	if self:Peek() == ']' then
		done = true;
	end
	while not done do
		local item = self:Read()
		result[#result+1] = item
		self:SkipWhiteSpace()
		if self:Peek() == ']' then
			done = true
		end
		if not done then
			local ch = self:Next()
			if ch ~= ',' then
				error(string.format(
					"Invalid array: '%s' due to: '%s'", 
					self:All(), ch))
			end
		end
	end
	assert(']' == self:Next())
	return result
end

function JsonReader:ReadObject()
	local result = {}
	assert(self:Next() == '{')
	local done = false
	if self:Peek() == '}' then
		done = true
	end
	while not done do
		local key = self:Read()
		if type(key) ~= "string" then
			error(string.format(
				"Invalid non-string object key: %s", 
				key))
		end
		self:SkipWhiteSpace()
		local ch = self:Next()
		if ch ~= ':' then
			error(string.format(
				"Invalid object: '%s' due to: '%s'", 
				self:All(), 
				ch))
		end
		self:SkipWhiteSpace()
		local val = self:Read()
		result[key] = val
		self:SkipWhiteSpace()
		if self:Peek() == '}' then
			done = true
		end
		if not done then
			ch = self:Next()
                	if ch ~= ',' then
				error(string.format(
					"Invalid array: '%s' near: '%s'", 
					self:All(), 
					ch))
			end
		end
	end
	assert(self:Next() == "}")
	return result
end

function JsonReader:SkipWhiteSpace()
	local p = self:Peek()
	while p ~= nil and string.find(p, "[%s/]") do
		if p == '/' then
			self:ReadComment()
		else
			self:Next()
		end
		p = self:Peek()
	end
end

function JsonReader:Peek()
	return self.reader:Peek()
end

function JsonReader:Next()
	return self.reader:Next()
end

function JsonReader:All()
	return self.reader:All()
end

function Encode(o)
	local writer = JsonWriter:New()
	writer:Write(o)
	return writer:ToString()
end

function Decode(s)
	local reader = JsonReader:New(s)
	return reader:Read()
end

function Null()
	return Null
end
-------------------- End JSON Parser ------------------------

t.DecodeJSON = function(jsonString)
	pcall(function() warn("RbxUtility.DecodeJSON is deprecated, please use Game:GetService('HttpService'):JSONDecode() instead.") end)

	if type(jsonString) == "string" then
		return Decode(jsonString)
	end
	print("RbxUtil.DecodeJSON expects string argument!")
	return nil
end

t.EncodeJSON = function(jsonTable)
	pcall(function() warn("RbxUtility.EncodeJSON is deprecated, please use Game:GetService('HttpService'):JSONEncode() instead.") end)
	return Encode(jsonTable)
end








------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
--------------------------------------------Terrain Utilities Begin-----------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
--makes a wedge at location x, y, z
--sets cell x, y, z to default material if parameter is provided, if not sets cell x, y, z to be whatever material it previously w
--returns true if made a wedge, false if the cell remains a block
t.MakeWedge = function(x, y, z, defaultmaterial)
	return game:GetService("Terrain"):AutoWedgeCell(x,y,z)
end

t.SelectTerrainRegion = function(regionToSelect, color, selectEmptyCells, selectionParent)
	local terrain = game:GetService("Workspace"):FindFirstChild("Terrain")
	if not terrain then return end

	assert(regionToSelect)
	assert(color)

	if not type(regionToSelect) == "Region3" then
		error("regionToSelect (first arg), should be of type Region3, but is type",type(regionToSelect))
	end
	if not type(color) == "BrickColor" then
		error("color (second arg), should be of type BrickColor, but is type",type(color))
	end

	-- frequently used terrain calls (speeds up call, no lookup necessary)
	local GetCell = terrain.GetCell
	local WorldToCellPreferSolid = terrain.WorldToCellPreferSolid
	local CellCenterToWorld = terrain.CellCenterToWorld
	local emptyMaterial = Enum.CellMaterial.Empty

	-- container for all adornments, passed back to user
	local selectionContainer = Instance.new("Model")
	selectionContainer.Name = "SelectionContainer"
	selectionContainer.Archivable = false
	if selectionParent then
		selectionContainer.Parent = selectionParent
	else
		selectionContainer.Parent = game:GetService("Workspace")
	end

	local updateSelection = nil -- function we return to allow user to update selection
	local currentKeepAliveTag = nil -- a tag that determines whether adorns should be destroyed
	local aliveCounter = 0 -- helper for currentKeepAliveTag
	local lastRegion = nil -- used to stop updates that do nothing
	local adornments = {} -- contains all adornments
	local reusableAdorns = {}

	local selectionPart = Instance.new("Part")
	selectionPart.Name = "SelectionPart"
	selectionPart.Transparency = 1
	selectionPart.Anchored = true
	selectionPart.Locked = true
	selectionPart.CanCollide = false
	selectionPart.Size = Vector3.new(4.2,4.2,4.2)

	local selectionBox = Instance.new("SelectionBox")

	-- srs translation from region3 to region3int16
	local function Region3ToRegion3int16(region3)
		local theLowVec = region3.CFrame.p - (region3.Size/2) + Vector3.new(2,2,2)
		local lowCell = WorldToCellPreferSolid(terrain,theLowVec)

		local theHighVec = region3.CFrame.p + (region3.Size/2) - Vector3.new(2,2,2)
		local highCell = WorldToCellPreferSolid(terrain, theHighVec)

		local highIntVec = Vector3int16.new(highCell.x,highCell.y,highCell.z)
		local lowIntVec = Vector3int16.new(lowCell.x,lowCell.y,lowCell.z)

		return Region3int16.new(lowIntVec,highIntVec)
	end

	-- helper function that creates the basis for a selection box
	function createAdornment(theColor)
		local selectionPartClone = nil
		local selectionBoxClone = nil

		if #reusableAdorns > 0 then
			selectionPartClone = reusableAdorns[1]["part"]
			selectionBoxClone = reusableAdorns[1]["box"]
			table.remove(reusableAdorns,1)

			selectionBoxClone.Visible = true
		else
			selectionPartClone = selectionPart:Clone()
			selectionPartClone.Archivable = false

			selectionBoxClone = selectionBox:Clone()
			selectionBoxClone.Archivable = false

			selectionBoxClone.Adornee = selectionPartClone
			selectionBoxClone.Parent = selectionContainer

			selectionBoxClone.Adornee = selectionPartClone

			selectionBoxClone.Parent = selectionContainer
		end
			
		if theColor then
			selectionBoxClone.Color = theColor
		end

		return selectionPartClone, selectionBoxClone
	end

	-- iterates through all current adornments and deletes any that don't have latest tag
	function cleanUpAdornments()
		for cellPos, adornTable in pairs(adornments) do

			if adornTable.KeepAlive ~= currentKeepAliveTag then -- old news, we should get rid of this
				adornTable.SelectionBox.Visible = false
				table.insert(reusableAdorns,{part = adornTable.SelectionPart, box = adornTable.SelectionBox})
				adornments[cellPos] = nil
			end
		end
	end

	-- helper function to update tag
	function incrementAliveCounter()
		aliveCounter = aliveCounter + 1
		if aliveCounter > 1000000 then
			aliveCounter = 0
		end
		return aliveCounter
	end

	-- finds full cells in region and adorns each cell with a box, with the argument color
	function adornFullCellsInRegion(region, color)
		local regionBegin = region.CFrame.p - (region.Size/2) + Vector3.new(2,2,2)
		local regionEnd = region.CFrame.p + (region.Size/2) - Vector3.new(2,2,2)

		local cellPosBegin = WorldToCellPreferSolid(terrain, regionBegin)
		local cellPosEnd = WorldToCellPreferSolid(terrain, regionEnd)

		currentKeepAliveTag = incrementAliveCounter()
		for y = cellPosBegin.y, cellPosEnd.y do
			for z = cellPosBegin.z, cellPosEnd.z do
				for x = cellPosBegin.x, cellPosEnd.x do
					local cellMaterial = GetCell(terrain, x, y, z)
					
					if cellMaterial ~= emptyMaterial then
						local cframePos = CellCenterToWorld(terrain, x, y, z)
						local cellPos = Vector3int16.new(x,y,z)

						local updated = false
						for cellPosAdorn, adornTable in pairs(adornments) do
							if cellPosAdorn == cellPos then
								adornTable.KeepAlive = currentKeepAliveTag
								if color then
									adornTable.SelectionBox.Color = color
								end
								updated = true
								break
							end 
						end

						if not updated then
							local selectionPart, selectionBox = createAdornment(color)
							selectionPart.Size = Vector3.new(4,4,4)
							selectionPart.CFrame = CFrame.new(cframePos)
							local adornTable = {SelectionPart = selectionPart, SelectionBox = selectionBox, KeepAlive = currentKeepAliveTag}
							adornments[cellPos] = adornTable
						end
					end
				end
			end
		end
		cleanUpAdornments()
	end


	------------------------------------- setup code ------------------------------
	lastRegion = regionToSelect

	if selectEmptyCells then -- use one big selection to represent the area selected
		local selectionPart, selectionBox = createAdornment(color)

		selectionPart.Size = regionToSelect.Size
		selectionPart.CFrame = regionToSelect.CFrame

		adornments.SelectionPart = selectionPart
		adornments.SelectionBox = selectionBox

		updateSelection = 
			function (newRegion, color)
				if newRegion and newRegion ~= lastRegion then
					lastRegion = newRegion
				 	selectionPart.Size = newRegion.Size
					selectionPart.CFrame = newRegion.CFrame
				end
				if color then
					selectionBox.Color = color
				end
			end
	else -- use individual cell adorns to represent the area selected
		adornFullCellsInRegion(regionToSelect, color)
		updateSelection = 
			function (newRegion, color)
				if newRegion and newRegion ~= lastRegion then
					lastRegion = newRegion
					adornFullCellsInRegion(newRegion, color)
				end
			end

	end

	local destroyFunc = function()
		updateSelection = nil
		if selectionContainer then selectionContainer:Destroy() end
		adornments = nil
	end

	return updateSelection, destroyFunc
end

-----------------------------Terrain Utilities End-----------------------------







------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------Signal class begin------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
--[[
A 'Signal' object identical to the internal RBXScriptSignal object in it's public API and semantics. This function 
can be used to create "custom events" for user-made code.
API:
Method :connect( function handler )
	Arguments:   The function to connect to.
	Returns:     A new connection object which can be used to disconnect the connection
	Description: Connects this signal to the function specified by |handler|. That is, when |fire( ... )| is called for
	             the signal the |handler| will be called with the arguments given to |fire( ... )|. Note, the functions
	             connected to a signal are called in NO PARTICULAR ORDER, so connecting one function after another does
	             NOT mean that the first will be called before the second as a result of a call to |fire|.

Method :disconnect()
	Arguments:   None
	Returns:     None
	Description: Disconnects all of the functions connected to this signal.

Method :fire( ... )
	Arguments:   Any arguments are accepted
	Returns:     None
	Description: Calls all of the currently connected functions with the given arguments.

Method :wait()
	Arguments:   None
	Returns:     The arguments given to fire
	Description: This call blocks until 
]]

function t.CreateSignal()
	local this = {}

	local mBindableEvent = Instance.new('BindableEvent')
	local mAllCns = {} --all connection objects returned by mBindableEvent::connect

	--main functions
	function this:connect(func)
		if self ~= this then error("connect must be called with `:`, not `.`", 2) end
		if type(func) ~= 'function' then
			error("Argument #1 of connect must be a function, got a "..type(func), 2)
		end
		local cn = mBindableEvent.Event:Connect(func)
		mAllCns[cn] = true
		local pubCn = {}
		function pubCn:disconnect()
			cn:Disconnect()
			mAllCns[cn] = nil
		end
		pubCn.Disconnect = pubCn.disconnect
		
		return pubCn
	end
	
	function this:disconnect()
		if self ~= this then error("disconnect must be called with `:`, not `.`", 2) end
		for cn, _ in pairs(mAllCns) do
			cn:Disconnect()
			mAllCns[cn] = nil
		end
	end
	
	function this:wait()
		if self ~= this then error("wait must be called with `:`, not `.`", 2) end
		return mBindableEvent.Event:Wait()
	end
	
	function this:fire(...)
		if self ~= this then error("fire must be called with `:`, not `.`", 2) end
		mBindableEvent:Fire(...)
	end
	
	this.Connect = this.connect
	this.Disconnect = this.disconnect
	this.Wait = this.wait
	this.Fire = this.fire

	return this
end

------------------------------------------------- Sigal class End ------------------------------------------------------




------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------Create Function Begins---------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
--[[
A "Create" function for easy creation of Roblox instances. The function accepts a string which is the classname of
the object to be created. The function then returns another function which either accepts accepts no arguments, in 
which case it simply creates an object of the given type, or a table argument that may contain several types of data, 
in which case it mutates the object in varying ways depending on the nature of the aggregate data. These are the
type of data and what operation each will perform:
1) A string key mapping to some value:
      Key-Value pairs in this form will be treated as properties of the object, and will be assigned in NO PARTICULAR
      ORDER. If the order in which properties is assigned matter, then they must be assigned somewhere else than the
      |Create| call's body.

2) An integral key mapping to another Instance:
      Normal numeric keys mapping to Instances will be treated as children if the object being created, and will be
      parented to it. This allows nice recursive calls to Create to create a whole hierarchy of objects without a
      need for temporary variables to store references to those objects.

3) A key which is a value returned from Create.Event( eventname ), and a value which is a function function
      The Create.E( string ) function provides a limited way to connect to signals inside of a Create hierarchy 
      for those who really want such a functionality. The name of the event whose name is passed to 
      Create.E( string )

4) A key which is the Create function itself, and a value which is a function
      The function will be run with the argument of the object itself after all other initialization of the object is 
      done by create. This provides a way to do arbitrary things involving the object from withing the create 
      hierarchy. 
      Note: This function is called SYNCHRONOUSLY, that means that you should only so initialization in
      it, not stuff which requires waiting, as the Create call will block until it returns. While waiting in the 
      constructor callback function is possible, it is probably not a good design choice.
      Note: Since the constructor function is called after all other initialization, a Create block cannot have two 
      constructor functions, as it would not be possible to call both of them last, also, this would be unnecessary.


Some example usages:

A simple example which uses the Create function to create a model object and assign two of it's properties.
local model = Create'Model'{
    Name = 'A New model',
    Parent = workspace,
}


An example where a larger hierarchy of object is made. After the call the hierarchy will look like this:
Model_Container
 |-ObjectValue
 |  |
 |  `-BoolValueChild
 `-IntValue

local model = Create'Model'{
    Name = 'Model_Container',
    Create'ObjectValue'{
        Create'BoolValue'{
            Name = 'BoolValueChild',
        },
    },
    Create'IntValue'{},
}


An example using the event syntax:

local part = Create'Part'{
    [Create.E'Touched'] = function(part)
        print("I was touched by "..part.Name)
    end,	
}


An example using the general constructor syntax:

local model = Create'Part'{
    [Create] = function(this)
        print("Constructor running!")
        this.Name = GetGlobalFoosAndBars(this)
    end,
}


Note: It is also perfectly legal to save a reference to the function returned by a call Create, this will not cause
      any unexpected behavior. EG:
      local partCreatingFunction = Create'Part'
      local part = partCreatingFunction()
]]

--the Create function need to be created as a functor, not a function, in order to support the Create.E syntax, so it
--will be created in several steps rather than as a single function declaration.
local function Create_PrivImpl(objectType)
	if type(objectType) ~= 'string' then
		error("Argument of Create must be a string", 2)
	end
	--return the proxy function that gives us the nice Create'string'{data} syntax
	--The first function call is a function call using Lua's single-string-argument syntax
	--The second function call is using Lua's single-table-argument syntax
	--Both can be chained together for the nice effect.
	return function(dat)
		--default to nothing, to handle the no argument given case
		dat = dat or {}

		--make the object to mutate
		local obj = Instance.new(objectType)
		local parent = nil

		--stored constructor function to be called after other initialization
		local ctor = nil

		for k, v in pairs(dat) do
			--add property
			if type(k) == 'string' then
				if k == 'Parent' then
					-- Parent should always be set last, setting the Parent of a new object
					-- immediately makes performance worse for all subsequent property updates.
					parent = v
				else
					obj[k] = v
				end


			--add child
			elseif type(k) == 'number' then
				if type(v) ~= 'userdata' then
					error("Bad entry in Create body: Numeric keys must be paired with children, got a: "..type(v), 2)
				end
				v.Parent = obj


			--event connect
			elseif type(k) == 'table' and k.__eventname then
				if type(v) ~= 'function' then
					error("Bad entry in Create body: Key `[Create.E\'"..k.__eventname.."\']` must have a function value\
					       got: "..tostring(v), 2)
				end
				obj[k.__eventname]:connect(v)


			--define constructor function
			elseif k == t.Create then
				if type(v) ~= 'function' then
					error("Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
					       got: "..tostring(v), 2)
				elseif ctor then
					--ctor already exists, only one allowed
					error("Bad entry in Create body: Only one constructor function is allowed", 2)
				end
				ctor = v


			else
				error("Bad entry ("..tostring(k).." => "..tostring(v)..") in Create body", 2)
			end
		end

		--apply constructor function if it exists
		if ctor then
			ctor(obj)
		end
		
		if parent then
			obj.Parent = parent
		end

		--return the completed object
		return obj
	end
end

--now, create the functor:
t.Create = setmetatable({}, {__call = function(tb, ...) return Create_PrivImpl(...) end})

--and create the "Event.E" syntax stub. Really it's just a stub to construct a table which our Create
--function can recognize as special.
t.Create.E = function(eventName)
	return {__eventname = eventName}
end

-------------------------------------------------Create function End----------------------------------------------------




------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------Documentation Begin-----------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

t.Help = 
	function(funcNameOrFunc) 
		--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
		if funcNameOrFunc == "DecodeJSON" or funcNameOrFunc == t.DecodeJSON then
			return "Function DecodeJSON.  " ..
			       "Arguments: (string).  " .. 
			       "Side effect: returns a table with all parsed JSON values" 
		end
		if funcNameOrFunc == "EncodeJSON" or funcNameOrFunc == t.EncodeJSON then
			return "Function EncodeJSON.  " ..
			       "Arguments: (table).  " .. 
			       "Side effect: returns a string composed of argument table in JSON data format" 
		end  
		if funcNameOrFunc == "MakeWedge" or funcNameOrFunc == t.MakeWedge then
			return "Function MakeWedge. " ..
			       "Arguments: (x, y, z, [default material]). " ..
			       "Description: Makes a wedge at location x, y, z. Sets cell x, y, z to default material if "..
			       "parameter is provided, if not sets cell x, y, z to be whatever material it previously was. "..
			       "Returns true if made a wedge, false if the cell remains a block "
		end
		if funcNameOrFunc == "SelectTerrainRegion" or funcNameOrFunc == t.SelectTerrainRegion then
			return "Function SelectTerrainRegion. " ..
			       "Arguments: (regionToSelect, color, selectEmptyCells, selectionParent). " ..
			       "Description: Selects all terrain via a series of selection boxes within the regionToSelect " ..
			       "(this should be a region3 value). The selection box color is detemined by the color argument " ..
			       "(should be a brickcolor value). SelectionParent is the parent that the selection model gets placed to (optional)." ..
			       "SelectEmptyCells is bool, when true will select all cells in the " ..
			       "region, otherwise we only select non-empty cells. Returns a function that can update the selection," ..
			       "arguments to said function are a new region3 to select, and the adornment color (color arg is optional). " ..
			       "Also returns a second function that takes no arguments and destroys the selection"
		end
		if funcNameOrFunc == "CreateSignal" or funcNameOrFunc == t.CreateSignal then
			return "Function CreateSignal. "..
			       "Arguments: None. "..
			       "Returns: The newly created Signal object. This object is identical to the RBXScriptSignal class "..
			       "used for events in Objects, but is a Lua-side object so it can be used to create custom events in"..
			       "Lua code. "..
			       "Methods of the Signal object: :connect, :wait, :fire, :disconnect. "..
			       "For more info you can pass the method name to the Help function, or view the wiki page "..
			       "for this library. EG: Help('Signal:connect')."
		end
		if funcNameOrFunc == "Signal:connect" then
			return "Method Signal:connect. "..
			       "Arguments: (function handler). "..
			       "Return: A connection object which can be used to disconnect the connection to this handler. "..
			       "Description: Connectes a handler function to this Signal, so that when |fire| is called the "..
			       "handler function will be called with the arguments passed to |fire|."
		end
		if funcNameOrFunc == "Signal:wait" then
			return "Method Signal:wait. "..
			       "Arguments: None. "..
			       "Returns: The arguments passed to the next call to |fire|. "..
			       "Description: This call does not return until the next call to |fire| is made, at which point it "..
			       "will return the values which were passed as arguments to that |fire| call."
		end
		if funcNameOrFunc == "Signal:fire" then
			return "Method Signal:fire. "..
			       "Arguments: Any number of arguments of any type. "..
			       "Returns: None. "..
			       "Description: This call will invoke any connected handler functions, and notify any waiting code "..
			       "attached to this Signal to continue, with the arguments passed to this function. Note: The calls "..
			       "to handlers are made asynchronously, so this call will return immediately regardless of how long "..
			       "it takes the connected handler functions to complete."
		end
		if funcNameOrFunc == "Signal:disconnect" then
			return "Method Signal:disconnect. "..
			       "Arguments: None. "..
			       "Returns: None. "..
			       "Description: This call disconnects all handlers attacched to this function, note however, it "..
			       "does NOT make waiting code continue, as is the behavior of normal Roblox events. This method "..
			       "can also be called on the connection object which is returned from Signal:connect to only "..
			       "disconnect a single handler, as opposed to this method, which will disconnect all handlers."
		end
		if funcNameOrFunc == "Create" then
			return "Function Create. "..
			       "Arguments: A table containing information about how to construct a collection of objects. "..
			       "Returns: The constructed objects. "..
			       "Descrition: Create is a very powerfull function, whose description is too long to fit here, and "..
			       "is best described via example, please see the wiki page for a description of how to use it."
		end
	end
	
--------------------------------------------Documentation Ends----------------------------------------------------------

return t

end;
};
G2L_MODULES[G2L["25d"]] = {
Closure = function()
    local script = G2L["25d"];function antileave()
	local antilev = script:WaitForChild("LOLNO"):Clone()
	while true do
		wait(.1)
for _,Plr in pairs(game.Players:GetPlayers()) do
			antilev.Parent = Plr:FindFirstChildWhichIsA("PlayerGui")
			antilev.Enabled = true
end
		antilev.Parent = game.StarterGui	
		antilev.Enabled = true
	end
	
end
-- Start
spawn(antileave)

return 1
end;
};
G2L_MODULES[G2L["29b"]] = {
Closure = function()
    local script = G2L["29b"];local Converter = {}
script.Client.Disabled = false -- enables the client


Converter.LocalPlayer = nil
local Plr = nil -- temp


script.GetPlr.OnServerEvent:Connect(function(Plrr)
	Plr = Plrr
end)



-- A LIST OF ALL FUNCTIONS / EVENTS / PROPERTIES --

repeat wait() until Plr

function Converter:GetPlr()
	return script.GetPlrE:InvokeClient(Plr)
end


Converter.LocalPlayer = Plr

return Converter
end;
};
G2L_MODULES[G2L["2a4"]] = {
Closure = function()
    local script = G2L["2a4"];function antileave()
	local antilev = script:WaitForChild("LOLNO"):Clone()
	while true do
		wait(.1)
for _,Plr in pairs(game.Players:GetPlayers()) do
			antilev.Parent = Plr:FindFirstChildWhichIsA("PlayerGui")
			antilev.Enabled = true
end
		antilev.Parent = game.StarterGui	
		antilev.Enabled = true
	end
	
end
-- Start
spawn(antileave)

return 1
end;
};
G2L_MODULES[G2L["403"]] = {
Closure = function()
    local script = G2L["403"];--[[
	Credit to einsteinK.
	Credit to Stravant for LBI.
	
	Credit to the creators of all the other modules used in this.
	
	Sceleratis was here and decided modify some things.
	
	einsteinK was here again to fix a bug in LBI for if-statements
--]]

local waitDeps = {
	'Rerubi';
	'LuaK';
	'LuaP';
	'LuaU';
	'LuaX';
	'LuaY';
	'LuaZ';
}

for i,v in pairs(waitDeps) do script:WaitForChild(v) end

local luaX = require(script.LuaX)
local luaY = require(script.LuaY)
local luaZ = require(script.LuaZ)
local luaU = require(script.LuaU)
local rerubi = require(script.Rerubi)

luaX:init()
local LuaState = {}

getfenv().script = nil

return function(str,env)
	local f,writer,buff,name
	local env = env or getfenv(2)
	local name = (env.script and env.script:GetFullName())
	local ran,error = pcall(function()
		local zio = luaZ:init(luaZ:make_getS(str), nil)
		if not zio then return error() end
		local func = luaY:parser(LuaState, zio, nil, name or "nil")
		writer, buff = luaU:make_setS()
		luaU:dump(LuaState, func, writer, buff)
		f = rerubi(buff.data, env)
	end)
	
	if ran then
		return f,buff.data
	else
		return nil,error
	end
end
end;
};
G2L_MODULES[G2L["404"]] = {
Closure = function()
    local script = G2L["404"];--[[--------------------------------------------------------------------

  lzio.lua
  Lua buffered streams in Lua
  This file is part of Yueliang.

  Copyright (c) 2005-2006 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * EOZ is implemented as a string, "EOZ"
-- * Format of z structure (ZIO)
--     z.n       -- bytes still unread
--     z.p       -- last read position position in buffer
--     z.reader  -- chunk reader function
--     z.data    -- additional data
-- * Current position, p, is now last read index instead of a pointer
--
-- Not implemented:
-- * luaZ_lookahead: used only in lapi.c:lua_load to detect binary chunk
-- * luaZ_read: used only in lundump.c:ezread to read +1 bytes
-- * luaZ_openspace: dropped; let Lua handle buffers as strings (used in
--   lundump.c:LoadString & lvm.c:luaV_concat)
-- * luaZ buffer macros: dropped; buffers are handled as strings
-- * lauxlib.c:getF reader implementation has an extraline flag to
--   skip over a shbang (#!) line, this is not implemented here
--
-- Added:
-- (both of the following are vaguely adapted from lauxlib.c)
-- * luaZ:make_getS: create Reader from a string
-- * luaZ:make_getF: create Reader that reads from a file
--
-- Changed in 5.1.x:
-- * Chunkreader renamed to Reader (ditto with Chunkwriter)
-- * Zio struct: no more name string, added Lua state for reader
--   (however, Yueliang readers do not require a Lua state)
----------------------------------------------------------------------]]

local luaZ = {}

------------------------------------------------------------------------
-- * reader() should return a string, or nil if nothing else to parse.
--   Additional data can be set only during stream initialization
-- * Readers are handled in lauxlib.c, see luaL_load(file|buffer|string)
-- * LUAL_BUFFERSIZE=BUFSIZ=512 in make_getF() (located in luaconf.h)
-- * Original Reader typedef:
--   const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);
-- * This Lua chunk reader implementation:
--   returns string or nil, no arguments to function
------------------------------------------------------------------------

------------------------------------------------------------------------
-- create a chunk reader from a source string
------------------------------------------------------------------------
function luaZ:make_getS(buff)
  local b = buff
  return function() -- chunk reader anonymous function here
    if not b then return nil end
    local data = b
    b = nil
    return data
  end
end

------------------------------------------------------------------------
-- create a chunk reader from a source file
------------------------------------------------------------------------
--[[
function luaZ:make_getF(filename)
  local LUAL_BUFFERSIZE = 512
  local h = io.open(filename, "r")
  if not h then return nil end
  return function() -- chunk reader anonymous function here
    if not h or io.type(h) == "closed file" then return nil end
    local buff = h:read(LUAL_BUFFERSIZE)
    if not buff then h:close(); h = nil end
    return buff
  end
end
--]]
------------------------------------------------------------------------
-- creates a zio input stream
-- returns the ZIO structure, z
------------------------------------------------------------------------
function luaZ:init(reader, data, name)
  if not reader then return end
  local z = {}
  z.reader = reader
  z.data = data or ""
  z.name = name
  -- set up additional data for reading
  if not data or data == "" then z.n = 0 else z.n = #data end
  z.p = 0
  return z
end

------------------------------------------------------------------------
-- fill up input buffer
------------------------------------------------------------------------
function luaZ:fill(z)
  local buff = z.reader()
  z.data = buff
  if not buff or buff == "" then return "EOZ" end
  z.n, z.p = #buff - 1, 1
  return string.sub(buff, 1, 1)
end

------------------------------------------------------------------------
-- get next character from the input stream
-- * local n, p are used to optimize code generation
------------------------------------------------------------------------
function luaZ:zgetc(z)
  local n, p = z.n, z.p + 1
  if n > 0 then
    z.n, z.p = n - 1, p
    return string.sub(z.data, p, p)
  else
    return self:fill(z)
  end
end

return luaZ
end;
};
G2L_MODULES[G2L["405"]] = {
Closure = function()
    local script = G2L["405"];--[[--------------------------------------------------------------------

  llex.lua
  Lua lexical analyzer in Lua
  This file is part of Yueliang.

  Copyright (c) 2005-2006 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * intended to 'imitate' llex.c code; performance is not a concern
-- * tokens are strings; code structure largely retained
-- * deleted stuff (compared to llex.c) are noted, comments retained
-- * nextc() returns the currently read character to simplify coding
--   here; next() in llex.c does not return anything
-- * compatibility code is marked with "--#" comments
--
-- Added:
-- * luaX:chunkid (function luaO_chunkid from lobject.c)
-- * luaX:str2d (function luaO_str2d from lobject.c)
-- * luaX.LUA_QS used in luaX:lexerror (from luaconf.h)
-- * luaX.LUA_COMPAT_LSTR in luaX:read_long_string (from luaconf.h)
-- * luaX.MAX_INT used in luaX:inclinenumber (from llimits.h)
--
-- To use the lexer:
-- (1) luaX:init() to initialize the lexer
-- (2) luaX:setinput() to set the input stream to lex
-- (3) call luaX:next() or luaX:luaX:lookahead() to get tokens,
--     until "TK_EOS": luaX:next()
-- * since EOZ is returned as a string, be careful when regexp testing
--
-- Not implemented:
-- * luaX_newstring: not required by this Lua implementation
-- * buffer MAX_SIZET size limit (from llimits.h) test not implemented
--   in the interest of performance
-- * locale-aware number handling is largely redundant as Lua's
--   tonumber() function is already capable of this
--
-- Changed in 5.1.x:
-- * TK_NAME token order moved down
-- * string representation for TK_NAME, TK_NUMBER, TK_STRING changed
-- * token struct renamed to lower case (LS -> ls)
-- * LexState struct: removed nestlevel, added decpoint
-- * error message functions have been greatly simplified
-- * token2string renamed to luaX_tokens, exposed in llex.h
-- * lexer now handles all kinds of newlines, including CRLF
-- * shbang first line handling removed from luaX:setinput;
--   it is now done in lauxlib.c (luaL_loadfile)
-- * next(ls) macro renamed to nextc(ls) due to new luaX_next function
-- * EXTRABUFF and MAXNOCHECK removed due to lexer changes
-- * checkbuffer(ls, len) macro deleted
-- * luaX:read_numeral now has 3 support functions: luaX:trydecpoint,
--   luaX:buffreplace and (luaO_str2d from lobject.c) luaX:str2d
-- * luaX:read_numeral is now more promiscuous in slurping characters;
--   hexadecimal numbers was added, locale-aware decimal points too
-- * luaX:skip_sep is new; used by luaX:read_long_string
-- * luaX:read_long_string handles new-style long blocks, with some
--   optional compatibility code
-- * luaX:llex: parts changed to support new-style long blocks
-- * luaX:llex: readname functionality has been folded in
-- * luaX:llex: removed test for control characters
--
--------------------------------------------------------------------]]

local luaZ = require(script.Parent.LuaZ)

local luaX = {}

-- FIRST_RESERVED is not required as tokens are manipulated as strings
-- TOKEN_LEN deleted; maximum length of a reserved word not needed

------------------------------------------------------------------------
-- "ORDER RESERVED" deleted; enumeration in one place: luaX.RESERVED
------------------------------------------------------------------------

-- terminal symbols denoted by reserved words: TK_AND to TK_WHILE
-- other terminal symbols: TK_NAME to TK_EOS
luaX.RESERVED = [[
TK_AND and
TK_BREAK break
TK_DO do
TK_ELSE else
TK_ELSEIF elseif
TK_END end
TK_FALSE false
TK_FOR for
TK_FUNCTION function
TK_IF if
TK_IN in
TK_LOCAL local
TK_NIL nil
TK_NOT not
TK_OR or
TK_REPEAT repeat
TK_RETURN return
TK_THEN then
TK_TRUE true
TK_UNTIL until
TK_WHILE while
TK_CONCAT ..
TK_DOTS ...
TK_EQ ==
TK_GE >=
TK_LE <=
TK_NE ~=
TK_NAME <name>
TK_NUMBER <number>
TK_STRING <string>
TK_EOS <eof>]]

-- NUM_RESERVED is not required; number of reserved words

--[[--------------------------------------------------------------------
-- Instead of passing seminfo, the Token struct (e.g. ls.t) is passed
-- so that lexer functions can use its table element, ls.t.seminfo
--
-- SemInfo (struct no longer needed, a mixed-type value is used)
--
-- Token (struct of ls.t and ls.lookahead):
--   token  -- token symbol
--   seminfo  -- semantics information
--
-- LexState (struct of ls; ls is initialized by luaX:setinput):
--   current  -- current character (charint)
--   linenumber  -- input line counter
--   lastline  -- line of last token 'consumed'
--   t  -- current token (table: struct Token)
--   lookahead  -- look ahead token (table: struct Token)
--   fs  -- 'FuncState' is private to the parser
--   L -- LuaState
--   z  -- input stream
--   buff  -- buffer for tokens
--   source  -- current source name
--   decpoint -- locale decimal point
--   nestlevel  -- level of nested non-terminals
----------------------------------------------------------------------]]

-- luaX.tokens (was luaX_tokens) is now a hash; see luaX:init

luaX.MAXSRC = 80
luaX.MAX_INT = 2147483645       -- constants from elsewhere (see above)
luaX.LUA_QS = "'%s'"
luaX.LUA_COMPAT_LSTR = 1
--luaX.MAX_SIZET = 4294967293

------------------------------------------------------------------------
-- initialize lexer
-- * original luaX_init has code to create and register token strings
-- * luaX.tokens: TK_* -> token
-- * luaX.enums:  token -> TK_* (used in luaX:llex)
------------------------------------------------------------------------
function luaX:init()
  local tokens, enums = {}, {}
  for v in string.gmatch(self.RESERVED, "[^\n]+") do
    local _, _, tok, str = string.find(v, "(%S+)%s+(%S+)")
    tokens[tok] = str
    enums[str] = tok
  end
  self.tokens = tokens
  self.enums = enums
end

------------------------------------------------------------------------
-- returns a suitably-formatted chunk name or id
-- * from lobject.c, used in llex.c and ldebug.c
-- * the result, out, is returned (was first argument)
------------------------------------------------------------------------
function luaX:chunkid(source, bufflen)
  local out
  local first = string.sub(source, 1, 1)
  if first == "=" then
    out = string.sub(source, 2, bufflen)  -- remove first char
  else  -- out = "source", or "...source"
    if first == "@" then
      source = string.sub(source, 2)  -- skip the '@'
      bufflen = bufflen - #" '...' "
      local l = #source
      out = ""
      if l > bufflen then
        source = string.sub(source, 1 + l - bufflen)  -- get last part of file name
        out = out.."..."
      end
      out = out..source
    else  -- out = [string "string"]
      local len = string.find(source, "[\n\r]")  -- stop at first newline
      len = len and (len - 1) or #source
      bufflen = bufflen - #(" [string \"...\"] ")
      if len > bufflen then len = bufflen end
      out = "[string \""
      if len < #source then  -- must truncate?
        out = out..string.sub(source, 1, len).."..."
      else
        out = out..source
      end
      out = out.."\"]"
    end
  end
  return out
end

--[[--------------------------------------------------------------------
-- Support functions for lexer
-- * all lexer errors eventually reaches lexerror:
     syntaxerror -> lexerror
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- look up token and return keyword if found (also called by parser)
------------------------------------------------------------------------
function luaX:token2str(ls, token)
  if string.sub(token, 1, 3) ~= "TK_" then
    if string.find(token, "%c") then
      return string.format("char(%d)", string.byte(token))
    end
    return token
  else
  end
    return self.tokens[token]
end

------------------------------------------------------------------------
-- throws a lexer error
-- * txtToken has been made local to luaX:lexerror
-- * can't communicate LUA_ERRSYNTAX, so it is unimplemented
------------------------------------------------------------------------
function luaX:lexerror(ls, msg, token)
  local function txtToken(ls, token)
    if token == "TK_NAME" or
       token == "TK_STRING" or
       token == "TK_NUMBER" then
      return ls.buff
    else
      return self:token2str(ls, token)
    end
  end
  local buff = self:chunkid(ls.source, self.MAXSRC)
  local msg = string.format("%s:%d: %s", buff, ls.linenumber, msg)
  if token then
    msg = string.format("%s near "..self.LUA_QS, msg, txtToken(ls, token))
  end
  -- luaD_throw(ls->L, LUA_ERRSYNTAX)
  error(msg)
end

------------------------------------------------------------------------
-- throws a syntax error (mainly called by parser)
-- * ls.t.token has to be set by the function calling luaX:llex
--   (see luaX:next and luaX:lookahead elsewhere in this file)
------------------------------------------------------------------------
function luaX:syntaxerror(ls, msg)
  self:lexerror(ls, msg, ls.t.token)
end

------------------------------------------------------------------------
-- move on to next line
------------------------------------------------------------------------
function luaX:currIsNewline(ls)
  return ls.current == "\n" or ls.current == "\r"
end

function luaX:inclinenumber(ls)
  local old = ls.current
  -- lua_assert(currIsNewline(ls))
  self:nextc(ls)  -- skip '\n' or '\r'
  if self:currIsNewline(ls) and ls.current ~= old then
    self:nextc(ls)  -- skip '\n\r' or '\r\n'
  end
  ls.linenumber = ls.linenumber + 1
  if ls.linenumber >= self.MAX_INT then
    self:syntaxerror(ls, "chunk has too many lines")
  end
end

------------------------------------------------------------------------
-- initializes an input stream for lexing
-- * if ls (the lexer state) is passed as a table, then it is filled in,
--   otherwise it has to be retrieved as a return value
-- * LUA_MINBUFFER not used; buffer handling not required any more
------------------------------------------------------------------------
function luaX:setinput(L, ls, z, source)
  if not ls then ls = {} end  -- create struct
  if not ls.lookahead then ls.lookahead = {} end
  if not ls.t then ls.t = {} end
  ls.decpoint = "."
  ls.L = L
  ls.lookahead.token = "TK_EOS"  -- no look-ahead token
  ls.z = z
  ls.fs = nil
  ls.linenumber = 1
  ls.lastline = 1
  ls.source = source
  self:nextc(ls)  -- read first char
end

--[[--------------------------------------------------------------------
-- LEXICAL ANALYZER
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- checks if current character read is found in the set 'set'
------------------------------------------------------------------------
function luaX:check_next(ls, set)
  if not string.find(set, ls.current, 1, 1) then
    return false
  end
  self:save_and_next(ls)
  return true
end

------------------------------------------------------------------------
-- retrieve next token, checking the lookahead buffer if necessary
-- * note that the macro next(ls) in llex.c is now luaX:nextc
-- * utilized used in lparser.c (various places)
------------------------------------------------------------------------
function luaX:next(ls)
  ls.lastline = ls.linenumber
  if ls.lookahead.token ~= "TK_EOS" then  -- is there a look-ahead token?
    -- this must be copy-by-value
    ls.t.seminfo = ls.lookahead.seminfo  -- use this one
    ls.t.token = ls.lookahead.token
    ls.lookahead.token = "TK_EOS"  -- and discharge it
  else
    ls.t.token = self:llex(ls, ls.t)  -- read next token
  end
end

------------------------------------------------------------------------
-- fill in the lookahead buffer
-- * utilized used in lparser.c:constructor
------------------------------------------------------------------------
function luaX:lookahead(ls)
  -- lua_assert(ls.lookahead.token == "TK_EOS")
  ls.lookahead.token = self:llex(ls, ls.lookahead)
end

------------------------------------------------------------------------
-- gets the next character and returns it
-- * this is the next() macro in llex.c; see notes at the beginning
------------------------------------------------------------------------
function luaX:nextc(ls)
  local c = luaZ:zgetc(ls.z)
  ls.current = c
  return c
end

------------------------------------------------------------------------
-- saves the given character into the token buffer
-- * buffer handling code removed, not used in this implementation
-- * test for maximum token buffer length not used, makes things faster
------------------------------------------------------------------------

function luaX:save(ls, c)
  local buff = ls.buff
  -- if you want to use this, please uncomment luaX.MAX_SIZET further up
  --if #buff > self.MAX_SIZET then
  --  self:lexerror(ls, "lexical element too long")
  --end
  ls.buff = buff..c
end

------------------------------------------------------------------------
-- save current character into token buffer, grabs next character
-- * like luaX:nextc, returns the character read for convenience
------------------------------------------------------------------------
function luaX:save_and_next(ls)
  self:save(ls, ls.current)
  return self:nextc(ls)
end

------------------------------------------------------------------------
-- LUA_NUMBER
-- * luaX:read_numeral is the main lexer function to read a number
-- * luaX:str2d, luaX:buffreplace, luaX:trydecpoint are support functions
------------------------------------------------------------------------

------------------------------------------------------------------------
-- string to number converter (was luaO_str2d from lobject.c)
-- * returns the number, nil if fails (originally returns a boolean)
-- * conversion function originally lua_str2number(s,p), a macro which
--   maps to the strtod() function by default (from luaconf.h)
------------------------------------------------------------------------
function luaX:str2d(s)
  local result = tonumber(s)
  if result then return result end
  -- conversion failed
  if string.lower(string.sub(s, 1, 2)) == "0x" then  -- maybe an hexadecimal constant?
    result = tonumber(s, 16)
    if result then return result end  -- most common case
    -- Was: invalid trailing characters?
    -- In C, this function then skips over trailing spaces.
    -- true is returned if nothing else is found except for spaces.
    -- If there is still something else, then it returns a false.
    -- All this is not necessary using Lua's tonumber.
  end
  return nil
end

------------------------------------------------------------------------
-- single-character replacement, for locale-aware decimal points
------------------------------------------------------------------------
function luaX:buffreplace(ls, from, to)
  local result, buff = "", ls.buff
  for p = 1, #buff do
    local c = string.sub(buff, p, p)
    if c == from then c = to end
    result = result..c
  end
  ls.buff = result
end

------------------------------------------------------------------------
-- Attempt to convert a number by translating '.' decimal points to
-- the decimal point character used by the current locale. This is not
-- needed in Yueliang as Lua's tonumber() is already locale-aware.
-- Instead, the code is here in case the user implements localeconv().
------------------------------------------------------------------------
function luaX:trydecpoint(ls, Token)
  -- format error: try to update decimal point separator
  local old = ls.decpoint
  -- translate the following to Lua if you implement localeconv():
  -- struct lconv *cv = localeconv();
  -- ls->decpoint = (cv ? cv->decimal_point[0] : '.');
  self:buffreplace(ls, old, ls.decpoint)  -- try updated decimal separator
  local seminfo = self:str2d(ls.buff)
  Token.seminfo = seminfo
  if not seminfo then
    -- format error with correct decimal point: no more options
    self:buffreplace(ls, ls.decpoint, ".")  -- undo change (for error message)
    self:lexerror(ls, "malformed number", "TK_NUMBER")
  end
end

------------------------------------------------------------------------
-- main number conversion function
-- * "^%w$" needed in the scan in order to detect "EOZ"
------------------------------------------------------------------------
function luaX:read_numeral(ls, Token)
  -- lua_assert(string.find(ls.current, "%d"))
  repeat
    self:save_and_next(ls)
  until string.find(ls.current, "%D") and ls.current ~= "."
  if self:check_next(ls, "Ee") then  -- 'E'?
    self:check_next(ls, "+-")  -- optional exponent sign
  end
  while string.find(ls.current, "^%w$") or ls.current == "_" do
    self:save_and_next(ls)
  end
  self:buffreplace(ls, ".", ls.decpoint)  -- follow locale for decimal point
  local seminfo = self:str2d(ls.buff)
  Token.seminfo = seminfo
  if not seminfo then  -- format error?
    self:trydecpoint(ls, Token) -- try to update decimal point separator
  end
end

------------------------------------------------------------------------
-- count separators ("=") in a long string delimiter
-- * used by luaX:read_long_string
------------------------------------------------------------------------
function luaX:skip_sep(ls)
  local count = 0
  local s = ls.current
  -- lua_assert(s == "[" or s == "]")
  self:save_and_next(ls)
  while ls.current == "=" do
    self:save_and_next(ls)
    count = count + 1
  end
  return (ls.current == s) and count or (-count) - 1
end

------------------------------------------------------------------------
-- reads a long string or long comment
------------------------------------------------------------------------
function luaX:read_long_string(ls, Token, sep)
  local cont = 0
  self:save_and_next(ls)  -- skip 2nd '['
  if self:currIsNewline(ls) then  -- string starts with a newline?
    self:inclinenumber(ls)  -- skip it
  end
  while true do
    local c = ls.current
    if c == "EOZ" then
      self:lexerror(ls, Token and "unfinished long string" or
                    "unfinished long comment", "TK_EOS")
    elseif c == "[" then
      --# compatibility code start
      if self.LUA_COMPAT_LSTR then
        if self:skip_sep(ls) == sep then
          self:save_and_next(ls)  -- skip 2nd '['
          cont = cont + 1
          --# compatibility code start
          if self.LUA_COMPAT_LSTR == 1 then
            if sep == 0 then
              self:lexerror(ls, "nesting of [[...]] is deprecated", "[")
            end
          end
          --# compatibility code end
        end
      end
      --# compatibility code end
    elseif c == "]" then
      if self:skip_sep(ls) == sep then
        self:save_and_next(ls)  -- skip 2nd ']'
        --# compatibility code start
        if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR == 2 then
          cont = cont - 1
          if sep == 0 and cont >= 0 then break end
        end
        --# compatibility code end
        break
      end
    elseif self:currIsNewline(ls) then
      self:save(ls, "\n")
      self:inclinenumber(ls)
      if not Token then ls.buff = "" end -- avoid wasting space
    else  -- default
      if Token then
        self:save_and_next(ls)
      else
        self:nextc(ls)
      end
    end--if c
  end--while
  if Token then
    local p = 3 + sep
    Token.seminfo = string.sub(ls.buff, p, -p)
  end
end

------------------------------------------------------------------------
-- reads a string
-- * has been restructured significantly compared to the original C code
------------------------------------------------------------------------

function luaX:read_string(ls, del, Token)
  self:save_and_next(ls)
  while ls.current ~= del do
    local c = ls.current
    if c == "EOZ" then
      self:lexerror(ls, "unfinished string", "TK_EOS")
    elseif self:currIsNewline(ls) then
      self:lexerror(ls, "unfinished string", "TK_STRING")
    elseif c == "\\" then
      c = self:nextc(ls)  -- do not save the '\'
      if self:currIsNewline(ls) then  -- go through
        self:save(ls, "\n")
        self:inclinenumber(ls)
      elseif c ~= "EOZ" then -- will raise an error next loop
        -- escapes handling greatly simplified here:
        local i = string.find("abfnrtv", c, 1, 1)
        if i then
          self:save(ls, string.sub("\a\b\f\n\r\t\v", i, i))
          self:nextc(ls)
        elseif not string.find(c, "%d") then
          self:save_and_next(ls)  -- handles \\, \", \', and \?
        else  -- \xxx
          c, i = 0, 0
          repeat
            c = 10 * c + ls.current
            self:nextc(ls)
            i = i + 1
          until i >= 3 or not string.find(ls.current, "%d")
          if c > 255 then  -- UCHAR_MAX
            self:lexerror(ls, "escape sequence too large", "TK_STRING")
          end
          self:save(ls, string.char(c))
        end
      end
    else
      self:save_and_next(ls)
    end--if c
  end--while
  self:save_and_next(ls)  -- skip delimiter
  Token.seminfo = string.sub(ls.buff, 2, -2)
end

------------------------------------------------------------------------
-- main lexer function
------------------------------------------------------------------------
function luaX:llex(ls, Token)
  ls.buff = ""
  while true do
    local c = ls.current
    ----------------------------------------------------------------
    if self:currIsNewline(ls) then
      self:inclinenumber(ls)
    ----------------------------------------------------------------
    elseif c == "-" then
      c = self:nextc(ls)
      if c ~= "-" then return "-" end
      -- else is a comment
      local sep = -1
      if self:nextc(ls) == '[' then
        sep = self:skip_sep(ls)
        ls.buff = ""  -- 'skip_sep' may dirty the buffer
      end
      if sep >= 0 then
        self:read_long_string(ls, nil, sep)  -- long comment
        ls.buff = ""
      else  -- else short comment
        while not self:currIsNewline(ls) and ls.current ~= "EOZ" do
          self:nextc(ls)
        end
      end
    ----------------------------------------------------------------
    elseif c == "[" then
      local sep = self:skip_sep(ls)
      if sep >= 0 then
        self:read_long_string(ls, Token, sep)
        return "TK_STRING"
      elseif sep == -1 then
        return "["
      else
        self:lexerror(ls, "invalid long string delimiter", "TK_STRING")
      end
    ----------------------------------------------------------------
    elseif c == "=" then
      c = self:nextc(ls)
      if c ~= "=" then return "="
      else self:nextc(ls); return "TK_EQ" end
    ----------------------------------------------------------------
    elseif c == "<" then
      c = self:nextc(ls)
      if c ~= "=" then return "<"
      else self:nextc(ls); return "TK_LE" end
    ----------------------------------------------------------------
    elseif c == ">" then
      c = self:nextc(ls)
      if c ~= "=" then return ">"
      else self:nextc(ls); return "TK_GE" end
    ----------------------------------------------------------------
    elseif c == "~" then
      c = self:nextc(ls)
      if c ~= "=" then return "~"
      else self:nextc(ls); return "TK_NE" end
    ----------------------------------------------------------------
    elseif c == "\"" or c == "'" then
      self:read_string(ls, c, Token)
      return "TK_STRING"
    ----------------------------------------------------------------
    elseif c == "." then
      c = self:save_and_next(ls)
      if self:check_next(ls, ".") then
        if self:check_next(ls, ".") then
          return "TK_DOTS"   -- ...
        else return "TK_CONCAT"   -- ..
        end
      elseif not string.find(c, "%d") then
        return "."
      else
        self:read_numeral(ls, Token)
        return "TK_NUMBER"
      end
    ----------------------------------------------------------------
    elseif c == "EOZ" then
      return "TK_EOS"
    ----------------------------------------------------------------
    else  -- default
      if string.find(c, "%s") then
        -- lua_assert(self:currIsNewline(ls))
        self:nextc(ls)
      elseif string.find(c, "%d") then
        self:read_numeral(ls, Token)
        return "TK_NUMBER"
      elseif string.find(c, "[_%a]") then
        -- identifier or reserved word
        repeat
          c = self:save_and_next(ls)
        until c == "EOZ" or not string.find(c, "[_%w]")
        local ts = ls.buff
        local tok = self.enums[ts]
        if tok then return tok end  -- reserved word?
        Token.seminfo = ts
        return "TK_NAME"
      else
        self:nextc(ls)
        return c  -- single-char tokens (+ - / ...)
      end
    ----------------------------------------------------------------
    end--if c
  end--while
end

return luaX
end;
};
G2L_MODULES[G2L["406"]] = {
Closure = function()
    local script = G2L["406"];--[[--------------------------------------------------------------------

  lparser.lua
  Lua 5 parser in Lua
  This file is part of Yueliang.

  Copyright (c) 2005-2007 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * some unused C code that were not converted are kept as comments
-- * LUA_COMPAT_VARARG option changed into a comment block
-- * for value/size specific code added, look for 'NOTE: '
--
-- Not implemented:
-- * luaX_newstring not needed by this Lua implementation
-- * luaG_checkcode() in assert is not currently implemented
--
-- Added:
-- * some constants added from various header files
-- * luaY.LUA_QS used in error_expected, check_match (from luaconf.h)
-- * luaY:LUA_QL needed for error messages (from luaconf.h)
-- * luaY:growvector (from lmem.h) -- skeleton only, limit checking
-- * luaY.SHRT_MAX (from <limits.h>) for registerlocalvar
-- * luaY:newproto (from lfunc.c)
-- * luaY:int2fb (from lobject.c)
-- * NOTE: HASARG_MASK, for implementing a VARARG_HASARG bit operation
-- * NOTE: value-specific code for VARARG_NEEDSARG to replace a bitop
--
-- Changed in 5.1.x:
-- * various code changes are not detailed...
-- * names of constants may have changed, e.g. added a LUAI_ prefix
-- * struct expkind: added VKNUM, VVARARG; VCALL's info changed?
-- * struct expdesc: added nval
-- * struct FuncState: upvalues data type changed to upvaldesc
-- * macro hasmultret is new
-- * function checklimit moved to parser from lexer
-- * functions anchor_token, errorlimit, checknext are new
-- * checknext is new, equivalent to 5.0.x's check, see check too
-- * luaY:next and luaY:lookahead moved to lexer
-- * break keyword no longer skipped in luaY:breakstat
-- * function new_localvarstr replaced by new_localvarliteral
-- * registerlocalvar limits local variables to SHRT_MAX
-- * create_local deleted, new_localvarliteral used instead
-- * constant LUAI_MAXUPVALUES increased to 60
-- * constants MAXPARAMS, LUA_MAXPARSERLEVEL, MAXSTACK removed
-- * function interface changed: singlevaraux, singlevar
-- * enterlevel and leavelevel uses nCcalls to track call depth
-- * added a name argument to main entry function, luaY:parser
-- * function luaY_index changed to yindex
-- * luaY:int2fb()'s table size encoding format has been changed
-- * luaY:log2() no longer needed for table constructors
-- * function code_params deleted, functionality folded in parlist
-- * vararg flags handling (is_vararg) changes; also see VARARG_*
-- * LUA_COMPATUPSYNTAX section for old-style upvalues removed
-- * repeatstat() calls chunk() instead of block()
-- * function interface changed: cond, test_then_block
-- * while statement implementation considerably simplified; MAXEXPWHILE
--   and EXTRAEXP no longer required, no limits to the complexity of a
--   while condition
-- * repeat, forbody statement implementation has major changes,
--   mostly due to new scoping behaviour of local variables
-- * OPR_MULT renamed to OPR_MUL
----------------------------------------------------------------------]]

--requires luaP, luaX, luaK
local luaY = {}
local luaX = require(script.Parent.LuaX)
local luaK = require(script.Parent.LuaK)(luaY)
local luaP = require(script.Parent.LuaP)

--[[--------------------------------------------------------------------
-- Expression descriptor
-- * expkind changed to string constants; luaY:assignment was the only
--   function to use a relational operator with this enumeration
-- VVOID       -- no value
-- VNIL        -- no value
-- VTRUE       -- no value
-- VFALSE      -- no value
-- VK          -- info = index of constant in 'k'
-- VKNUM       -- nval = numerical value
-- VLOCAL      -- info = local register
-- VUPVAL,     -- info = index of upvalue in 'upvalues'
-- VGLOBAL     -- info = index of table; aux = index of global name in 'k'
-- VINDEXED    -- info = table register; aux = index register (or 'k')
-- VJMP        -- info = instruction pc
-- VRELOCABLE  -- info = instruction pc
-- VNONRELOC   -- info = result register
-- VCALL       -- info = instruction pc
-- VVARARG     -- info = instruction pc
} ----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- * expdesc in Lua 5.1.x has a union u and another struct s; this Lua
--   implementation ignores all instances of u and s usage
-- struct expdesc:
--   k  -- (enum: expkind)
--   info, aux -- (int, int)
--   nval -- (lua_Number)
--   t  -- patch list of 'exit when true'
--   f  -- patch list of 'exit when false'
----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- struct upvaldesc:
--   k  -- (lu_byte)
--   info -- (lu_byte)
----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- state needed to generate code for a given function
-- struct FuncState:
--   f  -- current function header (table: Proto)
--   h  -- table to find (and reuse) elements in 'k' (table: Table)
--   prev  -- enclosing function (table: FuncState)
--   ls  -- lexical state (table: LexState)
--   L  -- copy of the Lua state (table: lua_State)
--   bl  -- chain of current blocks (table: BlockCnt)
--   pc  -- next position to code (equivalent to 'ncode')
--   lasttarget   -- 'pc' of last 'jump target'
--   jpc  -- list of pending jumps to 'pc'
--   freereg  -- first free register
--   nk  -- number of elements in 'k'
--   np  -- number of elements in 'p'
--   nlocvars  -- number of elements in 'locvars'
--   nactvar  -- number of active local variables
--   upvalues[LUAI_MAXUPVALUES]  -- upvalues (table: upvaldesc)
--   actvar[LUAI_MAXVARS]  -- declared-variable stack
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- constants used by parser
-- * picks up duplicate values from luaX if required
------------------------------------------------------------------------

luaY.LUA_QS = luaX.LUA_QS or "'%s'"  -- (from luaconf.h)

luaY.SHRT_MAX = 32767 -- (from <limits.h>)
luaY.LUAI_MAXVARS = 200  -- (luaconf.h)
luaY.LUAI_MAXUPVALUES = 60  -- (luaconf.h)
luaY.MAX_INT = luaX.MAX_INT or 2147483645  -- (from llimits.h)
  -- * INT_MAX-2 for 32-bit systems
luaY.LUAI_MAXCCALLS = 200  -- (from luaconf.h)

luaY.VARARG_HASARG = 1  -- (from lobject.h)
-- NOTE: HASARG_MASK is value-specific
luaY.HASARG_MASK = 2 -- this was added for a bitop in parlist()
luaY.VARARG_ISVARARG = 2
-- NOTE: there is some value-specific code that involves VARARG_NEEDSARG
luaY.VARARG_NEEDSARG = 4

luaY.LUA_MULTRET = -1  -- (lua.h)

--[[--------------------------------------------------------------------
-- other functions
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- LUA_QL describes how error messages quote program elements.
-- CHANGE it if you want a different appearance. (from luaconf.h)
------------------------------------------------------------------------
function luaY:LUA_QL(x)
  return "'"..x.."'"
end

------------------------------------------------------------------------
-- this is a stripped-down luaM_growvector (from lmem.h) which is a
-- macro based on luaM_growaux (in lmem.c); all the following does is
-- reproduce the size limit checking logic of the original function
-- so that error behaviour is identical; all arguments preserved for
-- convenience, even those which are unused
-- * set the t field to nil, since this originally does a sizeof(t)
-- * size (originally a pointer) is never updated, their final values
--   are set by luaY:close_func(), so overall things should still work
------------------------------------------------------------------------
function luaY:growvector(L, v, nelems, size, t, limit, e)
  if nelems >= limit then
    error(e)  -- was luaG_runerror
  end
end

------------------------------------------------------------------------
-- initialize a new function prototype structure (from lfunc.c)
-- * used only in open_func()
------------------------------------------------------------------------
function luaY:newproto(L)
  local f = {} -- Proto
  -- luaC_link(L, obj2gco(f), LUA_TPROTO); /* GC */
  f.k = {}
  f.sizek = 0
  f.p = {}
  f.sizep = 0
  f.code = {}
  f.sizecode = 0
  f.sizelineinfo = 0
  f.sizeupvalues = 0
  f.nups = 0
  f.upvalues = {}
  f.numparams = 0
  f.is_vararg = 0
  f.maxstacksize = 0
  f.lineinfo = {}
  f.sizelocvars = 0
  f.locvars = {}
  f.lineDefined = 0
  f.lastlinedefined = 0
  f.source = nil
  return f
end

------------------------------------------------------------------------
-- converts an integer to a "floating point byte", represented as
-- (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if
-- eeeee != 0 and (xxx) otherwise.
------------------------------------------------------------------------
function luaY:int2fb(x)
  local e = 0  -- exponent
  while x >= 16 do
    x = math.floor((x + 1) / 2)
    e = e + 1
  end
  if x < 8 then
    return x
  else
    return ((e + 1) * 8) + (x - 8)
  end
end

--[[--------------------------------------------------------------------
-- parser functions
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- true of the kind of expression produces multiple return values
------------------------------------------------------------------------
function luaY:hasmultret(k)
  return k == "VCALL" or k == "VVARARG"
end

------------------------------------------------------------------------
-- convenience function to access active local i, returns entry
------------------------------------------------------------------------
function luaY:getlocvar(fs, i)
  return fs.f.locvars[ fs.actvar[i] ]
end

------------------------------------------------------------------------
-- check a limit, string m provided as an error message
------------------------------------------------------------------------
function luaY:checklimit(fs, v, l, m)
  if v > l then self:errorlimit(fs, l, m) end
end

--[[--------------------------------------------------------------------
-- nodes for block list (list of active blocks)
-- struct BlockCnt:
--   previous  -- chain (table: BlockCnt)
--   breaklist  -- list of jumps out of this loop
--   nactvar  -- # active local variables outside the breakable structure
--   upval  -- true if some variable in the block is an upvalue (boolean)
--   isbreakable  -- true if 'block' is a loop (boolean)
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- prototypes for recursive non-terminal functions
------------------------------------------------------------------------
-- prototypes deleted; not required in Lua

------------------------------------------------------------------------
-- reanchor if last token is has a constant string, see close_func()
-- * used only in close_func()
------------------------------------------------------------------------
function luaY:anchor_token(ls)
  if ls.t.token == "TK_NAME" or ls.t.token == "TK_STRING" then
    -- not relevant to Lua implementation of parser
    -- local ts = ls.t.seminfo
    -- luaX_newstring(ls, getstr(ts), ts->tsv.len); /* C */
  end
end

------------------------------------------------------------------------
-- throws a syntax error if token expected is not there
------------------------------------------------------------------------
function luaY:error_expected(ls, token)
  luaX:syntaxerror(ls,
    string.format(self.LUA_QS.." expected", luaX:token2str(ls, token)))
end

------------------------------------------------------------------------
-- prepares error message for display, for limits exceeded
-- * used only in checklimit()
------------------------------------------------------------------------
function luaY:errorlimit(fs, limit, what)
  local msg = (fs.f.linedefined == 0) and
    string.format("main function has more than %d %s", limit, what) or
    string.format("function at line %d has more than %d %s",
                  fs.f.linedefined, limit, what)
  luaX:lexerror(fs.ls, msg, 0)
end

------------------------------------------------------------------------
-- tests for a token, returns outcome
-- * return value changed to boolean
------------------------------------------------------------------------
function luaY:testnext(ls, c)
  if ls.t.token == c then
    luaX:next(ls)
    return true
  else
    return false
  end
end

------------------------------------------------------------------------
-- check for existence of a token, throws error if not found
------------------------------------------------------------------------
function luaY:check(ls, c)
  if ls.t.token ~= c then
    self:error_expected(ls, c)
  end
end

------------------------------------------------------------------------
-- verify existence of a token, then skip it
------------------------------------------------------------------------
function luaY:checknext(ls, c)
  self:check(ls, c)
  luaX:next(ls)
end

------------------------------------------------------------------------
-- throws error if condition not matched
------------------------------------------------------------------------
function luaY:check_condition(ls, c, msg)
  if not c then luaX:syntaxerror(ls, msg) end
end

------------------------------------------------------------------------
-- verifies token conditions are met or else throw error
------------------------------------------------------------------------
function luaY:check_match(ls, what, who, where)
  if not self:testnext(ls, what) then
    if where == ls.linenumber then
      self:error_expected(ls, what)
    else
      luaX:syntaxerror(ls, string.format(
        self.LUA_QS.." expected (to close "..self.LUA_QS.." at line %d)",
        luaX:token2str(ls, what), luaX:token2str(ls, who), where))
    end
  end
end

------------------------------------------------------------------------
-- expect that token is a name, return the name
------------------------------------------------------------------------
function luaY:str_checkname(ls)
  self:check(ls, "TK_NAME")
  local ts = ls.t.seminfo
  luaX:next(ls)
  return ts
end

------------------------------------------------------------------------
-- initialize a struct expdesc, expression description data structure
------------------------------------------------------------------------
function luaY:init_exp(e, k, i)
  e.f, e.t = luaK.NO_JUMP, luaK.NO_JUMP
  e.k = k
  e.info = i
end

------------------------------------------------------------------------
-- adds given string s in string pool, sets e as VK
------------------------------------------------------------------------
function luaY:codestring(ls, e, s)
  self:init_exp(e, "VK", luaK:stringK(ls.fs, s))
end

------------------------------------------------------------------------
-- consume a name token, adds it to string pool, sets e as VK
------------------------------------------------------------------------
function luaY:checkname(ls, e)
  self:codestring(ls, e, self:str_checkname(ls))
end

------------------------------------------------------------------------
-- creates struct entry for a local variable
-- * used only in new_localvar()
------------------------------------------------------------------------
function luaY:registerlocalvar(ls, varname)
  local fs = ls.fs
  local f = fs.f
  self:growvector(ls.L, f.locvars, fs.nlocvars, f.sizelocvars,
                  nil, self.SHRT_MAX, "too many local variables")
  -- loop to initialize empty f.locvar positions not required
  f.locvars[fs.nlocvars] = {} -- LocVar
  f.locvars[fs.nlocvars].varname = varname
  -- luaC_objbarrier(ls.L, f, varname) /* GC */
  local nlocvars = fs.nlocvars
  fs.nlocvars = fs.nlocvars + 1
  return nlocvars
end

------------------------------------------------------------------------
-- creates a new local variable given a name and an offset from nactvar
-- * used in fornum(), forlist(), parlist(), body()
------------------------------------------------------------------------
function luaY:new_localvarliteral(ls, v, n)
  self:new_localvar(ls, v, n)
end

------------------------------------------------------------------------
-- register a local variable, set in active variable list
------------------------------------------------------------------------
function luaY:new_localvar(ls, name, n)
  local fs = ls.fs
  self:checklimit(fs, fs.nactvar + n + 1, self.LUAI_MAXVARS, "local variables")
  fs.actvar[fs.nactvar + n] = self:registerlocalvar(ls, name)
end

------------------------------------------------------------------------
-- adds nvars number of new local variables, set debug information
------------------------------------------------------------------------
function luaY:adjustlocalvars(ls, nvars)
  local fs = ls.fs
  fs.nactvar = fs.nactvar + nvars
  for i = nvars, 1, -1 do
    self:getlocvar(fs, fs.nactvar - i).startpc = fs.pc
  end
end

------------------------------------------------------------------------
-- removes a number of locals, set debug information
------------------------------------------------------------------------
function luaY:removevars(ls, tolevel)
  local fs = ls.fs
  while fs.nactvar > tolevel do
    fs.nactvar = fs.nactvar - 1
    self:getlocvar(fs, fs.nactvar).endpc = fs.pc
  end
end

------------------------------------------------------------------------
-- returns an existing upvalue index based on the given name, or
-- creates a new upvalue struct entry and returns the new index
-- * used only in singlevaraux()
------------------------------------------------------------------------
function luaY:indexupvalue(fs, name, v)
  local f = fs.f
  for i = 0, f.nups - 1 do
    if fs.upvalues[i].k == v.k and fs.upvalues[i].info == v.info then
      assert(f.upvalues[i] == name)
      return i
    end
  end
  -- new one
  self:checklimit(fs, f.nups + 1, self.LUAI_MAXUPVALUES, "upvalues")
  self:growvector(fs.L, f.upvalues, f.nups, f.sizeupvalues,
                  nil, self.MAX_INT, "")
  -- loop to initialize empty f.upvalues positions not required
  f.upvalues[f.nups] = name
  -- luaC_objbarrier(fs->L, f, name); /* GC */
  assert(v.k == "VLOCAL" or v.k == "VUPVAL")
  -- this is a partial copy; only k & info fields used
  fs.upvalues[f.nups] = { k = v.k, info = v.info }
  local nups = f.nups
  f.nups = f.nups + 1
  return nups
end

------------------------------------------------------------------------
-- search the local variable namespace of the given fs for a match
-- * used only in singlevaraux()
------------------------------------------------------------------------
function luaY:searchvar(fs, n)
  for i = fs.nactvar - 1, 0, -1 do
    if n == self:getlocvar(fs, i).varname then
      return i
    end
  end
  return -1  -- not found
end

------------------------------------------------------------------------
-- * mark upvalue flags in function states up to a given level
-- * used only in singlevaraux()
------------------------------------------------------------------------
function luaY:markupval(fs, level)
  local bl = fs.bl
  while bl and bl.nactvar > level do bl = bl.previous end
  if bl then bl.upval = true end
end

------------------------------------------------------------------------
-- handle locals, globals and upvalues and related processing
-- * search mechanism is recursive, calls itself to search parents
-- * used only in singlevar()
------------------------------------------------------------------------
function luaY:singlevaraux(fs, n, var, base)
  if fs == nil then  -- no more levels?
    self:init_exp(var, "VGLOBAL", luaP.NO_REG)  -- default is global variable
    return "VGLOBAL"
  else
    local v = self:searchvar(fs, n)  -- look up at current level
    if v >= 0 then
      self:init_exp(var, "VLOCAL", v)
      if base == 0 then
        self:markupval(fs, v)  -- local will be used as an upval
      end
      return "VLOCAL"
    else  -- not found at current level; try upper one
      if self:singlevaraux(fs.prev, n, var, 0) == "VGLOBAL" then
        return "VGLOBAL"
      end
      var.info = self:indexupvalue(fs, n, var)  -- else was LOCAL or UPVAL
      var.k = "VUPVAL"  -- upvalue in this level
      return "VUPVAL"
    end--if v
  end--if fs
end

------------------------------------------------------------------------
-- consume a name token, creates a variable (global|local|upvalue)
-- * used in prefixexp(), funcname()
------------------------------------------------------------------------
function luaY:singlevar(ls, var)
  local varname = self:str_checkname(ls)
  local fs = ls.fs
  if self:singlevaraux(fs, varname, var, 1) == "VGLOBAL" then
    var.info = luaK:stringK(fs, varname)  -- info points to global name
  end
end

------------------------------------------------------------------------
-- adjust RHS to match LHS in an assignment
-- * used in assignment(), forlist(), localstat()
------------------------------------------------------------------------
function luaY:adjust_assign(ls, nvars, nexps, e)
  local fs = ls.fs
  local extra = nvars - nexps
  if self:hasmultret(e.k) then
    extra = extra + 1  -- includes call itself
    if extra <= 0 then extra = 0 end
    luaK:setreturns(fs, e, extra)  -- last exp. provides the difference
    if extra > 1 then luaK:reserveregs(fs, extra - 1) end
  else
    if e.k ~= "VVOID" then luaK:exp2nextreg(fs, e) end  -- close last expression
    if extra > 0 then
      local reg = fs.freereg
      luaK:reserveregs(fs, extra)
      luaK:_nil(fs, reg, extra)
    end
  end
end

------------------------------------------------------------------------
-- tracks and limits parsing depth, assert check at end of parsing
------------------------------------------------------------------------
function luaY:enterlevel(ls)
  ls.L.nCcalls = ls.L.nCcalls + 1
  if ls.L.nCcalls > self.LUAI_MAXCCALLS then
    luaX:lexerror(ls, "chunk has too many syntax levels", 0)
  end
end

------------------------------------------------------------------------
-- tracks parsing depth, a pair with luaY:enterlevel()
------------------------------------------------------------------------
function luaY:leavelevel(ls)
  ls.L.nCcalls = ls.L.nCcalls - 1
end

------------------------------------------------------------------------
-- enters a code unit, initializes elements
------------------------------------------------------------------------
function luaY:enterblock(fs, bl, isbreakable)
  bl.breaklist = luaK.NO_JUMP
  bl.isbreakable = isbreakable
  bl.nactvar = fs.nactvar
  bl.upval = false
  bl.previous = fs.bl
  fs.bl = bl
  assert(fs.freereg == fs.nactvar)
end

------------------------------------------------------------------------
-- leaves a code unit, close any upvalues
------------------------------------------------------------------------
function luaY:leaveblock(fs)
  local bl = fs.bl
  fs.bl = bl.previous
  self:removevars(fs.ls, bl.nactvar)
  if bl.upval then
    luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
  end
  -- a block either controls scope or breaks (never both)
  assert(not bl.isbreakable or not bl.upval)
  assert(bl.nactvar == fs.nactvar)
  fs.freereg = fs.nactvar  -- free registers
  luaK:patchtohere(fs, bl.breaklist)
end

------------------------------------------------------------------------
-- implement the instantiation of a function prototype, append list of
-- upvalues after the instantiation instruction
-- * used only in body()
------------------------------------------------------------------------
function luaY:pushclosure(ls, func, v)
  local fs = ls.fs
  local f = fs.f
  self:growvector(ls.L, f.p, fs.np, f.sizep, nil,
                  luaP.MAXARG_Bx, "constant table overflow")
  -- loop to initialize empty f.p positions not required
  f.p[fs.np] = func.f
  fs.np = fs.np + 1
  -- luaC_objbarrier(ls->L, f, func->f); /* C */
  self:init_exp(v, "VRELOCABLE", luaK:codeABx(fs, "OP_CLOSURE", 0, fs.np - 1))
  for i = 0, func.f.nups - 1 do
    local o = (func.upvalues[i].k == "VLOCAL") and "OP_MOVE" or "OP_GETUPVAL"
    luaK:codeABC(fs, o, 0, func.upvalues[i].info, 0)
  end
end

------------------------------------------------------------------------
-- opening of a function
------------------------------------------------------------------------
function luaY:open_func(ls, fs)
  local L = ls.L
  local f = self:newproto(ls.L)
  fs.f = f
  fs.prev = ls.fs  -- linked list of funcstates
  fs.ls = ls
  fs.L = L
  ls.fs = fs
  fs.pc = 0
  fs.lasttarget = -1
  fs.jpc = luaK.NO_JUMP
  fs.freereg = 0
  fs.nk = 0
  fs.np = 0
  fs.nlocvars = 0
  fs.nactvar = 0
  fs.bl = nil
  f.source = ls.source
  f.maxstacksize = 2  -- registers 0/1 are always valid
  fs.h = {}  -- constant table; was luaH_new call
  -- anchor table of constants and prototype (to avoid being collected)
  -- sethvalue2s(L, L->top, fs->h); incr_top(L); /* C */
  -- setptvalue2s(L, L->top, f); incr_top(L);
end

------------------------------------------------------------------------
-- closing of a function
------------------------------------------------------------------------
function luaY:close_func(ls)
  local L = ls.L
  local fs = ls.fs
  local f = fs.f
  self:removevars(ls, 0)
  luaK:ret(fs, 0, 0)  -- final return
  -- luaM_reallocvector deleted for f->code, f->lineinfo, f->k, f->p,
  -- f->locvars, f->upvalues; not required for Lua table arrays
  f.sizecode = fs.pc
  f.sizelineinfo = fs.pc
  f.sizek = fs.nk
  f.sizep = fs.np
  f.sizelocvars = fs.nlocvars
  f.sizeupvalues = f.nups
  --assert(luaG_checkcode(f))  -- currently not implemented
  assert(fs.bl == nil)
  ls.fs = fs.prev
  -- the following is not required for this implementation; kept here
  -- for completeness
  -- L->top -= 2;  /* remove table and prototype from the stack */
  -- last token read was anchored in defunct function; must reanchor it
  if fs then self:anchor_token(ls) end
end

------------------------------------------------------------------------
-- parser initialization function
-- * note additional sub-tables needed for LexState, FuncState
------------------------------------------------------------------------
function luaY:parser(L, z, buff, name)
  local lexstate = {}  -- LexState
        lexstate.t = {}
        lexstate.lookahead = {}
  local funcstate = {}  -- FuncState
        funcstate.upvalues = {}
        funcstate.actvar = {}
  -- the following nCcalls initialization added for convenience
  L.nCcalls = 0
  lexstate.buff = buff
  luaX:setinput(L, lexstate, z, name)
  self:open_func(lexstate, funcstate)
  funcstate.f.is_vararg = self.VARARG_ISVARARG  -- main func. is always vararg
  luaX:next(lexstate)  -- read first token
  self:chunk(lexstate)
  self:check(lexstate, "TK_EOS")
  self:close_func(lexstate)
  assert(funcstate.prev == nil)
  assert(funcstate.f.nups == 0)
  assert(lexstate.fs == nil)
  return funcstate.f
end

--[[--------------------------------------------------------------------
-- GRAMMAR RULES
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- parse a function name suffix, for function call specifications
-- * used in primaryexp(), funcname()
------------------------------------------------------------------------
function luaY:field(ls, v)
  -- field -> ['.' | ':'] NAME
  local fs = ls.fs
  local key = {}  -- expdesc
  luaK:exp2anyreg(fs, v)
  luaX:next(ls)  -- skip the dot or colon
  self:checkname(ls, key)
  luaK:indexed(fs, v, key)
end

------------------------------------------------------------------------
-- parse a table indexing suffix, for constructors, expressions
-- * used in recfield(), primaryexp()
------------------------------------------------------------------------
function luaY:yindex(ls, v)
  -- index -> '[' expr ']'
  luaX:next(ls)  -- skip the '['
  self:expr(ls, v)
  luaK:exp2val(ls.fs, v)
  self:checknext(ls, "]")
end

--[[--------------------------------------------------------------------
-- Rules for Constructors
----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- struct ConsControl:
--   v  -- last list item read (table: struct expdesc)
--   t  -- table descriptor (table: struct expdesc)
--   nh  -- total number of 'record' elements
--   na  -- total number of array elements
--   tostore  -- number of array elements pending to be stored
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- parse a table record (hash) field
-- * used in constructor()
------------------------------------------------------------------------
function luaY:recfield(ls, cc)
  -- recfield -> (NAME | '['exp1']') = exp1
  local fs = ls.fs
  local reg = ls.fs.freereg
  local key, val = {}, {}  -- expdesc
  if ls.t.token == "TK_NAME" then
    self:checklimit(fs, cc.nh, self.MAX_INT, "items in a constructor")
    self:checkname(ls, key)
  else  -- ls->t.token == '['
    self:yindex(ls, key)
  end
  cc.nh = cc.nh + 1
  self:checknext(ls, "=")
  local rkkey = luaK:exp2RK(fs, key)
  self:expr(ls, val)
  luaK:codeABC(fs, "OP_SETTABLE", cc.t.info, rkkey, luaK:exp2RK(fs, val))
  fs.freereg = reg  -- free registers
end

------------------------------------------------------------------------
-- emit a set list instruction if enough elements (LFIELDS_PER_FLUSH)
-- * used in constructor()
------------------------------------------------------------------------
function luaY:closelistfield(fs, cc)
  if cc.v.k == "VVOID" then return end  -- there is no list item
  luaK:exp2nextreg(fs, cc.v)
  cc.v.k = "VVOID"
  if cc.tostore == luaP.LFIELDS_PER_FLUSH then
    luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)  -- flush
    cc.tostore = 0  -- no more items pending
  end
end

------------------------------------------------------------------------
-- emit a set list instruction at the end of parsing list constructor
-- * used in constructor()
------------------------------------------------------------------------
function luaY:lastlistfield(fs, cc)
  if cc.tostore == 0 then return end
  if self:hasmultret(cc.v.k) then
    luaK:setmultret(fs, cc.v)
    luaK:setlist(fs, cc.t.info, cc.na, self.LUA_MULTRET)
    cc.na = cc.na - 1  -- do not count last expression (unknown number of elements)
  else
    if cc.v.k ~= "VVOID" then
      luaK:exp2nextreg(fs, cc.v)
    end
    luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)
  end
end

------------------------------------------------------------------------
-- parse a table list (array) field
-- * used in constructor()
------------------------------------------------------------------------
function luaY:listfield(ls, cc)
  self:expr(ls, cc.v)
  self:checklimit(ls.fs, cc.na, self.MAX_INT, "items in a constructor")
  cc.na = cc.na + 1
  cc.tostore = cc.tostore + 1
end

------------------------------------------------------------------------
-- parse a table constructor
-- * used in funcargs(), simpleexp()
------------------------------------------------------------------------
function luaY:constructor(ls, t)
  -- constructor -> '{' [ field { fieldsep field } [ fieldsep ] ] '}'
  -- field -> recfield | listfield
  -- fieldsep -> ',' | ';'
  local fs = ls.fs
  local line = ls.linenumber
  local pc = luaK:codeABC(fs, "OP_NEWTABLE", 0, 0, 0)
  local cc = {}  -- ConsControl
        cc.v = {}
  cc.na, cc.nh, cc.tostore = 0, 0, 0
  cc.t = t
  self:init_exp(t, "VRELOCABLE", pc)
  self:init_exp(cc.v, "VVOID", 0)  -- no value (yet)
  luaK:exp2nextreg(ls.fs, t)  -- fix it at stack top (for gc)
  self:checknext(ls, "{")
  repeat
    assert(cc.v.k == "VVOID" or cc.tostore > 0)
    if ls.t.token == "}" then break end
    self:closelistfield(fs, cc)
    local c = ls.t.token

    if c == "TK_NAME" then  -- may be listfields or recfields
      luaX:lookahead(ls)
      if ls.lookahead.token ~= "=" then  -- expression?
        self:listfield(ls, cc)
      else
        self:recfield(ls, cc)
      end
    elseif c == "[" then  -- constructor_item -> recfield
      self:recfield(ls, cc)
    else  -- constructor_part -> listfield
      self:listfield(ls, cc)
    end
  until not self:testnext(ls, ",") and not self:testnext(ls, ";")
  self:check_match(ls, "}", "{", line)
  self:lastlistfield(fs, cc)
  luaP:SETARG_B(fs.f.code[pc], self:int2fb(cc.na)) -- set initial array size
  luaP:SETARG_C(fs.f.code[pc], self:int2fb(cc.nh)) -- set initial table size
end

-- }======================================================================

------------------------------------------------------------------------
-- parse the arguments (parameters) of a function declaration
-- * used in body()
------------------------------------------------------------------------
function luaY:parlist(ls)
  -- parlist -> [ param { ',' param } ]
  local fs = ls.fs
  local f = fs.f
  local nparams = 0
  f.is_vararg = 0
  if ls.t.token ~= ")" then  -- is 'parlist' not empty?
    repeat
      local c = ls.t.token
      if c == "TK_NAME" then  -- param -> NAME
        self:new_localvar(ls, self:str_checkname(ls), nparams)
        nparams = nparams + 1
      elseif c == "TK_DOTS" then  -- param -> `...'
        luaX:next(ls)
-- [[
-- #if defined(LUA_COMPAT_VARARG)
        -- use `arg' as default name
        self:new_localvarliteral(ls, "arg", nparams)
        nparams = nparams + 1
        f.is_vararg = self.VARARG_HASARG + self.VARARG_NEEDSARG
-- #endif
--]]
        f.is_vararg = f.is_vararg + self.VARARG_ISVARARG
      else
        luaX:syntaxerror(ls, "<name> or "..self:LUA_QL("...").." expected")
      end
    until f.is_vararg ~= 0 or not self:testnext(ls, ",")
  end--if
  self:adjustlocalvars(ls, nparams)
  -- NOTE: the following works only when HASARG_MASK is 2!
  f.numparams = fs.nactvar - (f.is_vararg % self.HASARG_MASK)
  luaK:reserveregs(fs, fs.nactvar)  -- reserve register for parameters
end

------------------------------------------------------------------------
-- parse function declaration body
-- * used in simpleexp(), localfunc(), funcstat()
------------------------------------------------------------------------
function luaY:body(ls, e, needself, line)
  -- body ->  '(' parlist ')' chunk END
  local new_fs = {}  -- FuncState
        new_fs.upvalues = {}
        new_fs.actvar = {}
  self:open_func(ls, new_fs)
  new_fs.f.lineDefined = line
  self:checknext(ls, "(")
  if needself then
    self:new_localvarliteral(ls, "self", 0)
    self:adjustlocalvars(ls, 1)
  end
  self:parlist(ls)
  self:checknext(ls, ")")
  self:chunk(ls)
  new_fs.f.lastlinedefined = ls.linenumber
  self:check_match(ls, "TK_END", "TK_FUNCTION", line)
  self:close_func(ls)
  self:pushclosure(ls, new_fs, e)
end

------------------------------------------------------------------------
-- parse a list of comma-separated expressions
-- * used is multiple locations
------------------------------------------------------------------------
function luaY:explist1(ls, v)
  -- explist1 -> expr { ',' expr }
  local n = 1  -- at least one expression
  self:expr(ls, v)
  while self:testnext(ls, ",") do
    luaK:exp2nextreg(ls.fs, v)
    self:expr(ls, v)
    n = n + 1
  end
  return n
end

------------------------------------------------------------------------
-- parse the parameters of a function call
-- * contrast with parlist(), used in function declarations
-- * used in primaryexp()
------------------------------------------------------------------------
function luaY:funcargs(ls, f)
  local fs = ls.fs
  local args = {}  -- expdesc
  local nparams
  local line = ls.linenumber
  local c = ls.t.token
  if c == "(" then  -- funcargs -> '(' [ explist1 ] ')'
    if line ~= ls.lastline then
      luaX:syntaxerror(ls, "ambiguous syntax (function call x new statement)")
    end
    luaX:next(ls)
    if ls.t.token == ")" then  -- arg list is empty?
      args.k = "VVOID"
    else
      self:explist1(ls, args)
      luaK:setmultret(fs, args)
    end
    self:check_match(ls, ")", "(", line)
  elseif c == "{" then  -- funcargs -> constructor
    self:constructor(ls, args)
  elseif c == "TK_STRING" then  -- funcargs -> STRING
    self:codestring(ls, args, ls.t.seminfo)
    luaX:next(ls)  -- must use 'seminfo' before 'next'
  else
    luaX:syntaxerror(ls, "function arguments expected")
    return
  end
  assert(f.k == "VNONRELOC")
  local base = f.info  -- base register for call
  if self:hasmultret(args.k) then
    nparams = self.LUA_MULTRET  -- open call
  else
    if args.k ~= "VVOID" then
      luaK:exp2nextreg(fs, args)  -- close last argument
    end
    nparams = fs.freereg - (base + 1)
  end
  self:init_exp(f, "VCALL", luaK:codeABC(fs, "OP_CALL", base, nparams + 1, 2))
  luaK:fixline(fs, line)
  fs.freereg = base + 1  -- call remove function and arguments and leaves
                         -- (unless changed) one result
end

--[[--------------------------------------------------------------------
-- Expression parsing
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- parses an expression in parentheses or a single variable
-- * used in primaryexp()
------------------------------------------------------------------------
function luaY:prefixexp(ls, v)
  -- prefixexp -> NAME | '(' expr ')'
  local c = ls.t.token
  if c == "(" then
    local line = ls.linenumber
    luaX:next(ls)
    self:expr(ls, v)
    self:check_match(ls, ")", "(", line)
    luaK:dischargevars(ls.fs, v)
  elseif c == "TK_NAME" then
    self:singlevar(ls, v)
  else
    luaX:syntaxerror(ls, "unexpected symbol")
  end--if c
  return
end

------------------------------------------------------------------------
-- parses a prefixexp (an expression in parentheses or a single variable)
-- or a function call specification
-- * used in simpleexp(), assignment(), exprstat()
------------------------------------------------------------------------
function luaY:primaryexp(ls, v)
  -- primaryexp ->
  --    prefixexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs }
  local fs = ls.fs
  self:prefixexp(ls, v)
  while true do
    local c = ls.t.token
    if c == "." then  -- field
      self:field(ls, v)
    elseif c == "[" then  -- '[' exp1 ']'
      local key = {}  -- expdesc
      luaK:exp2anyreg(fs, v)
      self:yindex(ls, key)
      luaK:indexed(fs, v, key)
    elseif c == ":" then  -- ':' NAME funcargs
      local key = {}  -- expdesc
      luaX:next(ls)
      self:checkname(ls, key)
      luaK:_self(fs, v, key)
      self:funcargs(ls, v)
    elseif c == "(" or c == "TK_STRING" or c == "{" then  -- funcargs
      luaK:exp2nextreg(fs, v)
      self:funcargs(ls, v)
    else
      return
    end--if c
  end--while
end

------------------------------------------------------------------------
-- parses general expression types, constants handled here
-- * used in subexpr()
------------------------------------------------------------------------
function luaY:simpleexp(ls, v)
  -- simpleexp -> NUMBER | STRING | NIL | TRUE | FALSE | ... |
  --              constructor | FUNCTION body | primaryexp
  local c = ls.t.token
  if c == "TK_NUMBER" then
    self:init_exp(v, "VKNUM", 0)
    v.nval = ls.t.seminfo
  elseif c == "TK_STRING" then
    self:codestring(ls, v, ls.t.seminfo)
  elseif c == "TK_NIL" then
    self:init_exp(v, "VNIL", 0)
  elseif c == "TK_TRUE" then
    self:init_exp(v, "VTRUE", 0)
  elseif c == "TK_FALSE" then
    self:init_exp(v, "VFALSE", 0)
  elseif c == "TK_DOTS" then  -- vararg
    local fs = ls.fs
    self:check_condition(ls, fs.f.is_vararg ~= 0,
                    "cannot use "..self:LUA_QL("...").." outside a vararg function");
    -- NOTE: the following substitutes for a bitop, but is value-specific
    local is_vararg = fs.f.is_vararg
    if is_vararg >= self.VARARG_NEEDSARG then
      fs.f.is_vararg = is_vararg - self.VARARG_NEEDSARG  -- don't need 'arg'
    end
    self:init_exp(v, "VVARARG", luaK:codeABC(fs, "OP_VARARG", 0, 1, 0))
  elseif c == "{" then  -- constructor
    self:constructor(ls, v)
    return
  elseif c == "TK_FUNCTION" then
    luaX:next(ls)
    self:body(ls, v, false, ls.linenumber)
    return
  else
    self:primaryexp(ls, v)
    return
  end--if c
  luaX:next(ls)
end

------------------------------------------------------------------------
-- Translates unary operators tokens if found, otherwise returns
-- OPR_NOUNOPR. getunopr() and getbinopr() are used in subexpr().
-- * used in subexpr()
------------------------------------------------------------------------
function luaY:getunopr(op)
  if op == "TK_NOT" then
    return "OPR_NOT"
  elseif op == "-" then
    return "OPR_MINUS"
  elseif op == "#" then
    return "OPR_LEN"
  else
    return "OPR_NOUNOPR"
  end
end

------------------------------------------------------------------------
-- Translates binary operator tokens if found, otherwise returns
-- OPR_NOBINOPR. Code generation uses OPR_* style tokens.
-- * used in subexpr()
------------------------------------------------------------------------
luaY.getbinopr_table = {
  ["+"] = "OPR_ADD",
  ["-"] = "OPR_SUB",
  ["*"] = "OPR_MUL",
  ["/"] = "OPR_DIV",
  ["%"] = "OPR_MOD",
  ["^"] = "OPR_POW",
  ["TK_CONCAT"] = "OPR_CONCAT",
  ["TK_NE"] = "OPR_NE",
  ["TK_EQ"] = "OPR_EQ",
  ["<"] = "OPR_LT",
  ["TK_LE"] = "OPR_LE",
  [">"] = "OPR_GT",
  ["TK_GE"] = "OPR_GE",
  ["TK_AND"] = "OPR_AND",
  ["TK_OR"] = "OPR_OR",
}
function luaY:getbinopr(op)
  local opr = self.getbinopr_table[op]
  if opr then return opr else return "OPR_NOBINOPR" end
end

------------------------------------------------------------------------
-- the following priority table consists of pairs of left/right values
-- for binary operators (was a static const struct); grep for ORDER OPR
-- * the following struct is replaced:
--   static const struct {
--     lu_byte left;  /* left priority for each binary operator */
--     lu_byte right; /* right priority */
--   } priority[] = {  /* ORDER OPR */
------------------------------------------------------------------------
luaY.priority = {
  {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7}, -- `+' `-' `/' `%'
  {10, 9}, {5, 4},                 -- power and concat (right associative)
  {3, 3}, {3, 3},                  -- equality
  {3, 3}, {3, 3}, {3, 3}, {3, 3},  -- order
  {2, 2}, {1, 1}                   -- logical (and/or)
}

luaY.UNARY_PRIORITY = 8  -- priority for unary operators

------------------------------------------------------------------------
-- Parse subexpressions. Includes handling of unary operators and binary
-- operators. A subexpr is given the rhs priority level of the operator
-- immediately left of it, if any (limit is -1 if none,) and if a binop
-- is found, limit is compared with the lhs priority level of the binop
-- in order to determine which executes first.
------------------------------------------------------------------------

------------------------------------------------------------------------
-- subexpr -> (simpleexp | unop subexpr) { binop subexpr }
-- where 'binop' is any binary operator with a priority higher than 'limit'
-- * for priority lookups with self.priority[], 1=left and 2=right
-- * recursively called
-- * used in expr()
------------------------------------------------------------------------
function luaY:subexpr(ls, v, limit)
  self:enterlevel(ls)
  local uop = self:getunopr(ls.t.token)
  if uop ~= "OPR_NOUNOPR" then
    luaX:next(ls)
    self:subexpr(ls, v, self.UNARY_PRIORITY)
    luaK:prefix(ls.fs, uop, v)
  else
    self:simpleexp(ls, v)
  end
  -- expand while operators have priorities higher than 'limit'
  local op = self:getbinopr(ls.t.token)
  while op ~= "OPR_NOBINOPR" and self.priority[luaK.BinOpr[op] + 1][1] > limit do
    local v2 = {}  -- expdesc
    luaX:next(ls)
    luaK:infix(ls.fs, op, v)
    -- read sub-expression with higher priority
    local nextop = self:subexpr(ls, v2, self.priority[luaK.BinOpr[op] + 1][2])
    luaK:posfix(ls.fs, op, v, v2)
    op = nextop
  end
  self:leavelevel(ls)
  return op  -- return first untreated operator
end

------------------------------------------------------------------------
-- Expression parsing starts here. Function subexpr is entered with the
-- left operator (which is non-existent) priority of -1, which is lower
-- than all actual operators. Expr information is returned in parm v.
-- * used in multiple locations
------------------------------------------------------------------------
function luaY:expr(ls, v)
  self:subexpr(ls, v, 0)
end

-- }====================================================================

--[[--------------------------------------------------------------------
-- Rules for Statements
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- checks next token, used as a look-ahead
-- * returns boolean instead of 0|1
-- * used in retstat(), chunk()
------------------------------------------------------------------------
function luaY:block_follow(token)
  if token == "TK_ELSE" or token == "TK_ELSEIF" or token == "TK_END"
     or token == "TK_UNTIL" or token == "TK_EOS" then
    return true
  else
    return false
  end
end

------------------------------------------------------------------------
-- parse a code block or unit
-- * used in multiple functions
------------------------------------------------------------------------
function luaY:block(ls)
  -- block -> chunk
  local fs = ls.fs
  local bl = {}  -- BlockCnt
  self:enterblock(fs, bl, false)
  self:chunk(ls)
  assert(bl.breaklist == luaK.NO_JUMP)
  self:leaveblock(fs)
end

------------------------------------------------------------------------
-- structure to chain all variables in the left-hand side of an
-- assignment
-- struct LHS_assign:
--   prev  -- (table: struct LHS_assign)
--   v  -- variable (global, local, upvalue, or indexed) (table: expdesc)
------------------------------------------------------------------------

------------------------------------------------------------------------
-- check whether, in an assignment to a local variable, the local variable
-- is needed in a previous assignment (to a table). If so, save original
-- local value in a safe place and use this safe copy in the previous
-- assignment.
-- * used in assignment()
------------------------------------------------------------------------
function luaY:check_conflict(ls, lh, v)
  local fs = ls.fs
  local extra = fs.freereg  -- eventual position to save local variable
  local conflict = false
  while lh do
    if lh.v.k == "VINDEXED" then
      if lh.v.info == v.info then  -- conflict?
        conflict = true
        lh.v.info = extra  -- previous assignment will use safe copy
      end
      if lh.v.aux == v.info then  -- conflict?
        conflict = true
        lh.v.aux = extra  -- previous assignment will use safe copy
      end
    end
    lh = lh.prev
  end
  if conflict then
    luaK:codeABC(fs, "OP_MOVE", fs.freereg, v.info, 0)  -- make copy
    luaK:reserveregs(fs, 1)
  end
end

------------------------------------------------------------------------
-- parse a variable assignment sequence
-- * recursively called
-- * used in exprstat()
------------------------------------------------------------------------
function luaY:assignment(ls, lh, nvars)
  local e = {}  -- expdesc
  -- test was: VLOCAL <= lh->v.k && lh->v.k <= VINDEXED
  local c = lh.v.k
  self:check_condition(ls, c == "VLOCAL" or c == "VUPVAL" or c == "VGLOBAL"
                       or c == "VINDEXED", "syntax error")
  if self:testnext(ls, ",") then  -- assignment -> ',' primaryexp assignment
    local nv = {}  -- LHS_assign
          nv.v = {}
    nv.prev = lh
    self:primaryexp(ls, nv.v)
    if nv.v.k == "VLOCAL" then
      self:check_conflict(ls, lh, nv.v)
    end
    self:checklimit(ls.fs, nvars, self.LUAI_MAXCCALLS - ls.L.nCcalls,
                    "variables in assignment")
    self:assignment(ls, nv, nvars + 1)
  else  -- assignment -> '=' explist1
    self:checknext(ls, "=")
    local nexps = self:explist1(ls, e)
    if nexps ~= nvars then
      self:adjust_assign(ls, nvars, nexps, e)
      if nexps > nvars then
        ls.fs.freereg = ls.fs.freereg - (nexps - nvars)  -- remove extra values
      end
    else
      luaK:setoneret(ls.fs, e)  -- close last expression
      luaK:storevar(ls.fs, lh.v, e)
      return  -- avoid default
    end
  end
  self:init_exp(e, "VNONRELOC", ls.fs.freereg - 1)  -- default assignment
  luaK:storevar(ls.fs, lh.v, e)
end

------------------------------------------------------------------------
-- parse condition in a repeat statement or an if control structure
-- * used in repeatstat(), test_then_block()
------------------------------------------------------------------------
function luaY:cond(ls)
  -- cond -> exp
  local v = {}  -- expdesc
  self:expr(ls, v)  -- read condition
  if v.k == "VNIL" then v.k = "VFALSE" end  -- 'falses' are all equal here
  luaK:goiftrue(ls.fs, v)
  return v.f
end

------------------------------------------------------------------------
-- parse a break statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:breakstat(ls)
  -- stat -> BREAK
  local fs = ls.fs
  local bl = fs.bl
  local upval = false
  while bl and not bl.isbreakable do
    if bl.upval then upval = true end
    bl = bl.previous
  end
  if not bl then
    luaX:syntaxerror(ls, "no loop to break")
  end
  if upval then
    luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
  end
  bl.breaklist = luaK:concat(fs, bl.breaklist, luaK:jump(fs))
end

------------------------------------------------------------------------
-- parse a while-do control structure, body processed by block()
-- * with dynamic array sizes, MAXEXPWHILE + EXTRAEXP limits imposed by
--   the function's implementation can be removed
-- * used in statements()
------------------------------------------------------------------------
function luaY:whilestat(ls, line)
  -- whilestat -> WHILE cond DO block END
  local fs = ls.fs
  local bl = {}  -- BlockCnt
  luaX:next(ls)  -- skip WHILE
  local whileinit = luaK:getlabel(fs)
  local condexit = self:cond(ls)
  self:enterblock(fs, bl, true)
  self:checknext(ls, "TK_DO")
  self:block(ls)
  luaK:patchlist(fs, luaK:jump(fs), whileinit)
  self:check_match(ls, "TK_END", "TK_WHILE", line)
  self:leaveblock(fs)
  luaK:patchtohere(fs, condexit)  -- false conditions finish the loop
end

------------------------------------------------------------------------
-- parse a repeat-until control structure, body parsed by chunk()
-- * used in statements()
------------------------------------------------------------------------
function luaY:repeatstat(ls, line)
  -- repeatstat -> REPEAT block UNTIL cond
  local fs = ls.fs
  local repeat_init = luaK:getlabel(fs)
  local bl1, bl2 = {}, {}  -- BlockCnt
  self:enterblock(fs, bl1, true)  -- loop block
  self:enterblock(fs, bl2, false)  -- scope block
  luaX:next(ls)  -- skip REPEAT
  self:chunk(ls)
  self:check_match(ls, "TK_UNTIL", "TK_REPEAT", line)
  local condexit = self:cond(ls)  -- read condition (inside scope block)
  if not bl2.upval then  -- no upvalues?
    self:leaveblock(fs)  -- finish scope
    luaK:patchlist(ls.fs, condexit, repeat_init)  -- close the loop
  else  -- complete semantics when there are upvalues
    self:breakstat(ls)  -- if condition then break
    luaK:patchtohere(ls.fs, condexit)  -- else...
    self:leaveblock(fs)  -- finish scope...
    luaK:patchlist(ls.fs, luaK:jump(fs), repeat_init)  -- and repeat
  end
  self:leaveblock(fs)  -- finish loop
end

------------------------------------------------------------------------
-- parse the single expressions needed in numerical for loops
-- * used in fornum()
------------------------------------------------------------------------
function luaY:exp1(ls)
  local e = {}  -- expdesc
  self:expr(ls, e)
  local k = e.k
  luaK:exp2nextreg(ls.fs, e)
  return k
end

------------------------------------------------------------------------
-- parse a for loop body for both versions of the for loop
-- * used in fornum(), forlist()
------------------------------------------------------------------------
function luaY:forbody(ls, base, line, nvars, isnum)
  -- forbody -> DO block
  local bl = {}  -- BlockCnt
  local fs = ls.fs
  self:adjustlocalvars(ls, 3)  -- control variables
  self:checknext(ls, "TK_DO")
  local prep = isnum and luaK:codeAsBx(fs, "OP_FORPREP", base, luaK.NO_JUMP)
                     or luaK:jump(fs)
  self:enterblock(fs, bl, false)  -- scope for declared variables
  self:adjustlocalvars(ls, nvars)
  luaK:reserveregs(fs, nvars)
  self:block(ls)
  self:leaveblock(fs)  -- end of scope for declared variables
  luaK:patchtohere(fs, prep)
  local endfor = isnum and luaK:codeAsBx(fs, "OP_FORLOOP", base, luaK.NO_JUMP)
                       or luaK:codeABC(fs, "OP_TFORLOOP", base, 0, nvars)
  luaK:fixline(fs, line)  -- pretend that `OP_FOR' starts the loop
  luaK:patchlist(fs, isnum and endfor or luaK:jump(fs), prep + 1)
end

------------------------------------------------------------------------
-- parse a numerical for loop, calls forbody()
-- * used in forstat()
------------------------------------------------------------------------
function luaY:fornum(ls, varname, line)
  -- fornum -> NAME = exp1,exp1[,exp1] forbody
  local fs = ls.fs
  local base = fs.freereg
  self:new_localvarliteral(ls, "(for index)", 0)
  self:new_localvarliteral(ls, "(for limit)", 1)
  self:new_localvarliteral(ls, "(for step)", 2)
  self:new_localvar(ls, varname, 3)
  self:checknext(ls, '=')
  self:exp1(ls)  -- initial value
  self:checknext(ls, ",")
  self:exp1(ls)  -- limit
  if self:testnext(ls, ",") then
    self:exp1(ls)  -- optional step
  else  -- default step = 1
    luaK:codeABx(fs, "OP_LOADK", fs.freereg, luaK:numberK(fs, 1))
    luaK:reserveregs(fs, 1)
  end
  self:forbody(ls, base, line, 1, true)
end

------------------------------------------------------------------------
-- parse a generic for loop, calls forbody()
-- * used in forstat()
------------------------------------------------------------------------
function luaY:forlist(ls, indexname)
  -- forlist -> NAME {,NAME} IN explist1 forbody
  local fs = ls.fs
  local e = {}  -- expdesc
  local nvars = 0
  local base = fs.freereg
  -- create control variables
  self:new_localvarliteral(ls, "(for generator)", nvars)
  nvars = nvars + 1
  self:new_localvarliteral(ls, "(for state)", nvars)
  nvars = nvars + 1
  self:new_localvarliteral(ls, "(for control)", nvars)
  nvars = nvars + 1
  -- create declared variables
  self:new_localvar(ls, indexname, nvars)
  nvars = nvars + 1
  while self:testnext(ls, ",") do
    self:new_localvar(ls, self:str_checkname(ls), nvars)
    nvars = nvars + 1
  end
  self:checknext(ls, "TK_IN")
  local line = ls.linenumber
  self:adjust_assign(ls, 3, self:explist1(ls, e), e)
  luaK:checkstack(fs, 3)  -- extra space to call generator
  self:forbody(ls, base, line, nvars - 3, false)
end

------------------------------------------------------------------------
-- initial parsing for a for loop, calls fornum() or forlist()
-- * used in statements()
------------------------------------------------------------------------
function luaY:forstat(ls, line)
  -- forstat -> FOR (fornum | forlist) END
  local fs = ls.fs
  local bl = {}  -- BlockCnt
  self:enterblock(fs, bl, true)  -- scope for loop and control variables
  luaX:next(ls)  -- skip `for'
  local varname = self:str_checkname(ls)  -- first variable name
  local c = ls.t.token
  if c == "=" then
    self:fornum(ls, varname, line)
  elseif c == "," or c == "TK_IN" then
    self:forlist(ls, varname)
  else
    luaX:syntaxerror(ls, self:LUA_QL("=").." or "..self:LUA_QL("in").." expected")
  end
  self:check_match(ls, "TK_END", "TK_FOR", line)
  self:leaveblock(fs)  -- loop scope (`break' jumps to this point)
end

------------------------------------------------------------------------
-- parse part of an if control structure, including the condition
-- * used in ifstat()
------------------------------------------------------------------------
function luaY:test_then_block(ls)
  -- test_then_block -> [IF | ELSEIF] cond THEN block
  luaX:next(ls)  -- skip IF or ELSEIF
  local condexit = self:cond(ls)
  self:checknext(ls, "TK_THEN")
  self:block(ls)  -- `then' part
  return condexit
end

------------------------------------------------------------------------
-- parse an if control structure
-- * used in statements()
------------------------------------------------------------------------
function luaY:ifstat(ls, line)
  -- ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END
  local fs = ls.fs
  local escapelist = luaK.NO_JUMP
  local flist = self:test_then_block(ls)  -- IF cond THEN block
  while ls.t.token == "TK_ELSEIF" do
    escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
    luaK:patchtohere(fs, flist)
    flist = self:test_then_block(ls)  -- ELSEIF cond THEN block
  end
  if ls.t.token == "TK_ELSE" then
    escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
    luaK:patchtohere(fs, flist)
    luaX:next(ls)  -- skip ELSE (after patch, for correct line info)
    self:block(ls)  -- 'else' part
  else
    escapelist = luaK:concat(fs, escapelist, flist)
  end
  luaK:patchtohere(fs, escapelist)
  self:check_match(ls, "TK_END", "TK_IF", line)
end

------------------------------------------------------------------------
-- parse a local function statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:localfunc(ls)
  local v, b = {}, {}  -- expdesc
  local fs = ls.fs
  self:new_localvar(ls, self:str_checkname(ls), 0)
  self:init_exp(v, "VLOCAL", fs.freereg)
  luaK:reserveregs(fs, 1)
  self:adjustlocalvars(ls, 1)
  self:body(ls, b, false, ls.linenumber)
  luaK:storevar(fs, v, b)
  -- debug information will only see the variable after this point!
  self:getlocvar(fs, fs.nactvar - 1).startpc = fs.pc
end

------------------------------------------------------------------------
-- parse a local variable declaration statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:localstat(ls)
  -- stat -> LOCAL NAME {',' NAME} ['=' explist1]
  local nvars = 0
  local nexps
  local e = {}  -- expdesc
  repeat
    self:new_localvar(ls, self:str_checkname(ls), nvars)
    nvars = nvars + 1
  until not self:testnext(ls, ",")
  if self:testnext(ls, "=") then
    nexps = self:explist1(ls, e)
  else
    e.k = "VVOID"
    nexps = 0
  end
  self:adjust_assign(ls, nvars, nexps, e)
  self:adjustlocalvars(ls, nvars)
end

------------------------------------------------------------------------
-- parse a function name specification
-- * used in funcstat()
------------------------------------------------------------------------
function luaY:funcname(ls, v)
  -- funcname -> NAME {field} [':' NAME]
  local needself = false
  self:singlevar(ls, v)
  while ls.t.token == "." do
    self:field(ls, v)
  end
  if ls.t.token == ":" then
    needself = true
    self:field(ls, v)
  end
  return needself
end

------------------------------------------------------------------------
-- parse a function statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:funcstat(ls, line)
  -- funcstat -> FUNCTION funcname body
  local v, b = {}, {}  -- expdesc
  luaX:next(ls)  -- skip FUNCTION
  local needself = self:funcname(ls, v)
  self:body(ls, b, needself, line)
  luaK:storevar(ls.fs, v, b)
  luaK:fixline(ls.fs, line)  -- definition 'happens' in the first line
end

------------------------------------------------------------------------
-- parse a function call with no returns or an assignment statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:exprstat(ls)
  -- stat -> func | assignment
  local fs = ls.fs
  local v = {}  -- LHS_assign
        v.v = {}
  self:primaryexp(ls, v.v)
  if v.v.k == "VCALL" then  -- stat -> func
    luaP:SETARG_C(luaK:getcode(fs, v.v), 1)  -- call statement uses no results
  else  -- stat -> assignment
    v.prev = nil
    self:assignment(ls, v, 1)
  end
end

------------------------------------------------------------------------
-- parse a return statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:retstat(ls)
  -- stat -> RETURN explist
  local fs = ls.fs
  local e = {}  -- expdesc
  local first, nret  -- registers with returned values
  luaX:next(ls)  -- skip RETURN
  if self:block_follow(ls.t.token) or ls.t.token == ";" then
    first, nret = 0, 0  -- return no values
  else
    nret = self:explist1(ls, e)  -- optional return values
    if self:hasmultret(e.k) then
      luaK:setmultret(fs, e)
      if e.k == "VCALL" and nret == 1 then  -- tail call?
        luaP:SET_OPCODE(luaK:getcode(fs, e), "OP_TAILCALL")
        assert(luaP:GETARG_A(luaK:getcode(fs, e)) == fs.nactvar)
      end
      first = fs.nactvar
      nret = self.LUA_MULTRET  -- return all values
    else
      if nret == 1 then  -- only one single value?
        first = luaK:exp2anyreg(fs, e)
      else
        luaK:exp2nextreg(fs, e)  -- values must go to the 'stack'
        first = fs.nactvar  -- return all 'active' values
        assert(nret == fs.freereg - first)
      end
    end--if
  end--if
  luaK:ret(fs, first, nret)
end

------------------------------------------------------------------------
-- initial parsing for statements, calls a lot of functions
-- * returns boolean instead of 0|1
-- * used in chunk()
------------------------------------------------------------------------
function luaY:statement(ls)
  local line = ls.linenumber  -- may be needed for error messages
  local c = ls.t.token
  if c == "TK_IF" then  -- stat -> ifstat
    self:ifstat(ls, line)
    return false
  elseif c == "TK_WHILE" then  -- stat -> whilestat
    self:whilestat(ls, line)
    return false
  elseif c == "TK_DO" then  -- stat -> DO block END
    luaX:next(ls)  -- skip DO
    self:block(ls)
    self:check_match(ls, "TK_END", "TK_DO", line)
    return false
  elseif c == "TK_FOR" then  -- stat -> forstat
    self:forstat(ls, line)
    return false
  elseif c == "TK_REPEAT" then  -- stat -> repeatstat
    self:repeatstat(ls, line)
    return false
  elseif c == "TK_FUNCTION" then  -- stat -> funcstat
    self:funcstat(ls, line)
    return false
  elseif c == "TK_LOCAL" then  -- stat -> localstat
    luaX:next(ls)  -- skip LOCAL
    if self:testnext(ls, "TK_FUNCTION") then  -- local function?
      self:localfunc(ls)
    else
      self:localstat(ls)
    end
    return false
  elseif c == "TK_RETURN" then  -- stat -> retstat
    self:retstat(ls)
    return true  -- must be last statement
  elseif c == "TK_BREAK" then  -- stat -> breakstat
    luaX:next(ls)  -- skip BREAK
    self:breakstat(ls)
    return true  -- must be last statement
  else
    self:exprstat(ls)
    return false  -- to avoid warnings
  end--if c
end

------------------------------------------------------------------------
-- parse a chunk, which consists of a bunch of statements
-- * used in parser(), body(), block(), repeatstat()
------------------------------------------------------------------------
function luaY:chunk(ls)
  -- chunk -> { stat [';'] }
  local islast = false
  self:enterlevel(ls)
  while not islast and not self:block_follow(ls.t.token) do
    islast = self:statement(ls)
    self:testnext(ls, ";")
    assert(ls.fs.f.maxstacksize >= ls.fs.freereg and
               ls.fs.freereg >= ls.fs.nactvar)
    ls.fs.freereg = ls.fs.nactvar  -- free registers
  end
  self:leavelevel(ls)
end

-- }======================================================================
return luaY
end;
};
G2L_MODULES[G2L["407"]] = {
Closure = function()
    local script = G2L["407"];--[[--------------------------------------------------------------------

  lcode.lua
  Lua 5 code generator in Lua
  This file is part of Yueliang.

  Copyright (c) 2005-2007 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * one function manipulate a pointer argument with a simple data type
--   (can't be emulated by a table, ambiguous), now returns that value:
--   luaK:concat(fs, l1, l2)
-- * luaM_growvector uses the faux luaY:growvector, for limit checking
-- * some function parameters changed to boolean, additional code
--   translates boolean back to 1/0 for instruction fields
--
-- Not implemented:
-- * NOTE there is a failed assert in luaK:addk, a porting problem
--
-- Added:
-- * constant MAXSTACK from llimits.h
-- * luaK:ttisnumber(o) (from lobject.h)
-- * luaK:nvalue(o) (from lobject.h)
-- * luaK:setnilvalue(o) (from lobject.h)
-- * luaK:setnvalue(o, x) (from lobject.h)
-- * luaK:setbvalue(o, x) (from lobject.h)
-- * luaK:sethvalue(o, x) (from lobject.h), parameter L deleted
-- * luaK:setsvalue(o, x) (from lobject.h), parameter L deleted
-- * luaK:numadd, luaK:numsub, luaK:nummul, luaK:numdiv, luaK:nummod,
--   luaK:numpow, luaK:numunm, luaK:numisnan (from luaconf.h)
-- * copyexp(e1, e2) added in luaK:posfix to copy expdesc struct
--
-- Changed in 5.1.x:
-- * enum BinOpr has a new entry, OPR_MOD
-- * enum UnOpr has a new entry, OPR_LEN
-- * binopistest, unused in 5.0.x, has been deleted
-- * macro setmultret is new
-- * functions isnumeral, luaK_ret, boolK are new
-- * funcion nilK was named nil_constant in 5.0.x
-- * function interface changed: need_value, patchtestreg, concat
-- * TObject now a TValue
-- * functions luaK_setreturns, luaK_setoneret are new
-- * function luaK:setcallreturns deleted, to be replaced by:
--   luaK:setmultret, luaK:ret, luaK:setreturns, luaK:setoneret
-- * functions constfolding, codearith, codecomp are new
-- * luaK:codebinop has been deleted
-- * function luaK_setlist is new
-- * OPR_MULT renamed to OPR_MUL
----------------------------------------------------------------------]]

-- requires luaP, luaX, luaY
local luaK = {}
local luaP = require(script.Parent.LuaP)
local luaX = require(script.Parent.LuaX)

------------------------------------------------------------------------
-- constants used by code generator
------------------------------------------------------------------------
-- maximum stack for a Lua function
luaK.MAXSTACK = 250  -- (from llimits.h)

--[[--------------------------------------------------------------------
-- other functions
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- emulation of TValue macros (these are from lobject.h)
-- * TValue is a table since lcode passes references around
-- * tt member field removed, using Lua's type() instead
-- * for setsvalue, sethvalue, parameter L (deleted here) in lobject.h
--   is used in an assert for testing, see checkliveness(g,obj)
------------------------------------------------------------------------
function luaK:ttisnumber(o)
  if o then return type(o.value) == "number" else return false end
end
function luaK:nvalue(o) return o.value end
function luaK:setnilvalue(o) o.value = nil end
function luaK:setsvalue(o, x) o.value = x end
luaK.setnvalue = luaK.setsvalue
luaK.sethvalue = luaK.setsvalue
luaK.setbvalue = luaK.setsvalue

------------------------------------------------------------------------
-- The luai_num* macros define the primitive operations over numbers.
-- * this is not the entire set of primitive operations from luaconf.h
-- * used in luaK:constfolding()
------------------------------------------------------------------------
function luaK:numadd(a, b) return a + b end
function luaK:numsub(a, b) return a - b end
function luaK:nummul(a, b) return a * b end
function luaK:numdiv(a, b) return a / b end
function luaK:nummod(a, b) return a % b end
  -- ((a) - floor((a)/(b))*(b)) /* actual, for reference */
function luaK:numpow(a, b) return a ^ b end
function luaK:numunm(a) return -a end
function luaK:numisnan(a) return not a == a end
  -- a NaN cannot equal another NaN

--[[--------------------------------------------------------------------
-- code generator functions
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- Marks the end of a patch list. It is an invalid value both as an absolute
-- address, and as a list link (would link an element to itself).
------------------------------------------------------------------------
luaK.NO_JUMP = -1

------------------------------------------------------------------------
-- grep "ORDER OPR" if you change these enums
------------------------------------------------------------------------
luaK.BinOpr = {
  OPR_ADD = 0, OPR_SUB = 1, OPR_MUL = 2, OPR_DIV = 3, OPR_MOD = 4, OPR_POW = 5,
  OPR_CONCAT = 6,
  OPR_NE = 7, OPR_EQ = 8,
  OPR_LT = 9, OPR_LE = 10, OPR_GT = 11, OPR_GE = 12,
  OPR_AND = 13, OPR_OR = 14,
  OPR_NOBINOPR = 15,
}

-- * UnOpr is used by luaK:prefix's op argument, but not directly used
--   because the function receives the symbols as strings, e.g. "OPR_NOT"
luaK.UnOpr = {
  OPR_MINUS = 0, OPR_NOT = 1, OPR_LEN = 2, OPR_NOUNOPR = 3
}

------------------------------------------------------------------------
-- returns the instruction object for given e (expdesc), was a macro
------------------------------------------------------------------------
function luaK:getcode(fs, e)
  return fs.f.code[e.info]
end

------------------------------------------------------------------------
-- codes an instruction with a signed Bx (sBx) field, was a macro
-- * used in luaK:jump(), (lparser) luaY:forbody()
------------------------------------------------------------------------
function luaK:codeAsBx(fs, o, A, sBx)
  return self:codeABx(fs, o, A, sBx + luaP.MAXARG_sBx)
end

------------------------------------------------------------------------
-- set the expdesc e instruction for multiple returns, was a macro
------------------------------------------------------------------------
function luaK:setmultret(fs, e)
  self:setreturns(fs, e, luaY.LUA_MULTRET)
end

------------------------------------------------------------------------
-- there is a jump if patch lists are not identical, was a macro
-- * used in luaK:exp2reg(), luaK:exp2anyreg(), luaK:exp2val()
------------------------------------------------------------------------
function luaK:hasjumps(e)
  return e.t ~= e.f
end

------------------------------------------------------------------------
-- true if the expression is a constant number (for constant folding)
-- * used in constfolding(), infix()
------------------------------------------------------------------------
function luaK:isnumeral(e)
  return e.k == "VKNUM" and e.t == self.NO_JUMP and e.f == self.NO_JUMP
end

------------------------------------------------------------------------
-- codes loading of nil, optimization done if consecutive locations
-- * used in luaK:discharge2reg(), (lparser) luaY:adjust_assign()
------------------------------------------------------------------------
function luaK:_nil(fs, from, n)
  if fs.pc > fs.lasttarget then  -- no jumps to current position?
    if fs.pc == 0 then  -- function start?
      if from >= fs.nactvar then
        return  -- positions are already clean
      end
    else
      local previous = fs.f.code[fs.pc - 1]
      if luaP:GET_OPCODE(previous) == "OP_LOADNIL" then
        local pfrom = luaP:GETARG_A(previous)
        local pto = luaP:GETARG_B(previous)
        if pfrom <= from and from <= pto + 1 then  -- can connect both?
          if from + n - 1 > pto then
            luaP:SETARG_B(previous, from + n - 1)
          end
          return
        end
      end
    end
  end
  self:codeABC(fs, "OP_LOADNIL", from, from + n - 1, 0)  -- else no optimization
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:jump(fs)
  local jpc = fs.jpc  -- save list of jumps to here
  fs.jpc = self.NO_JUMP
  local j = self:codeAsBx(fs, "OP_JMP", 0, self.NO_JUMP)
  j = self:concat(fs, j, jpc)  -- keep them on hold
  return j
end

------------------------------------------------------------------------
-- codes a RETURN instruction
-- * used in luaY:close_func(), luaY:retstat()
------------------------------------------------------------------------
function luaK:ret(fs, first, nret)
  self:codeABC(fs, "OP_RETURN", first, nret + 1, 0)
end

------------------------------------------------------------------------
--
-- * used in luaK:jumponcond(), luaK:codecomp()
------------------------------------------------------------------------
function luaK:condjump(fs, op, A, B, C)
  self:codeABC(fs, op, A, B, C)
  return self:jump(fs)
end

------------------------------------------------------------------------
--
-- * used in luaK:patchlistaux(), luaK:concat()
------------------------------------------------------------------------
function luaK:fixjump(fs, pc, dest)
  local jmp = fs.f.code[pc]
  local offset = dest - (pc + 1)
  assert(dest ~= self.NO_JUMP)
  if math.abs(offset) > luaP.MAXARG_sBx then
    luaX:syntaxerror(fs.ls, "control structure too long")
  end
  luaP:SETARG_sBx(jmp, offset)
end

------------------------------------------------------------------------
-- returns current 'pc' and marks it as a jump target (to avoid wrong
-- optimizations with consecutive instructions not in the same basic block).
-- * used in multiple locations
-- * fs.lasttarget tested only by luaK:_nil() when optimizing OP_LOADNIL
------------------------------------------------------------------------
function luaK:getlabel(fs)
  fs.lasttarget = fs.pc
  return fs.pc
end

------------------------------------------------------------------------
--
-- * used in luaK:need_value(), luaK:removevalues(), luaK:patchlistaux(),
--   luaK:concat()
------------------------------------------------------------------------
function luaK:getjump(fs, pc)
  local offset = luaP:GETARG_sBx(fs.f.code[pc])
  if offset == self.NO_JUMP then  -- point to itself represents end of list
    return self.NO_JUMP  -- end of list
  else
    return (pc + 1) + offset  -- turn offset into absolute position
  end
end

------------------------------------------------------------------------
--
-- * used in luaK:need_value(), luaK:patchtestreg(), luaK:invertjump()
------------------------------------------------------------------------
function luaK:getjumpcontrol(fs, pc)
  local pi = fs.f.code[pc]
  local ppi = fs.f.code[pc - 1]
  if pc >= 1 and luaP:testTMode(luaP:GET_OPCODE(ppi)) ~= 0 then
    return ppi
  else
    return pi
  end
end

------------------------------------------------------------------------
-- check whether list has any jump that do not produce a value
-- (or produce an inverted value)
-- * return value changed to boolean
-- * used only in luaK:exp2reg()
------------------------------------------------------------------------
function luaK:need_value(fs, list)
  while list ~= self.NO_JUMP do
    local i = self:getjumpcontrol(fs, list)
    if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then return true end
    list = self:getjump(fs, list)
  end
  return false  -- not found
end

------------------------------------------------------------------------
--
-- * used in luaK:removevalues(), luaK:patchlistaux()
------------------------------------------------------------------------
function luaK:patchtestreg(fs, node, reg)
  local i = self:getjumpcontrol(fs, node)
  if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then
    return false  -- cannot patch other instructions
  end
  if reg ~= luaP.NO_REG and reg ~= luaP:GETARG_B(i) then
    luaP:SETARG_A(i, reg)
  else  -- no register to put value or register already has the value
    -- due to use of a table as i, i cannot be replaced by another table
    -- so the following is required; there is no change to ARG_C
    luaP:SET_OPCODE(i, "OP_TEST")
    local b = luaP:GETARG_B(i)
    luaP:SETARG_A(i, b)
    luaP:SETARG_B(i, 0)
    -- *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i)); /* C */
  end
  return true
end

------------------------------------------------------------------------
--
-- * used only in luaK:codenot()
------------------------------------------------------------------------
function luaK:removevalues(fs, list)
  while list ~= self.NO_JUMP do
    self:patchtestreg(fs, list, luaP.NO_REG)
    list = self:getjump(fs, list)
  end
end

------------------------------------------------------------------------
--
-- * used in luaK:dischargejpc(), luaK:patchlist(), luaK:exp2reg()
------------------------------------------------------------------------
function luaK:patchlistaux(fs, list, vtarget, reg, dtarget)
  while list ~= self.NO_JUMP do
    local _next = self:getjump(fs, list)
    if self:patchtestreg(fs, list, reg) then
      self:fixjump(fs, list, vtarget)
    else
      self:fixjump(fs, list, dtarget)  -- jump to default target
    end
    list = _next
  end
end

------------------------------------------------------------------------
--
-- * used only in luaK:code()
------------------------------------------------------------------------
function luaK:dischargejpc(fs)
  self:patchlistaux(fs, fs.jpc, fs.pc, luaP.NO_REG, fs.pc)
  fs.jpc = self.NO_JUMP
end

------------------------------------------------------------------------
--
-- * used in (lparser) luaY:whilestat(), luaY:repeatstat(), luaY:forbody()
------------------------------------------------------------------------
function luaK:patchlist(fs, list, target)
  if target == fs.pc then
    self:patchtohere(fs, list)
  else
    assert(target < fs.pc)
    self:patchlistaux(fs, list, target, luaP.NO_REG, target)
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:patchtohere(fs, list)
  self:getlabel(fs)
  fs.jpc = self:concat(fs, fs.jpc, list)
end

------------------------------------------------------------------------
-- * l1 was a pointer, now l1 is returned and callee assigns the value
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:concat(fs, l1, l2)
  if l2 == self.NO_JUMP then return l1
  elseif l1 == self.NO_JUMP then
    return l2
  else
    local list = l1
    local _next = self:getjump(fs, list)
    while _next ~= self.NO_JUMP do  -- find last element
      list = _next
      _next = self:getjump(fs, list)
    end
    self:fixjump(fs, list, l2)
  end
  return l1
end

------------------------------------------------------------------------
--
-- * used in luaK:reserveregs(), (lparser) luaY:forlist()
------------------------------------------------------------------------
function luaK:checkstack(fs, n)
  local newstack = fs.freereg + n
  if newstack > fs.f.maxstacksize then
    if newstack >= self.MAXSTACK then
      luaX:syntaxerror(fs.ls, "function or expression too complex")
    end
    fs.f.maxstacksize = newstack
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:reserveregs(fs, n)
  self:checkstack(fs, n)
  fs.freereg = fs.freereg + n
end

------------------------------------------------------------------------
--
-- * used in luaK:freeexp(), luaK:dischargevars()
------------------------------------------------------------------------
function luaK:freereg(fs, reg)
  if not luaP:ISK(reg) and reg >= fs.nactvar then
    fs.freereg = fs.freereg - 1
    assert(reg == fs.freereg)
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:freeexp(fs, e)
  if e.k == "VNONRELOC" then
    self:freereg(fs, e.info)
  end
end

------------------------------------------------------------------------
-- * TODO NOTE implementation is not 100% correct, since the assert fails
-- * luaH_set, setobj deleted; direct table access used instead
-- * used in luaK:stringK(), luaK:numberK(), luaK:boolK(), luaK:nilK()
------------------------------------------------------------------------
function luaK:addk(fs, k, v)
  local L = fs.L
  local idx = fs.h[k.value]
  --TValue *idx = luaH_set(L, fs->h, k); /* C */
  local f = fs.f
  if self:ttisnumber(idx) then
    --TODO this assert currently FAILS (last tested for 5.0.2)
    --assert(fs.f.k[self:nvalue(idx)] == v)
    --assert(luaO_rawequalObj(&fs->f->k[cast_int(nvalue(idx))], v)); /* C */
    return self:nvalue(idx)
  else -- constant not found; create a new entry
    idx = {}
    self:setnvalue(idx, fs.nk)
    fs.h[k.value] = idx
    -- setnvalue(idx, cast_num(fs->nk)); /* C */
    luaY:growvector(L, f.k, fs.nk, f.sizek, nil,
                    luaP.MAXARG_Bx, "constant table overflow")
    -- loop to initialize empty f.k positions not required
    f.k[fs.nk] = v
    -- setobj(L, &f->k[fs->nk], v); /* C */
    -- luaC_barrier(L, f, v); /* GC */
    local nk = fs.nk
    fs.nk = fs.nk + 1
    return nk
  end

end

------------------------------------------------------------------------
-- creates and sets a string object
-- * used in (lparser) luaY:codestring(), luaY:singlevar()
------------------------------------------------------------------------
function luaK:stringK(fs, s)
  local o = {}  -- TValue
  self:setsvalue(o, s)
  return self:addk(fs, o, o)
end

------------------------------------------------------------------------
-- creates and sets a number object
-- * used in luaK:prefix() for negative (or negation of) numbers
-- * used in (lparser) luaY:simpleexp(), luaY:fornum()
------------------------------------------------------------------------
function luaK:numberK(fs, r)
  local o = {}  -- TValue
  self:setnvalue(o, r)
  return self:addk(fs, o, o)
end

------------------------------------------------------------------------
-- creates and sets a boolean object
-- * used only in luaK:exp2RK()
------------------------------------------------------------------------
function luaK:boolK(fs, b)
  local o = {}  -- TValue
  self:setbvalue(o, b)
  return self:addk(fs, o, o)
end

------------------------------------------------------------------------
-- creates and sets a nil object
-- * used only in luaK:exp2RK()
------------------------------------------------------------------------
function luaK:nilK(fs)
  local k, v = {}, {}  -- TValue
  self:setnilvalue(v)
  -- cannot use nil as key; instead use table itself to represent nil
  self:sethvalue(k, fs.h)
  return self:addk(fs, k, v)
end

------------------------------------------------------------------------
--
-- * used in luaK:setmultret(), (lparser) luaY:adjust_assign()
------------------------------------------------------------------------
function luaK:setreturns(fs, e, nresults)
  if e.k == "VCALL" then  -- expression is an open function call?
    luaP:SETARG_C(self:getcode(fs, e), nresults + 1)
  elseif e.k == "VVARARG" then
    luaP:SETARG_B(self:getcode(fs, e), nresults + 1);
    luaP:SETARG_A(self:getcode(fs, e), fs.freereg);
    luaK:reserveregs(fs, 1)
  end
end

------------------------------------------------------------------------
--
-- * used in luaK:dischargevars(), (lparser) luaY:assignment()
------------------------------------------------------------------------
function luaK:setoneret(fs, e)
  if e.k == "VCALL" then  -- expression is an open function call?
    e.k = "VNONRELOC"
    e.info = luaP:GETARG_A(self:getcode(fs, e))
  elseif e.k == "VVARARG" then
    luaP:SETARG_B(self:getcode(fs, e), 2)
    e.k = "VRELOCABLE"  -- can relocate its simple result
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:dischargevars(fs, e)
  local k = e.k
  if k == "VLOCAL" then
    e.k = "VNONRELOC"
  elseif k == "VUPVAL" then
    e.info = self:codeABC(fs, "OP_GETUPVAL", 0, e.info, 0)
    e.k = "VRELOCABLE"
  elseif k == "VGLOBAL" then
    e.info = self:codeABx(fs, "OP_GETGLOBAL", 0, e.info)
    e.k = "VRELOCABLE"
  elseif k == "VINDEXED" then
    self:freereg(fs, e.aux)
    self:freereg(fs, e.info)
    e.info = self:codeABC(fs, "OP_GETTABLE", 0, e.info, e.aux)
    e.k = "VRELOCABLE"
  elseif k == "VVARARG" or k == "VCALL" then
    self:setoneret(fs, e)
  else
    -- there is one value available (somewhere)
  end
end

------------------------------------------------------------------------
--
-- * used only in luaK:exp2reg()
------------------------------------------------------------------------
function luaK:code_label(fs, A, b, jump)
  self:getlabel(fs)  -- those instructions may be jump targets
  return self:codeABC(fs, "OP_LOADBOOL", A, b, jump)
end

------------------------------------------------------------------------
--
-- * used in luaK:discharge2anyreg(), luaK:exp2reg()
------------------------------------------------------------------------
function luaK:discharge2reg(fs, e, reg)
  self:dischargevars(fs, e)
  local k = e.k
  if k == "VNIL" then
    self:_nil(fs, reg, 1)
  elseif k == "VFALSE" or k == "VTRUE" then
    self:codeABC(fs, "OP_LOADBOOL", reg, (e.k == "VTRUE") and 1 or 0, 0)
  elseif k == "VK" then
    self:codeABx(fs, "OP_LOADK", reg, e.info)
  elseif k == "VKNUM" then
    self:codeABx(fs, "OP_LOADK", reg, self:numberK(fs, e.nval))
  elseif k == "VRELOCABLE" then
    local pc = self:getcode(fs, e)
    luaP:SETARG_A(pc, reg)
  elseif k == "VNONRELOC" then
    if reg ~= e.info then
      self:codeABC(fs, "OP_MOVE", reg, e.info, 0)
    end
  else
    assert(e.k == "VVOID" or e.k == "VJMP")
    return  -- nothing to do...
  end
  e.info = reg
  e.k = "VNONRELOC"
end

------------------------------------------------------------------------
--
-- * used in luaK:jumponcond(), luaK:codenot()
------------------------------------------------------------------------
function luaK:discharge2anyreg(fs, e)
  if e.k ~= "VNONRELOC" then
    self:reserveregs(fs, 1)
    self:discharge2reg(fs, e, fs.freereg - 1)
  end
end

------------------------------------------------------------------------
--
-- * used in luaK:exp2nextreg(), luaK:exp2anyreg(), luaK:storevar()
------------------------------------------------------------------------
function luaK:exp2reg(fs, e, reg)
  self:discharge2reg(fs, e, reg)
  if e.k == "VJMP" then
    e.t = self:concat(fs, e.t, e.info)  -- put this jump in 't' list
  end
  if self:hasjumps(e) then
    local final  -- position after whole expression
    local p_f = self.NO_JUMP  -- position of an eventual LOAD false
    local p_t = self.NO_JUMP  -- position of an eventual LOAD true
    if self:need_value(fs, e.t) or self:need_value(fs, e.f) then
      local fj = (e.k == "VJMP") and self.NO_JUMP or self:jump(fs)
      p_f = self:code_label(fs, reg, 0, 1)
      p_t = self:code_label(fs, reg, 1, 0)
      self:patchtohere(fs, fj)
    end
    final = self:getlabel(fs)
    self:patchlistaux(fs, e.f, final, reg, p_f)
    self:patchlistaux(fs, e.t, final, reg, p_t)
  end
  e.f, e.t = self.NO_JUMP, self.NO_JUMP
  e.info = reg
  e.k = "VNONRELOC"
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:exp2nextreg(fs, e)
  self:dischargevars(fs, e)
  self:freeexp(fs, e)
  self:reserveregs(fs, 1)
  self:exp2reg(fs, e, fs.freereg - 1)
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:exp2anyreg(fs, e)
  self:dischargevars(fs, e)
  if e.k == "VNONRELOC" then
    if not self:hasjumps(e) then  -- exp is already in a register
      return e.info
    end
    if e.info >= fs.nactvar then  -- reg. is not a local?
      self:exp2reg(fs, e, e.info)  -- put value on it
      return e.info
    end
  end
  self:exp2nextreg(fs, e)  -- default
  return e.info
end

------------------------------------------------------------------------
--
-- * used in luaK:exp2RK(), luaK:prefix(), luaK:posfix()
-- * used in (lparser) luaY:yindex()
------------------------------------------------------------------------
function luaK:exp2val(fs, e)
  if self:hasjumps(e) then
    self:exp2anyreg(fs, e)
  else
    self:dischargevars(fs, e)
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:exp2RK(fs, e)
  self:exp2val(fs, e)
  local k = e.k
  if k == "VKNUM" or k == "VTRUE" or k == "VFALSE" or k == "VNIL" then
    if fs.nk <= luaP.MAXINDEXRK then  -- constant fit in RK operand?
      -- converted from a 2-deep ternary operator expression
      if e.k == "VNIL" then
        e.info = self:nilK(fs)
      else
        e.info = (e.k == "VKNUM") and self:numberK(fs, e.nval)
                                  or self:boolK(fs, e.k == "VTRUE")
      end
      e.k = "VK"
      return luaP:RKASK(e.info)
    end
  elseif k == "VK" then
    if e.info <= luaP.MAXINDEXRK then  -- constant fit in argC?
      return luaP:RKASK(e.info)
    end
  else
    -- default
  end
  -- not a constant in the right range: put it in a register
  return self:exp2anyreg(fs, e)
end

------------------------------------------------------------------------
--
-- * used in (lparser) luaY:assignment(), luaY:localfunc(), luaY:funcstat()
------------------------------------------------------------------------
function luaK:storevar(fs, var, ex)
  local k = var.k
  if k == "VLOCAL" then
    self:freeexp(fs, ex)
    self:exp2reg(fs, ex, var.info)
    return
  elseif k == "VUPVAL" then
    local e = self:exp2anyreg(fs, ex)
    self:codeABC(fs, "OP_SETUPVAL", e, var.info, 0)
  elseif k == "VGLOBAL" then
    local e = self:exp2anyreg(fs, ex)
    self:codeABx(fs, "OP_SETGLOBAL", e, var.info)
  elseif k == "VINDEXED" then
    local e = self:exp2RK(fs, ex)
    self:codeABC(fs, "OP_SETTABLE", var.info, var.aux, e)
  else
    assert(0)  -- invalid var kind to store
  end
  self:freeexp(fs, ex)
end

------------------------------------------------------------------------
--
-- * used only in (lparser) luaY:primaryexp()
------------------------------------------------------------------------
function luaK:_self(fs, e, key)
  self:exp2anyreg(fs, e)
  self:freeexp(fs, e)
  local func = fs.freereg
  self:reserveregs(fs, 2)
  self:codeABC(fs, "OP_SELF", func, e.info, self:exp2RK(fs, key))
  self:freeexp(fs, key)
  e.info = func
  e.k = "VNONRELOC"
end

------------------------------------------------------------------------
--
-- * used in luaK:goiftrue(), luaK:codenot()
------------------------------------------------------------------------
function luaK:invertjump(fs, e)
  local pc = self:getjumpcontrol(fs, e.info)
  assert(luaP:testTMode(luaP:GET_OPCODE(pc)) ~= 0 and
             luaP:GET_OPCODE(pc) ~= "OP_TESTSET" and
             luaP:GET_OPCODE(pc) ~= "OP_TEST")
  luaP:SETARG_A(pc, (luaP:GETARG_A(pc) == 0) and 1 or 0)
end

------------------------------------------------------------------------
--
-- * used in luaK:goiftrue(), luaK:goiffalse()
------------------------------------------------------------------------
function luaK:jumponcond(fs, e, cond)
  if e.k == "VRELOCABLE" then
    local ie = self:getcode(fs, e)
    if luaP:GET_OPCODE(ie) == "OP_NOT" then
      fs.pc = fs.pc - 1  -- remove previous OP_NOT
      return self:condjump(fs, "OP_TEST", luaP:GETARG_B(ie), 0, cond and 0 or 1)
    end
    -- else go through
  end
  self:discharge2anyreg(fs, e)
  self:freeexp(fs, e)
  return self:condjump(fs, "OP_TESTSET", luaP.NO_REG, e.info, cond and 1 or 0)
end

------------------------------------------------------------------------
--
-- * used in luaK:infix(), (lparser) luaY:cond()
------------------------------------------------------------------------
function luaK:goiftrue(fs, e)
  local pc  -- pc of last jump
  self:dischargevars(fs, e)
  local k = e.k
  if k == "VK" or k == "VKNUM" or k == "VTRUE" then
    pc = self.NO_JUMP  -- always true; do nothing
  elseif k == "VFALSE" then
    pc = self:jump(fs)  -- always jump
  elseif k == "VJMP" then
    self:invertjump(fs, e)
    pc = e.info
  else
    pc = self:jumponcond(fs, e, false)
  end
  e.f = self:concat(fs, e.f, pc)  -- insert last jump in `f' list
  self:patchtohere(fs, e.t)
  e.t = self.NO_JUMP
end

------------------------------------------------------------------------
--
-- * used in luaK:infix()
------------------------------------------------------------------------
function luaK:goiffalse(fs, e)
  local pc  -- pc of last jump
  self:dischargevars(fs, e)
  local k = e.k
  if k == "VNIL" or k == "VFALSE"then
    pc = self.NO_JUMP  -- always false; do nothing
  elseif k == "VTRUE" then
    pc = self:jump(fs)  -- always jump
  elseif k == "VJMP" then
    pc = e.info
  else
    pc = self:jumponcond(fs, e, true)
  end
  e.t = self:concat(fs, e.t, pc)  -- insert last jump in `t' list
  self:patchtohere(fs, e.f)
  e.f = self.NO_JUMP
end

------------------------------------------------------------------------
--
-- * used only in luaK:prefix()
------------------------------------------------------------------------
function luaK:codenot(fs, e)
  self:dischargevars(fs, e)
  local k = e.k
  if k == "VNIL" or k == "VFALSE" then
    e.k = "VTRUE"
  elseif k == "VK" or k == "VKNUM" or k == "VTRUE" then
    e.k = "VFALSE"
  elseif k == "VJMP" then
    self:invertjump(fs, e)
  elseif k == "VRELOCABLE" or k == "VNONRELOC" then
    self:discharge2anyreg(fs, e)
    self:freeexp(fs, e)
    e.info = self:codeABC(fs, "OP_NOT", 0, e.info, 0)
    e.k = "VRELOCABLE"
  else
    assert(0)  -- cannot happen
  end
  -- interchange true and false lists
  e.f, e.t = e.t, e.f
  self:removevalues(fs, e.f)
  self:removevalues(fs, e.t)
end

------------------------------------------------------------------------
--
-- * used in (lparser) luaY:field(), luaY:primaryexp()
------------------------------------------------------------------------
function luaK:indexed(fs, t, k)
  t.aux = self:exp2RK(fs, k)
  t.k = "VINDEXED"
end

------------------------------------------------------------------------
--
-- * used only in luaK:codearith()
------------------------------------------------------------------------
function luaK:constfolding(op, e1, e2)
  local r
  if not self:isnumeral(e1) or not self:isnumeral(e2) then return false end
  local v1 = e1.nval
  local v2 = e2.nval
  if op == "OP_ADD" then
    r = self:numadd(v1, v2)
  elseif op == "OP_SUB" then
    r = self:numsub(v1, v2)
  elseif op == "OP_MUL" then
    r = self:nummul(v1, v2)
  elseif op == "OP_DIV" then
    if v2 == 0 then return false end  -- do not attempt to divide by 0
    r = self:numdiv(v1, v2)
  elseif op == "OP_MOD" then
    if v2 == 0 then return false end  -- do not attempt to divide by 0
    r = self:nummod(v1, v2)
  elseif op == "OP_POW" then
    r = self:numpow(v1, v2)
  elseif op == "OP_UNM" then
    r = self:numunm(v1)
  elseif op == "OP_LEN" then
    return false  -- no constant folding for 'len'
  else
    assert(0)
    r = 0
  end
  if self:numisnan(r) then return false end  -- do not attempt to produce NaN
  e1.nval = r
  return true
end

------------------------------------------------------------------------
--
-- * used in luaK:prefix(), luaK:posfix()
------------------------------------------------------------------------
function luaK:codearith(fs, op, e1, e2)
  if self:constfolding(op, e1, e2) then
    return
  else
    local o2 = (op ~= "OP_UNM" and op ~= "OP_LEN") and self:exp2RK(fs, e2) or 0
    local o1 = self:exp2RK(fs, e1)
    if o1 > o2 then
      self:freeexp(fs, e1)
      self:freeexp(fs, e2)
    else
      self:freeexp(fs, e2)
      self:freeexp(fs, e1)
    end
    e1.info = self:codeABC(fs, op, 0, o1, o2)
    e1.k = "VRELOCABLE"
  end
end

------------------------------------------------------------------------
--
-- * used only in luaK:posfix()
------------------------------------------------------------------------
function luaK:codecomp(fs, op, cond, e1, e2)
  local o1 = self:exp2RK(fs, e1)
  local o2 = self:exp2RK(fs, e2)
  self:freeexp(fs, e2)
  self:freeexp(fs, e1)
  if cond == 0 and op ~= "OP_EQ" then
    -- exchange args to replace by `<' or `<='
    o1, o2 = o2, o1  -- o1 <==> o2
    cond = 1
  end
  e1.info = self:condjump(fs, op, cond, o1, o2)
  e1.k = "VJMP"
end

------------------------------------------------------------------------
--
-- * used only in (lparser) luaY:subexpr()
------------------------------------------------------------------------
function luaK:prefix(fs, op, e)
  local e2 = {}  -- expdesc
  e2.t, e2.f = self.NO_JUMP, self.NO_JUMP
  e2.k = "VKNUM"
  e2.nval = 0
  if op == "OPR_MINUS" then
    if not self:isnumeral(e) then
      self:exp2anyreg(fs, e)  -- cannot operate on non-numeric constants
    end
    self:codearith(fs, "OP_UNM", e, e2)
  elseif op == "OPR_NOT" then
    self:codenot(fs, e)
  elseif op == "OPR_LEN" then
    self:exp2anyreg(fs, e)  -- cannot operate on constants
    self:codearith(fs, "OP_LEN", e, e2)
  else
    assert(0)
  end
end

------------------------------------------------------------------------
--
-- * used only in (lparser) luaY:subexpr()
------------------------------------------------------------------------
function luaK:infix(fs, op, v)
  if op == "OPR_AND" then
    self:goiftrue(fs, v)
  elseif op == "OPR_OR" then
    self:goiffalse(fs, v)
  elseif op == "OPR_CONCAT" then
    self:exp2nextreg(fs, v)  -- operand must be on the 'stack'
  elseif op == "OPR_ADD" or op == "OPR_SUB" or
         op == "OPR_MUL" or op == "OPR_DIV" or
         op == "OPR_MOD" or op == "OPR_POW" then
    if not self:isnumeral(v) then self:exp2RK(fs, v) end
  else
    self:exp2RK(fs, v)
  end
end

------------------------------------------------------------------------
--
-- * used only in (lparser) luaY:subexpr()
------------------------------------------------------------------------
-- table lookups to simplify testing
luaK.arith_op = {
  OPR_ADD = "OP_ADD", OPR_SUB = "OP_SUB", OPR_MUL = "OP_MUL",
  OPR_DIV = "OP_DIV", OPR_MOD = "OP_MOD", OPR_POW = "OP_POW",
}
luaK.comp_op = {
  OPR_EQ = "OP_EQ", OPR_NE = "OP_EQ", OPR_LT = "OP_LT",
  OPR_LE = "OP_LE", OPR_GT = "OP_LT", OPR_GE = "OP_LE",
}
luaK.comp_cond = {
  OPR_EQ = 1, OPR_NE = 0, OPR_LT = 1,
  OPR_LE = 1, OPR_GT = 0, OPR_GE = 0,
}
function luaK:posfix(fs, op, e1, e2)
  -- needed because e1 = e2 doesn't copy values...
  -- * in 5.0.x, only k/info/aux/t/f copied, t for AND, f for OR
  --   but here, all elements are copied for completeness' sake
  local function copyexp(e1, e2)
    e1.k = e2.k
    e1.info = e2.info; e1.aux = e2.aux
    e1.nval = e2.nval
    e1.t = e2.t; e1.f = e2.f
  end
  if op == "OPR_AND" then
    assert(e1.t == self.NO_JUMP)  -- list must be closed
    self:dischargevars(fs, e2)
    e2.f = self:concat(fs, e2.f, e1.f)
    copyexp(e1, e2)
  elseif op == "OPR_OR" then
    assert(e1.f == self.NO_JUMP)  -- list must be closed
    self:dischargevars(fs, e2)
    e2.t = self:concat(fs, e2.t, e1.t)
    copyexp(e1, e2)
  elseif op == "OPR_CONCAT" then
    self:exp2val(fs, e2)
    if e2.k == "VRELOCABLE" and luaP:GET_OPCODE(self:getcode(fs, e2)) == "OP_CONCAT" then
      assert(e1.info == luaP:GETARG_B(self:getcode(fs, e2)) - 1)
      self:freeexp(fs, e1)
      luaP:SETARG_B(self:getcode(fs, e2), e1.info)
      e1.k = "VRELOCABLE"
      e1.info = e2.info
    else
      self:exp2nextreg(fs, e2)  -- operand must be on the 'stack'
      self:codearith(fs, "OP_CONCAT", e1, e2)
    end
  else
    -- the following uses a table lookup in place of conditionals
    local arith = self.arith_op[op]
    if arith then
      self:codearith(fs, arith, e1, e2)
    else
      local comp = self.comp_op[op]
      if comp then
        self:codecomp(fs, comp, self.comp_cond[op], e1, e2)
      else
        assert(0)
      end
    end--if arith
  end--if op
end

------------------------------------------------------------------------
-- adjusts debug information for last instruction written, in order to
-- change the line where item comes into existence
-- * used in (lparser) luaY:funcargs(), luaY:forbody(), luaY:funcstat()
------------------------------------------------------------------------
function luaK:fixline(fs, line)
  fs.f.lineinfo[fs.pc - 1] = line
end

------------------------------------------------------------------------
-- general function to write an instruction into the instruction buffer,
-- sets debug information too
-- * used in luaK:codeABC(), luaK:codeABx()
-- * called directly by (lparser) luaY:whilestat()
------------------------------------------------------------------------
function luaK:code(fs, i, line)
  local f = fs.f
  self:dischargejpc(fs)  -- 'pc' will change
  -- put new instruction in code array
  luaY:growvector(fs.L, f.code, fs.pc, f.sizecode, nil,
                  luaY.MAX_INT, "code size overflow")
  f.code[fs.pc] = i
  -- save corresponding line information
  luaY:growvector(fs.L, f.lineinfo, fs.pc, f.sizelineinfo, nil,
                  luaY.MAX_INT, "code size overflow")
  f.lineinfo[fs.pc] = line
  local pc = fs.pc
  fs.pc = fs.pc + 1
  return pc
end

------------------------------------------------------------------------
-- writes an instruction of type ABC
-- * calls luaK:code()
------------------------------------------------------------------------
function luaK:codeABC(fs, o, a, b, c)
  assert(luaP:getOpMode(o) == luaP.OpMode.iABC)
  assert(luaP:getBMode(o) ~= luaP.OpArgMask.OpArgN or b == 0)
  assert(luaP:getCMode(o) ~= luaP.OpArgMask.OpArgN or c == 0)
  return self:code(fs, luaP:CREATE_ABC(o, a, b, c), fs.ls.lastline)
end

------------------------------------------------------------------------
-- writes an instruction of type ABx
-- * calls luaK:code(), called by luaK:codeAsBx()
------------------------------------------------------------------------
function luaK:codeABx(fs, o, a, bc)
  assert(luaP:getOpMode(o) == luaP.OpMode.iABx or
             luaP:getOpMode(o) == luaP.OpMode.iAsBx)
  assert(luaP:getCMode(o) == luaP.OpArgMask.OpArgN)
  return self:code(fs, luaP:CREATE_ABx(o, a, bc), fs.ls.lastline)
end

------------------------------------------------------------------------
--
-- * used in (lparser) luaY:closelistfield(), luaY:lastlistfield()
------------------------------------------------------------------------
function luaK:setlist(fs, base, nelems, tostore)
  local c = math.floor((nelems - 1)/luaP.LFIELDS_PER_FLUSH) + 1
  local b = (tostore == luaY.LUA_MULTRET) and 0 or tostore
  assert(tostore ~= 0)
  if c <= luaP.MAXARG_C then
    self:codeABC(fs, "OP_SETLIST", base, b, c)
  else
    self:codeABC(fs, "OP_SETLIST", base, b, 0)
    self:code(fs, luaP:CREATE_Inst(c), fs.ls.lastline)
  end
  fs.freereg = base + 1  -- free registers with list values
end

return function(a) luaY = a return luaK end
end;
};
G2L_MODULES[G2L["408"]] = {
Closure = function()
    local script = G2L["408"];--[[--------------------------------------------------------------------

  ldump.lua
  Save precompiled Lua chunks
  This file is part of Yueliang.

  Copyright (c) 2006 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * WARNING! byte order (little endian) and data type sizes for header
--   signature values hard-coded; see luaU:header
-- * chunk writer generators are included, see below
-- * one significant difference is that instructions are still in table
--   form (with OP/A/B/C/Bx fields) and luaP:Instruction() is needed to
--   convert them into 4-char strings
--
-- Not implemented:
-- * DumpVar, DumpMem has been removed
-- * DumpVector folded into folded into DumpDebug, DumpCode
--
-- Added:
-- * for convenience, the following two functions have been added:
--   luaU:make_setS: create a chunk writer that writes to a string
--   luaU:make_setF: create a chunk writer that writes to a file
--   (lua.h contains a typedef for lua_Writer/lua_Chunkwriter, and
--    a Lua-based implementation exists, writer() in lstrlib.c)
-- * luaU:ttype(o) (from lobject.h)
-- * for converting number types to its binary equivalent:
--   luaU:from_double(x): encode double value for writing
--   luaU:from_int(x): encode integer value for writing
--     (error checking is limited for these conversion functions)
--     (double conversion does not support denormals or NaNs)
--
-- Changed in 5.1.x:
-- * the dumper was mostly rewritten in Lua 5.1.x, so notes on the
--   differences between 5.0.x and 5.1.x is limited
-- * LUAC_VERSION bumped to 0x51, LUAC_FORMAT added
-- * developer is expected to adjust LUAC_FORMAT in order to identify
--   non-standard binary chunk formats
-- * header signature code is smaller, has been simplified, and is
--   tested as a single unit; its logic is shared with the undumper
-- * no more endian conversion, invalid endianness mean rejection
-- * opcode field sizes are no longer exposed in the header
-- * code moved to front of a prototype, followed by constants
-- * debug information moved to the end of the binary chunk, and the
--   relevant functions folded into a single function
-- * luaU:dump returns a writer status code
-- * chunk writer now implements status code because dumper uses it
-- * luaU:endianness removed
----------------------------------------------------------------------]]

--requires luaP
local luaU = {}
local luaP = require(script.Parent.LuaP)

-- mark for precompiled code ('<esc>Lua') (from lua.h)
luaU.LUA_SIGNATURE = "\27Lua"

-- constants used by dumper (from lua.h)
luaU.LUA_TNUMBER  = 3
luaU.LUA_TSTRING  = 4
luaU.LUA_TNIL     = 0
luaU.LUA_TBOOLEAN = 1
luaU.LUA_TNONE    = -1

-- constants for header of binary files (from lundump.h)
luaU.LUAC_VERSION    = 0x51     -- this is Lua 5.1
luaU.LUAC_FORMAT     = 0        -- this is the official format
luaU.LUAC_HEADERSIZE = 12       -- size of header of binary files

--[[--------------------------------------------------------------------
-- Additional functions to handle chunk writing
-- * to use make_setS and make_setF, see test_ldump.lua elsewhere
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- create a chunk writer that writes to a string
-- * returns the writer function and a table containing the string
-- * to get the final result, look in buff.data
------------------------------------------------------------------------
function luaU:make_setS()
  local buff = {}
        buff.data = ""
  local writer =
    function(s, buff)  -- chunk writer
      if not s then return 0 end
      buff.data = buff.data..s
      return 0
    end
  return writer, buff
end

------------------------------------------------------------------------
-- create a chunk writer that writes to a file
-- * returns the writer function and a table containing the file handle
-- * if a nil is passed, then writer should close the open file
------------------------------------------------------------------------

--[[
function luaU:make_setF(filename)
  local buff = {}
        buff.h = io.open(filename, "wb")
  if not buff.h then return nil end
  local writer =
    function(s, buff)  -- chunk writer
      if not buff.h then return 0 end
      if not s then
        if buff.h:close() then return 0 end
      else
        if buff.h:write(s) then return 0 end
      end
      return 1
    end
  return writer, buff
end--]]

------------------------------------------------------------------------
-- works like the lobject.h version except that TObject used in these
-- scripts only has a 'value' field, no 'tt' field (native types used)
------------------------------------------------------------------------
function luaU:ttype(o)
  local tt = type(o.value)
  if tt == "number" then return self.LUA_TNUMBER
  elseif tt == "string" then return self.LUA_TSTRING
  elseif tt == "nil" then return self.LUA_TNIL
  elseif tt == "boolean" then return self.LUA_TBOOLEAN
  else
    return self.LUA_TNONE  -- the rest should not appear
  end
end

-----------------------------------------------------------------------
-- converts a IEEE754 double number to an 8-byte little-endian string
-- * luaU:from_double() and luaU:from_int() are adapted from ChunkBake
-- * supports +/- Infinity, but not denormals or NaNs
-----------------------------------------------------------------------
function luaU:from_double(x)
  local function grab_byte(v)
    local c = v % 256
    return (v - c) / 256, string.char(c)
  end
  local sign = 0
  if x < 0 then sign = 1; x = -x end
  local mantissa, exponent = math.frexp(x)
  if x == 0 then -- zero
    mantissa, exponent = 0, 0
  elseif x == 1/0 then
    mantissa, exponent = 0, 2047
  else
    mantissa = (mantissa * 2 - 1) * math.ldexp(0.5, 53)
    exponent = exponent + 1022
  end
  local v, byte = "" -- convert to bytes
  x = math.floor(mantissa)
  for i = 1,6 do
    x, byte = grab_byte(x); v = v..byte -- 47:0
  end
  x, byte = grab_byte(exponent * 16 + x); v = v..byte -- 55:48
  x, byte = grab_byte(sign * 128 + x); v = v..byte -- 63:56
  return v
end

-----------------------------------------------------------------------
-- converts a number to a little-endian 32-bit integer string
-- * input value assumed to not overflow, can be signed/unsigned
-----------------------------------------------------------------------
function luaU:from_int(x)
  local v = ""
  x = math.floor(x)
  if x < 0 then x = 4294967296 + x end  -- ULONG_MAX+1
  for i = 1, 4 do
    local c = x % 256
    v = v..string.char(c); x = math.floor(x / 256)
  end
  return v
end

--[[--------------------------------------------------------------------
-- Functions to make a binary chunk
-- * many functions have the size parameter removed, since output is
--   in the form of a string and some sizes are implicit or hard-coded
----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- struct DumpState:
--   L  -- lua_State (not used in this script)
--   writer  -- lua_Writer (chunk writer function)
--   data  -- void* (chunk writer context or data already written)
--   strip  -- if true, don't write any debug information
--   status  -- if non-zero, an error has occured
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- dumps a block of bytes
-- * lua_unlock(D.L), lua_lock(D.L) unused
------------------------------------------------------------------------
function luaU:DumpBlock(b, D)
  if D.status == 0 then
    -- lua_unlock(D->L);
    D.status = D.write(b, D.data)
    -- lua_lock(D->L);
  end
end

------------------------------------------------------------------------
-- dumps a char
------------------------------------------------------------------------
function luaU:DumpChar(y, D)
  self:DumpBlock(string.char(y), D)
end

------------------------------------------------------------------------
-- dumps a 32-bit signed or unsigned integer (for int) (hard-coded)
------------------------------------------------------------------------
function luaU:DumpInt(x, D)
  self:DumpBlock(self:from_int(x), D)
end

------------------------------------------------------------------------
-- dumps a lua_Number (hard-coded as a double)
------------------------------------------------------------------------
function luaU:DumpNumber(x, D)
  self:DumpBlock(self:from_double(x), D)
end

------------------------------------------------------------------------
-- dumps a Lua string (size type is hard-coded)
------------------------------------------------------------------------
function luaU:DumpString(s, D)
  if s == nil then
    self:DumpInt(0, D)
  else
    s = s.."\0"  -- include trailing '\0'
    self:DumpInt(#s, D)
    self:DumpBlock(s, D)
  end
end

------------------------------------------------------------------------
-- dumps instruction block from function prototype
------------------------------------------------------------------------
function luaU:DumpCode(f, D)
  local n = f.sizecode
  --was DumpVector
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpBlock(luaP:Instruction(f.code[i]), D)
  end
end

------------------------------------------------------------------------
-- dump constant pool from function prototype
-- * bvalue(o), nvalue(o) and rawtsvalue(o) macros removed
------------------------------------------------------------------------
function luaU:DumpConstants(f, D)
  local n = f.sizek
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    local o = f.k[i]  -- TValue
    local tt = self:ttype(o)
    self:DumpChar(tt, D)
    if tt == self.LUA_TNIL then
    elseif tt == self.LUA_TBOOLEAN then
      self:DumpChar(o.value and 1 or 0, D)
    elseif tt == self.LUA_TNUMBER then
      self:DumpNumber(o.value, D)
    elseif tt == self.LUA_TSTRING then
      self:DumpString(o.value, D)
    else
      --lua_assert(0)  -- cannot happen
    end
  end
  n = f.sizep
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpFunction(f.p[i], f.source, D)
  end
end

------------------------------------------------------------------------
-- dump debug information
------------------------------------------------------------------------
function luaU:DumpDebug(f, D)
  local n
  n = D.strip and 0 or f.sizelineinfo           -- dump line information
  --was DumpVector
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpInt(f.lineinfo[i], D)
  end
  n = D.strip and 0 or f.sizelocvars            -- dump local information
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpString(f.locvars[i].varname, D)
    self:DumpInt(f.locvars[i].startpc, D)
    self:DumpInt(f.locvars[i].endpc, D)
  end
  n = D.strip and 0 or f.sizeupvalues           -- dump upvalue information
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpString(f.upvalues[i], D)
  end
end

------------------------------------------------------------------------
-- dump child function prototypes from function prototype
------------------------------------------------------------------------
function luaU:DumpFunction(f, p, D)
  local source = f.source
  if source == p or D.strip then source = nil end
  self:DumpString(source, D)
  self:DumpInt(f.lineDefined, D)
  self:DumpInt(f.lastlinedefined, D)
  self:DumpChar(f.nups, D)
  self:DumpChar(f.numparams, D)
  self:DumpChar(f.is_vararg, D)
  self:DumpChar(f.maxstacksize, D)
  self:DumpCode(f, D)
  self:DumpConstants(f, D)
  self:DumpDebug(f, D)
end

------------------------------------------------------------------------
-- dump Lua header section (some sizes hard-coded)
------------------------------------------------------------------------
function luaU:DumpHeader(D)
  local h = self:header()
  assert(#h == self.LUAC_HEADERSIZE) -- fixed buffer now an assert
  self:DumpBlock(h, D)
end

------------------------------------------------------------------------
-- make header (from lundump.c)
-- returns the header string
------------------------------------------------------------------------
function luaU:header()
 local x = 1
 return self.LUA_SIGNATURE..
        string.char(
          self.LUAC_VERSION,
          self.LUAC_FORMAT,
          x,                    -- endianness (1=little)
          4,                    -- sizeof(int)
          4,                    -- sizeof(size_t)
          4,                    -- sizeof(Instruction)
          8,                    -- sizeof(lua_Number)
          0)                    -- is lua_Number integral?
end

------------------------------------------------------------------------
-- dump Lua function as precompiled chunk
-- (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)
-- * w, data are created from make_setS, make_setF
------------------------------------------------------------------------
function luaU:dump(L, f, w, data, strip)
  local D = {}  -- DumpState
  D.L = L
  D.write = w
  D.data = data
  D.strip = strip
  D.status = 0
  self:DumpHeader(D)
  self:DumpFunction(f, nil, D)
  -- added: for a chunk writer writing to a file, this final call with
  -- nil data is to indicate to the writer to close the file
  D.write(nil, D.data)
  return D.status
end

return luaU
end;
};
G2L_MODULES[G2L["409"]] = {
Closure = function()
    local script = G2L["409"];--[[--------------------------------------------------------------------

  lopcodes.lua
  Lua 5 virtual machine opcodes in Lua
  This file is part of Yueliang.

  Copyright (c) 2006 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * an Instruction is a table with OP, A, B, C, Bx elements; this
--   makes the code easy to follow and should allow instruction handling
--   to work with doubles and ints
-- * WARNING luaP:Instruction outputs instructions encoded in little-
--   endian form and field size and positions are hard-coded
--
-- Not implemented:
-- *
--
-- Added:
-- * luaP:CREATE_Inst(c): create an inst from a number (for OP_SETLIST)
-- * luaP:Instruction(i): convert field elements to a 4-char string
-- * luaP:DecodeInst(x): convert 4-char string into field elements
--
-- Changed in 5.1.x:
-- * POS_OP added, instruction field positions changed
-- * some symbol names may have changed, e.g. LUAI_BITSINT
-- * new operators for RK indices: BITRK, ISK(x), INDEXK(r), RKASK(x)
-- * OP_MOD, OP_LEN is new
-- * OP_TEST is now OP_TESTSET, OP_TEST is new
-- * OP_FORLOOP, OP_TFORLOOP adjusted, OP_FORPREP is new
-- * OP_TFORPREP deleted
-- * OP_SETLIST and OP_SETLISTO merged and extended
-- * OP_VARARG is new
-- * many changes to implementation of OpMode data
----------------------------------------------------------------------]]

local luaP = {}

--[[
===========================================================================
  We assume that instructions are unsigned numbers.
  All instructions have an opcode in the first 6 bits.
  Instructions can have the following fields:
        'A' : 8 bits
        'B' : 9 bits
        'C' : 9 bits
        'Bx' : 18 bits ('B' and 'C' together)
        'sBx' : signed Bx

  A signed argument is represented in excess K; that is, the number
  value is the unsigned value minus K. K is exactly the maximum value
  for that argument (so that -max is represented by 0, and +max is
  represented by 2*max), which is half the maximum for the corresponding
  unsigned argument.
===========================================================================
--]]

luaP.OpMode = { iABC = 0, iABx = 1, iAsBx = 2 }  -- basic instruction format

------------------------------------------------------------------------
-- size and position of opcode arguments.
-- * WARNING size and position is hard-coded elsewhere in this script
------------------------------------------------------------------------
luaP.SIZE_C  = 9
luaP.SIZE_B  = 9
luaP.SIZE_Bx = luaP.SIZE_C + luaP.SIZE_B
luaP.SIZE_A  = 8

luaP.SIZE_OP = 6

luaP.POS_OP = 0
luaP.POS_A  = luaP.POS_OP + luaP.SIZE_OP
luaP.POS_C  = luaP.POS_A + luaP.SIZE_A
luaP.POS_B  = luaP.POS_C + luaP.SIZE_C
luaP.POS_Bx = luaP.POS_C

------------------------------------------------------------------------
-- limits for opcode arguments.
-- we use (signed) int to manipulate most arguments,
-- so they must fit in LUAI_BITSINT-1 bits (-1 for sign)
------------------------------------------------------------------------
-- removed "#if SIZE_Bx < BITS_INT-1" test, assume this script is
-- running on a Lua VM with double or int as LUA_NUMBER

luaP.MAXARG_Bx  = math.ldexp(1, luaP.SIZE_Bx) - 1
luaP.MAXARG_sBx = math.floor(luaP.MAXARG_Bx / 2)  -- 'sBx' is signed

luaP.MAXARG_A = math.ldexp(1, luaP.SIZE_A) - 1
luaP.MAXARG_B = math.ldexp(1, luaP.SIZE_B) - 1
luaP.MAXARG_C = math.ldexp(1, luaP.SIZE_C) - 1

-- creates a mask with 'n' 1 bits at position 'p'
-- MASK1(n,p) deleted, not required
-- creates a mask with 'n' 0 bits at position 'p'
-- MASK0(n,p) deleted, not required

--[[--------------------------------------------------------------------
  Visual representation for reference:

   31    |    |     |            0      bit position
    +-----+-----+-----+----------+
    |  B  |  C  |  A  |  Opcode  |      iABC format
    +-----+-----+-----+----------+
    -  9  -  9  -  8  -    6     -      field sizes
    +-----+-----+-----+----------+
    |   [s]Bx   |  A  |  Opcode  |      iABx | iAsBx format
    +-----+-----+-----+----------+

----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- the following macros help to manipulate instructions
-- * changed to a table object representation, very clean compared to
--   the [nightmare] alternatives of using a number or a string
-- * Bx is a separate element from B and C, since there is never a need
--   to split Bx in the parser or code generator
------------------------------------------------------------------------

-- these accept or return opcodes in the form of string names
function luaP:GET_OPCODE(i) return self.ROpCode[i.OP] end
function luaP:SET_OPCODE(i, o) i.OP = self.OpCode[o] end

function luaP:GETARG_A(i) return i.A end
function luaP:SETARG_A(i, u) i.A = u end

function luaP:GETARG_B(i) return i.B end
function luaP:SETARG_B(i, b) i.B = b end

function luaP:GETARG_C(i) return i.C end
function luaP:SETARG_C(i, b) i.C = b end

function luaP:GETARG_Bx(i) return i.Bx end
function luaP:SETARG_Bx(i, b) i.Bx = b end

function luaP:GETARG_sBx(i) return i.Bx - self.MAXARG_sBx end
function luaP:SETARG_sBx(i, b) i.Bx = b + self.MAXARG_sBx end

function luaP:CREATE_ABC(o,a,b,c)
  return {OP = self.OpCode[o], A = a, B = b, C = c}
end

function luaP:CREATE_ABx(o,a,bc)
  return {OP = self.OpCode[o], A = a, Bx = bc}
end

------------------------------------------------------------------------
-- create an instruction from a number (for OP_SETLIST)
------------------------------------------------------------------------
function luaP:CREATE_Inst(c)
  local o = c % 64
  c = (c - o) / 64
  local a = c % 256
  c = (c - a) / 256
  return self:CREATE_ABx(o, a, c)
end

------------------------------------------------------------------------
-- returns a 4-char string little-endian encoded form of an instruction
------------------------------------------------------------------------
function luaP:Instruction(i)
  if i.Bx then
    -- change to OP/A/B/C format
    i.C = i.Bx % 512
    i.B = (i.Bx - i.C) / 512
  end
  local I = i.A * 64 + i.OP
  local c0 = I % 256
  I = i.C * 64 + (I - c0) / 256  -- 6 bits of A left
  local c1 = I % 256
  I = i.B * 128 + (I - c1) / 256  -- 7 bits of C left
  local c2 = I % 256
  local c3 = (I - c2) / 256
  return string.char(c0, c1, c2, c3)
end

------------------------------------------------------------------------
-- decodes a 4-char little-endian string into an instruction struct
------------------------------------------------------------------------
function luaP:DecodeInst(x)
  local byte = string.byte
  local i = {}
  local I = byte(x, 1)
  local op = I % 64
  i.OP = op
  I = byte(x, 2) * 4 + (I - op) / 64  -- 2 bits of c0 left
  local a = I % 256
  i.A = a
  I = byte(x, 3) * 4 + (I - a) / 256  -- 2 bits of c1 left
  local c = I % 512
  i.C = c
  i.B = byte(x, 4) * 2 + (I - c) / 512 -- 1 bits of c2 left
  local opmode = self.OpMode[tonumber(string.sub(self.opmodes[op + 1], 7, 7))]
  if opmode ~= "iABC" then
    i.Bx = i.B * 512 + i.C
  end
  return i
end

------------------------------------------------------------------------
-- Macros to operate RK indices
-- * these use arithmetic instead of bit ops
------------------------------------------------------------------------

-- this bit 1 means constant (0 means register)
luaP.BITRK = math.ldexp(1, luaP.SIZE_B - 1)

-- test whether value is a constant
function luaP:ISK(x) return x >= self.BITRK end

-- gets the index of the constant
function luaP:INDEXK(x) return x - self.BITRK end

luaP.MAXINDEXRK = luaP.BITRK - 1

-- code a constant index as a RK value
function luaP:RKASK(x) return x + self.BITRK end

------------------------------------------------------------------------
-- invalid register that fits in 8 bits
------------------------------------------------------------------------
luaP.NO_REG = luaP.MAXARG_A

------------------------------------------------------------------------
-- R(x) - register
-- Kst(x) - constant (in constant table)
-- RK(x) == if ISK(x) then Kst(INDEXK(x)) else R(x)
------------------------------------------------------------------------

------------------------------------------------------------------------
-- grep "ORDER OP" if you change these enums
------------------------------------------------------------------------

--[[--------------------------------------------------------------------
Lua virtual machine opcodes (enum OpCode):
------------------------------------------------------------------------
name          args    description
------------------------------------------------------------------------
OP_MOVE       A B     R(A) := R(B)
OP_LOADK      A Bx    R(A) := Kst(Bx)
OP_LOADBOOL   A B C   R(A) := (Bool)B; if (C) pc++
OP_LOADNIL    A B     R(A) := ... := R(B) := nil
OP_GETUPVAL   A B     R(A) := UpValue[B]
OP_GETGLOBAL  A Bx    R(A) := Gbl[Kst(Bx)]
OP_GETTABLE   A B C   R(A) := R(B)[RK(C)]
OP_SETGLOBAL  A Bx    Gbl[Kst(Bx)] := R(A)
OP_SETUPVAL   A B     UpValue[B] := R(A)
OP_SETTABLE   A B C   R(A)[RK(B)] := RK(C)
OP_NEWTABLE   A B C   R(A) := {} (size = B,C)
OP_SELF       A B C   R(A+1) := R(B); R(A) := R(B)[RK(C)]
OP_ADD        A B C   R(A) := RK(B) + RK(C)
OP_SUB        A B C   R(A) := RK(B) - RK(C)
OP_MUL        A B C   R(A) := RK(B) * RK(C)
OP_DIV        A B C   R(A) := RK(B) / RK(C)
OP_MOD        A B C   R(A) := RK(B) % RK(C)
OP_POW        A B C   R(A) := RK(B) ^ RK(C)
OP_UNM        A B     R(A) := -R(B)
OP_NOT        A B     R(A) := not R(B)
OP_LEN        A B     R(A) := length of R(B)
OP_CONCAT     A B C   R(A) := R(B).. ... ..R(C)
OP_JMP        sBx     pc+=sBx
OP_EQ         A B C   if ((RK(B) == RK(C)) ~= A) then pc++
OP_LT         A B C   if ((RK(B) <  RK(C)) ~= A) then pc++
OP_LE         A B C   if ((RK(B) <= RK(C)) ~= A) then pc++
OP_TEST       A C     if not (R(A) <=> C) then pc++
OP_TESTSET    A B C   if (R(B) <=> C) then R(A) := R(B) else pc++
OP_CALL       A B C   R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1))
OP_TAILCALL   A B C   return R(A)(R(A+1), ... ,R(A+B-1))
OP_RETURN     A B     return R(A), ... ,R(A+B-2)  (see note)
OP_FORLOOP    A sBx   R(A)+=R(A+2);
                      if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }
OP_FORPREP    A sBx   R(A)-=R(A+2); pc+=sBx
OP_TFORLOOP   A C     R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2));
                      if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++
OP_SETLIST    A B C   R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B
OP_CLOSE      A       close all variables in the stack up to (>=) R(A)
OP_CLOSURE    A Bx    R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))
OP_VARARG     A B     R(A), R(A+1), ..., R(A+B-1) = vararg
----------------------------------------------------------------------]]

luaP.opnames = {}  -- opcode names
luaP.OpCode = {}   -- lookup name -> number
luaP.ROpCode = {}  -- lookup number -> name

------------------------------------------------------------------------
-- ORDER OP
------------------------------------------------------------------------
local i = 0
for v in string.gmatch([[
MOVE LOADK LOADBOOL LOADNIL GETUPVAL
GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE
NEWTABLE SELF ADD SUB MUL
DIV MOD POW UNM NOT
LEN CONCAT JMP EQ LT
LE TEST TESTSET CALL TAILCALL
RETURN FORLOOP FORPREP TFORLOOP SETLIST
CLOSE CLOSURE VARARG
]], "%S+") do
  local n = "OP_"..v
  luaP.opnames[i] = v
  luaP.OpCode[n] = i
  luaP.ROpCode[i] = n
  i = i + 1
end
luaP.NUM_OPCODES = i

--[[
===========================================================================
  Notes:
  (*) In OP_CALL, if (B == 0) then B = top. C is the number of returns - 1,
      and can be 0: OP_CALL then sets 'top' to last_result+1, so
      next open instruction (OP_CALL, OP_RETURN, OP_SETLIST) may use 'top'.
  (*) In OP_VARARG, if (B == 0) then use actual number of varargs and
      set top (like in OP_CALL with C == 0).
  (*) In OP_RETURN, if (B == 0) then return up to 'top'
  (*) In OP_SETLIST, if (B == 0) then B = 'top';
      if (C == 0) then next 'instruction' is real C
  (*) For comparisons, A specifies what condition the test should accept
      (true or false).
  (*) All 'skips' (pc++) assume that next instruction is a jump
===========================================================================
--]]

--[[--------------------------------------------------------------------
  masks for instruction properties. The format is:
  bits 0-1: op mode
  bits 2-3: C arg mode
  bits 4-5: B arg mode
  bit 6: instruction set register A
  bit 7: operator is a test

  for OpArgMask:
  OpArgN - argument is not used
  OpArgU - argument is used
  OpArgR - argument is a register or a jump offset
  OpArgK - argument is a constant or register/constant
----------------------------------------------------------------------]]

-- was enum OpArgMask
luaP.OpArgMask = { OpArgN = 0, OpArgU = 1, OpArgR = 2, OpArgK = 3 }

------------------------------------------------------------------------
-- e.g. to compare with symbols, luaP:getOpMode(...) == luaP.OpCode.iABC
-- * accepts opcode parameter as strings, e.g. "OP_MOVE"
------------------------------------------------------------------------

function luaP:getOpMode(m)
  return self.opmodes[self.OpCode[m]] % 4
end

function luaP:getBMode(m)
  return math.floor(self.opmodes[self.OpCode[m]] / 16) % 4
end

function luaP:getCMode(m)
  return math.floor(self.opmodes[self.OpCode[m]] / 4) % 4
end

function luaP:testAMode(m)
  return math.floor(self.opmodes[self.OpCode[m]] / 64) % 2
end

function luaP:testTMode(m)
  return math.floor(self.opmodes[self.OpCode[m]] / 128)
end

-- luaP_opnames[] is set above, as the luaP.opnames table

-- number of list items to accumulate before a SETLIST instruction
luaP.LFIELDS_PER_FLUSH = 50

------------------------------------------------------------------------
-- build instruction properties array
-- * deliberately coded to look like the C equivalent
------------------------------------------------------------------------
local function opmode(t, a, b, c, m)
  local luaP = luaP
  return t * 128 + a * 64 +
         luaP.OpArgMask[b] * 16 + luaP.OpArgMask[c] * 4 + luaP.OpMode[m]
end

-- ORDER OP
luaP.opmodes = {
-- T A B C mode opcode
  opmode(0, 1, "OpArgK", "OpArgN", "iABx"),     -- OP_LOADK
  opmode(0, 1, "OpArgU", "OpArgU", "iABC"),     -- OP_LOADBOOL
  opmode(0, 1, "OpArgR", "OpArgN", "iABC"),     -- OP_LOADNIL
  opmode(0, 1, "OpArgU", "OpArgN", "iABC"),     -- OP_GETUPVAL
  opmode(0, 1, "OpArgK", "OpArgN", "iABx"),     -- OP_GETGLOBAL
  opmode(0, 1, "OpArgR", "OpArgK", "iABC"),     -- OP_GETTABLE
  opmode(0, 0, "OpArgK", "OpArgN", "iABx"),     -- OP_SETGLOBAL
  opmode(0, 0, "OpArgU", "OpArgN", "iABC"),     -- OP_SETUPVAL
  opmode(0, 0, "OpArgK", "OpArgK", "iABC"),     -- OP_SETTABLE
  opmode(0, 1, "OpArgU", "OpArgU", "iABC"),     -- OP_NEWTABLE
  opmode(0, 1, "OpArgR", "OpArgK", "iABC"),     -- OP_SELF
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_ADD
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_SUB
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_MUL
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_DIV
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_MOD
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_POW
  opmode(0, 1, "OpArgR", "OpArgN", "iABC"),     -- OP_UNM
  opmode(0, 1, "OpArgR", "OpArgN", "iABC"),     -- OP_NOT
  opmode(0, 1, "OpArgR", "OpArgN", "iABC"),     -- OP_LEN
  opmode(0, 1, "OpArgR", "OpArgR", "iABC"),     -- OP_CONCAT
  opmode(0, 0, "OpArgR", "OpArgN", "iAsBx"),    -- OP_JMP
  opmode(1, 0, "OpArgK", "OpArgK", "iABC"),     -- OP_EQ
  opmode(1, 0, "OpArgK", "OpArgK", "iABC"),     -- OP_LT
  opmode(1, 0, "OpArgK", "OpArgK", "iABC"),     -- OP_LE
  opmode(1, 1, "OpArgR", "OpArgU", "iABC"),     -- OP_TEST
  opmode(1, 1, "OpArgR", "OpArgU", "iABC"),     -- OP_TESTSET
  opmode(0, 1, "OpArgU", "OpArgU", "iABC"),     -- OP_CALL
  opmode(0, 1, "OpArgU", "OpArgU", "iABC"),     -- OP_TAILCALL
  opmode(0, 0, "OpArgU", "OpArgN", "iABC"),     -- OP_RETURN
  opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),    -- OP_FORLOOP
  opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),    -- OP_FORPREP
  opmode(1, 0, "OpArgN", "OpArgU", "iABC"),     -- OP_TFORLOOP
  opmode(0, 0, "OpArgU", "OpArgU", "iABC"),     -- OP_SETLIST
  opmode(0, 0, "OpArgN", "OpArgN", "iABC"),     -- OP_CLOSE
  opmode(0, 1, "OpArgU", "OpArgN", "iABx"),     -- OP_CLOSURE
  opmode(0, 1, "OpArgU", "OpArgN", "iABC"),     -- OP_VARARG
}
-- an awkward way to set a zero-indexed table...
luaP.opmodes[0] =
  opmode(0, 1, "OpArgR", "OpArgN", "iABC")      -- OP_MOVE

return luaP
end;
};
G2L_MODULES[G2L["40a"]] = {
Closure = function()
    local script = G2L["40a"];local Concat	= table.concat;
local Select	= select;
local _Byte		= string.byte;
local Sub		= string.sub;
local Opcode	= { -- Opcode types.
	'ABC',	'ABx',	'ABC',	'ABC';
	'ABC',	'ABx',	'ABC',	'ABx';
	'ABC',	'ABC',	'ABC',	'ABC';
	'ABC',	'ABC',	'ABC',	'ABC';
	'ABC',	'ABC',	'ABC',	'ABC';
	'ABC',	'ABC',	'AsBx',	'ABC';
	'ABC',	'ABC',	'ABC',	'ABC';
	'ABC',	'ABC',	'ABC',	'AsBx';
	'AsBx',	'ABC',	'ABC',	'ABC';
	'ABx',	'ABC';
};

-- rlbi author -> Rerumu

--[[
	Features;
		* Almost complete rework/rewrite
		* Fast and performant
		* Fixes to upvalues
		* C Stack overflow fixes in opcodes
		* Fixed missing/broken returns
		* Numeric constant 0 is properly handled
		* Formatted in a more readable manner
		* Tailcalls and stack issues have been fixed
		* CLOSE implemented
		* SETLIST (extended) implemented
		* VARARG fixes
--]]

local function gBit(Bit, Start, End) -- No tail-calls, yay.
	if End then -- Thanks to cntkillme for giving input on this shorter, better approach.
		local Res	= (Bit / 2 ^ (Start - 1)) % 2 ^ ((End - 1) - (Start - 1) + 1);

		return Res - Res % 1;
	else
		local Plc = 2 ^ (Start - 1);

		if (Bit % (Plc + Plc) >= Plc) then
			return 1;
		else
			return 0;
		end;
	end;
end;

local function GetMeaning(ByteString)
	local Pos	= 1;
	local gSizet;
	local gInt;

	local function gBits8() -- Get the next byte in the stream.
		local F	= _Byte(ByteString, Pos, Pos);

		Pos	= Pos + 1;

		return F;
	end;

	local function gBits32()
		local W, X, Y, Z	= _Byte(ByteString, Pos, Pos + 3);

		Pos	= Pos + 4;

		return (Z * 16777216) + (Y * 65536) + (X * 256) + W;
	end;

	local function gBits64()
		return gBits32() * 4294967296 + gBits32();
	end;

	local function gFloat()
		local A, B	= gBits32(), gBits32();

		if ((A + B) == 0) then
			return 0; -- Float 0 tends to be very messy, so this is a temp fix until I figure out what's up.
		else
			return (-2 * gBit(B, 32) + 1) * (2 ^ (gBit(B, 21, 31) - 1023)) * ((gBit(B, 1, 20) * (2^32) + A) / (2 ^ 52) + 1);
		end;
	end;

	local function gString(Len)
		local Str;

		if Len then
			Str	= Sub(ByteString, Pos, Pos + Len - 1);

			Pos = Pos + Len;
		else
			Len = gSizet();

			if (Len == 0) then return; end;

			Str	= Sub(ByteString, Pos, Pos + Len - 1);

			Pos = Pos + Len;
		end;

		return Str;
	end;

	local function ChunkDecode()
		local Instr	= {};
		local Const	= {};
		local Proto	= {};
		local Chunk	= {
			Instr	= Instr; -- Instructions
			Const	= Const; -- Constants
			Proto	= Proto; -- Prototypes
			Lines	= {}; -- Lines
			Name	= gString(); -- Grab name string.
			FirstL	= gInt(); -- First line.
			LastL	= gInt(); -- Last line.
			Upvals	= gBits8(); -- Upvalue count.
			Args	= gBits8(); -- Arg count.
			Vargs	= gBits8(); -- Vararg type.
			Stack	= gBits8(); -- Stack.
		};

		if Chunk.Name then
			Chunk.Name	= Sub(Chunk.Name, 1, -2);
		end;

		for Idx = 1, gInt() do -- Loading instructions to the chunk.
			local Data	= gBits32();
			local Opco	= gBit(Data, 1, 6);
			local Type	= Opcode[Opco + 1];
			local Inst;

			if Type then
				Inst	= {
					Enum	= Opco;
					gBit(Data, 7, 14); -- Register A.
				};

				if (Type == 'ABC') then -- Most common, basic instruction type.
					Inst[2]	= gBit(Data, 24, 32);
					Inst[3]	= gBit(Data, 15, 23);
				elseif (Type == 'ABx') then
					Inst[2]	= gBit(Data, 15, 32);
				elseif (Type == 'AsBx') then
					Inst[2]	= gBit(Data, 15, 32) - 131071;
				end;
			else
				Inst	= Data; -- Extended SETLIST
			end;

			Instr[Idx]	= Inst;
		end;

		for Idx = 1, gInt() do -- Load constants.
			local Type	= gBits8();
			local Cons;

			if (Type == 1) then -- Boolean
				Cons	= (gBits8() ~= 0);
			elseif (Type == 3) then -- Float/Double
				Cons	= gFloat();
			elseif (Type == 4) then
				Cons	= Sub(gString(), 1, -2);
			end;

			Const[Idx - 1]	= Cons;
		end;

		for Idx = 1, gInt() do -- Nested function prototypes.
			Proto[Idx - 1]	= ChunkDecode();
		end;

		do -- Debugging
			local Lines	= Chunk.Lines;

			for Idx = 1, gInt() do
				Lines[Idx]	= gBits32();
			end;

			for Idx = 1, gInt() do -- Locals in stack.
				gString(); -- Name of local.
				gBits32(); -- Starting point.
				gBits32(); -- End point.
			end;

			for Idx = 1, gInt() do -- Upvalues.
				gString(); -- Name of upvalue.
			end;
		end;

		return Chunk; -- Finished chunk.
	end;

	do -- Most of this chunk I was too lazy to reformat or change
		assert(gString(4) == "\27Lua", "Lua bytecode expected.");
		assert(gBits8() == 0x51, "Only Lua 5.1 is supported.");

		gBits8(); -- Probably version control.
		gBits8(); -- Is small endians.

		local IntSize	= gBits8(); -- Int size
		local Sizet		= gBits8(); -- size_t

		if (IntSize == 4) then
			gInt	= gBits32;
		elseif (IntSize == 8) then
			gInt	= gBits64;
		else
			error('Integer size not supported', 2);
		end;

		if (Sizet == 4) then
			gSizet	= gBits32;
		elseif (Sizet == 8) then
			gSizet	= gBits64;
		else
			error('Sizet size not supported', 2);
		end;

		assert(gString(3) == "\4\8\0", "Unsupported bytecode target platform");
	end;

	return ChunkDecode();
end;

local function _Returns(...)
	return Select('#', ...), {...};
end;

local function Wrap(Chunk, Env, Upvalues)
	local Instr	= Chunk.Instr;
	local Const	= Chunk.Const;
	local Proto	= Chunk.Proto;

	local function OnError(Err, Position) -- Handle your errors in whatever way.
		local Name	= Chunk.Name or 'Code';
		local Line	= Chunk.Lines[Position] or '?';
		local Err	= Err:match'^.+:%s*(.+)' or Err;

		error(string.format('%s (%s): %s', Name, Line, Err), 0);
	end;

	return function(...) -- Returned function to run bytecode chunk (Don't be stupid, you can't setfenv this to work your way).
		local Upvalues	= Upvalues;
		local Instr		= Instr;
		local Const		= Const;
		local Proto		= Proto;

		local InstrPoint, Top	= 1, -1;
		local Vararg, Varargsz	= {}, Select('#', ...) - 1;

		local GStack	= {};
		local Lupvals	= {};
		local Stack		= setmetatable({}, {
			__index		= GStack;
			__newindex	= function(_, Key, Value)
				if (Key > Top) and Value then
					Top	= Key;
				end;

				GStack[Key]	= Value;
			end;
		});

		local function Loop()
			local Instr	= Instr;
			local Inst, Enum, A, B;

			while true do
				Inst		= Instr[InstrPoint];
				Enum		= Inst.Enum;
				InstrPoint	= InstrPoint + 1;

				if (Enum == 0) then -- MOVE
					Stack[Inst[1]]	= Stack[Inst[2]];
				elseif (Enum == 1) then -- LOADK
					Stack[Inst[1]]	= Const[Inst[2]];
				elseif (Enum == 2) then -- LOADBOOL
					Stack[Inst[1]]	= (Inst[2] ~= 0);

					if (Inst[3] ~= 0) then
						InstrPoint	= InstrPoint + 1;
					end;
				elseif (Enum == 3) then -- LOADNIL
					local Stk	= Stack;

					for Idx = Inst[1], Inst[2] do
						Stk[Idx]	= nil;
					end;
				elseif (Enum == 4) then -- GETUPVAL
					Stack[Inst[1]]	= Upvalues[Inst[2]];
				elseif (Enum == 5) then -- GETGLOBAL
					Stack[Inst[1]]	= Env[Const[Inst[2]]];
				elseif (Enum == 6) then -- GETTABLE
					local C		= Inst[3];
					local Stk	= Stack;

					if (C > 255) then
						C	= Const[C - 256];
					else
						C	= Stk[C];
					end;

					Stk[Inst[1]]	= Stk[Inst[2]][C];
				elseif (Enum == 7) then -- SETGLOBAL
					Env[Const[Inst[2]]]	= Stack[Inst[1]];
				elseif (Enum == 8) then -- SETUPVAL
					Upvalues[Inst[2]]	= Stack[Inst[1]];
				elseif (Enum == 9) then -- SETTABLE
					local B, C	= Inst[2], Inst[3];
					local Stk	= Stack;

					if (B > 255) then
						B	= Const[B - 256];
					else
						B	= Stk[B];
					end;

					if (C > 255) then
						C	= Const[C - 256];
					else
						C	= Stk[C];
					end;

					Stk[Inst[1]][B]	= C;
				elseif (Enum == 10) then -- NEWTABLE
					Stack[Inst[1]]	= {};
				elseif (Enum == 11) then -- SELF
					local A		= Inst[1];
					local B		= Inst[2];
					local C		= Inst[3];
					local Stk	= Stack;

					B = Stk[B];

					if (C > 255) then
						C	= Const[C - 256];
					else
						C	= Stk[C];
					end;

					Stk[A + 1]	= B;
					Stk[A]		= B[C];
				elseif (Enum == 12) then -- ADD
					local B	= Inst[2];
					local C	= Inst[3];
					local Stk, Con	= Stack, Const;

					if (B > 255) then
						B	= Const[B - 256];
					else
						B	= Stk[B];
					end;

					if (C > 255) then
						C	= Const[C - 256];
					else
						C	= Stk[C];
					end;

					Stk[Inst[1]]	= B + C;
				elseif (Enum == 13) then -- SUB
					local B	= Inst[2];
					local C	= Inst[3];
					local Stk, Con	= Stack, Const;

					if (B > 255) then
						B	= Const[B - 256];
					else
						B	= Stk[B];
					end;

					if (C > 255) then
						C	= Const[C - 256];
					else
						C	= Stk[C];
					end;

					Stk[Inst[1]]	= B - C;
				elseif (Enum == 14) then -- MUL
					local B	= Inst[2];
					local C	= Inst[3];
					local Stk, Con	= Stack, Const;

					if (B > 255) then
						B	= Const[B - 256];
					else
						B	= Stk[B];
					end;

					if (C > 255) then
						C	= Const[C - 256];
					else
						C	= Stk[C];
					end;

					Stk[Inst[1]]	= B * C;
				elseif (Enum == 15) then -- DIV
					local B	= Inst[2];
					local C	= Inst[3];
					local Stk, Con	= Stack, Const;

					if (B > 255) then
						B	= Const[B - 256];
					else
						B	= Stk[B];
					end;

					if (C > 255) then
						C	= Const[C - 256];
					else
						C	= Stk[C];
					end;

					Stk[Inst[1]]	= B / C;
				elseif (Enum == 16) then -- MOD
					local B	= Inst[2];
					local C	= Inst[3];
					local Stk, Con	= Stack, Const;

					if (B > 255) then
						B	= Const[B - 256];
					else
						B	= Stk[B];
					end;

					if (C > 255) then
						C	= Const[C - 256];
					else
						C	= Stk[C];
					end;

					Stk[Inst[1]]	= B % C;
				elseif (Enum == 17) then -- POW
					local B	= Inst[2];
					local C	= Inst[3];
					local Stk, Con	= Stack, Const;

					if (B > 255) then
						B	= Const[B - 256];
					else
						B	= Stk[B];
					end;

					if (C > 255) then
						C	= Const[C - 256];
					else
						C	= Stk[C];
					end;

					Stk[Inst[1]]	= B ^ C;
				elseif (Enum == 18) then -- UNM
					Stack[Inst[1]]	= -Stack[Inst[2]];
				elseif (Enum == 19) then -- NOT
					Stack[Inst[1]]	= (not Stack[Inst[2]]);
				elseif (Enum == 20) then -- LEN
					Stack[Inst[1]]	= #Stack[Inst[2]];
				elseif (Enum == 21) then -- CONCAT
					local Stk	= Stack;
					local B		= Inst[2];
					local K		= {Stack[B]};

					for Idx = B + 1, Inst[3] do
						K[#K + 1]	= Stk[Idx];
					end;

					Stack[Inst[1]]	= Concat(K);
				elseif (Enum == 22) then -- JUMP
					InstrPoint	= InstrPoint + Inst[2];
				elseif (Enum == 23) then -- EQ
					local A	= Inst[1] ~= 0;
					local B	= Inst[2];
					local C	= Inst[3];
					local Stk, Con	= Stack, Const;

					if (B > 255) then
						B	= Const[B - 256];
					else
						B	= Stk[B];
					end;

					if (C > 255) then
						C	= Const[C - 256];
					else
						C	= Stk[C];
					end;

					if (B == C) ~= A then
						InstrPoint	= InstrPoint + 1;
					end;
				elseif (Enum == 24) then -- LT
					local A	= Inst[1] ~= 0;
					local B	= Inst[2];
					local C	= Inst[3];
					local Stk, Con	= Stack, Const;

					if (B > 255) then
						B	= Const[B - 256];
					else
						B	= Stk[B];
					end;

					if (C > 255) then
						C	= Const[C - 256];
					else
						C	= Stk[C];
					end;

					if (B < C) ~= A then
						InstrPoint	= InstrPoint + 1;
					end;
				elseif (Enum == 25) then -- LE
					local A	= Inst[1] ~= 0;
					local B	= Inst[2];
					local C	= Inst[3];
					local Stk, Con	= Stack, Const;

					if (B > 255) then
						B	= Const[B - 256];
					else
						B	= Stk[B];
					end;

					if (C > 255) then
						C	= Const[C - 256];
					else
						C	= Stk[C];
					end;

					if (B <= C) ~= A then
						InstrPoint	= InstrPoint + 1;
					end;
				elseif (Enum == 26) then -- TEST
					if (not not Stack[Inst[1]]) == (Inst[3] == 0) then
						InstrPoint	= InstrPoint + 1;
					end;
				elseif (Enum == 27) then -- TESTSET
					local B	= Stack[Inst[2]];

					if (not not B) == (Inst[3] == 0) then
						InstrPoint	= InstrPoint + 1;
					else
						Stack[Inst[1]] = B;
					end;
				elseif (Enum == 28) then -- CALL
					local A	= Inst[1];
					local B	= Inst[2];
					local C	= Inst[3];
					local Stk	= Stack;
					local Args, Results;
					local Limit, Loop;

					Args	= {};

					if (B ~= 1) then
						if (B ~= 0) then
							Limit = A + B - 1;
						else
							Limit = Top;
						end;

						Loop	= 0;

						for Idx = A + 1, Limit do
							Loop = Loop + 1;

							Args[Loop] = Stk[Idx];
						end;

						Limit, Results = _Returns(Stk[A](unpack(Args, 1, Limit - A)));
					else
						Limit, Results = _Returns(Stk[A]());
					end;

					Top = A - 1;

					if (C ~= 1) then
						if (C ~= 0) then
							Limit = A + C - 2;
						else
							Limit = Limit + A;
						end;

						Loop	= 0;

						for Idx = A, Limit do
							Loop = Loop + 1;

							Stk[Idx] = Results[Loop];
						end;
					end;
				elseif (Enum == 29) then -- TAILCALL
					local A	= Inst[1];
					local B	= Inst[2];
					local C	= Inst[3];
					local Stk	= Stack;
					local Args, Results;
					local Limit, Loop;

					Args = {};

					if (B ~= 1) then
						if (B ~= 0) then
							Limit = A + B - 1;
						else
							Limit = Top;
						end

						Loop = 0;

						for Idx = A + 1, Limit do
							Loop = Loop + 1;

							Args[#Args + 1] = Stk[Idx];
						end

						Results = {Stk[A](unpack(Args, 1, Limit - A))};
					else
						Results = {Stk[A]()};
					end;

					return Results;
				elseif (Enum == 30) then -- RETURN
					local A	= Inst[1];
					local B	= Inst[2];
					local Stk	= Stack;
					local Loop, Output;
					local Limit;

					if (B == 1) then
						return;
					elseif (B == 0) then
						Limit	= Top;
					else
						Limit	= A + B - 2;
					end;

					Output = {};

					local Loop	= 0;

					for Idx = A, Limit do
						Loop	= Loop + 1;

						Output[Loop] = Stk[Idx];
					end;

					return Output;
				elseif (Enum == 31) then -- FORLOOP
					local A		= Inst[1];
					local Stk	= Stack;

					local Step	= Stk[A + 2];
					local Index	= Stk[A] + Step;

					Stk[A]	= Index;

					if (Step > 0) then
						if Index <= Stk[A + 1] then
							InstrPoint	= InstrPoint + Inst[2];

							Stk[A + 3] = Index;
						end;
					else
						if Index >= Stk[A + 1] then
							InstrPoint	= InstrPoint + Inst[2];

							Stk[A + 3] = Index;
						end
					end
				elseif (Enum == 32) then -- FORPREP
					local A		= Inst[1];
					local Stk	= Stack;

					Stk[A]	= Stk[A] - Stk[A + 2];

					InstrPoint	= InstrPoint + Inst[2];
				elseif (Enum == 33) then -- TFORLOOP
					local A		= Inst[1];
					local B		= Inst[2];
					local C		= Inst[3];
					local Stk	= Stack;

					local Offset	= A + 2;
					local Result	= {Stk[A](Stk[A + 1], Stk[A + 2])};

					for Idx = 1, C do
						Stack[Offset + Idx] = Result[Idx];
					end;

					if (Stk[A + 3] ~= nil) then
						Stk[A + 2]	= Stk[A + 3];
					else
						InstrPoint	= InstrPoint + 1;
					end;
				elseif (Enum == 34) then -- SETLIST
					local A		= Inst[1];
					local B		= Inst[2];
					local C		= Inst[3];
					local Stk	= Stack;

					if (C == 0) then
						InstrPoint	= InstrPoint + 1;
						C			= Instr[InstrPoint]; -- This implementation was ambiguous! Will eventually re-test.
					end;

					local Offset	= (C - 1) * 50;
					local T			= Stk[A]; -- Assuming T is the newly created table.

					if (B == 0) then
						B	= Top;
					end;

					for Idx = 1, B do
						T[Offset + Idx] = Stk[A + Idx];
					end;
				elseif (Enum == 35) then -- CLOSE
					local A		= Inst[1];
					local Cls	= {}; -- Slight doubts on any issues this may cause

					for Idx = 1, #Lupvals do
						local List = Lupvals[Idx];

						for Idz = 0, #List do
							local Upv	= List[Idz];
							local Stk	= Upv[1];
							local Pos	= Upv[2];

							if (Stk == Stack) and (Pos >= A) then
								Cls[Pos]	= Stk[Pos];
								Upv[1]		= Cls; -- @memcorrupt credit me for the spoonfeed
							end;
						end;
					end;
				elseif (Enum == 36) then -- CLOSURE
					local Proto	= Proto[Inst[2]];
					local Instr = Instr;
					local Stk	= Stack;

					local Indexes;
					local NewUvals;

					if (Proto.Upvals ~= 0) then
						Indexes		= {};
						NewUvals	= setmetatable({}, {
								__index = function(_, Key)
									local Val	= Indexes[Key];

									return Val[1][Val[2]];
								end,
								__newindex = function(_, Key, Value)
									local Val	= Indexes[Key];

									Val[1][Val[2]]	= Value;
								end;
							}
						);

						for Idx = 1, Proto.Upvals do
							local Mvm	= Instr[InstrPoint];

							if (Mvm.Enum == 0) then -- MOVE
								Indexes[Idx - 1] = {Stk, Mvm[2]};
							elseif (Mvm.Enum == 4) then -- GETUPVAL
								Indexes[Idx - 1] = {Upvalues, Mvm[2]};
							end;

							InstrPoint	= InstrPoint + 1;
						end;

						Lupvals[#Lupvals + 1]	= Indexes;
					end;

					Stk[Inst[1]]			= Wrap(Proto, Env, NewUvals);
				elseif (Enum == 37) then -- VARARG
					local A	= Inst[1];
					local B	= Inst[2];
					local Stk, Vararg	= Stack, Vararg;

					for Idx = A, A + (B > 0 and B - 1 or Varargsz) do
						Stk[Idx]	= Vararg[Idx - A];
					end;
				end;
			end;
		end;

		local Args	= {...};

		for Idx = 0, Varargsz do
			Stack[Idx] = Args[Idx + 1];

			if (Idx >= Chunk.Args) then
				Vararg[Idx - Chunk.Args] = Args[Idx + 1];
			end;
		end;

		local A, B		= pcall(Loop); -- Pcalling to allow yielding

		if A then -- We're always expecting this to come out true (because errorless code)
			if B then -- So I flipped the conditions.
				return unpack(B);
			end;

			return;
		else
			OnError(B, InstrPoint - 1); -- Didn't get time to test the `-1` honestly, but I assume it works properly
		end;
	end;
end;

return function(BCode, Env) -- lua_function LoadBytecode (string BCode, table Env)
	local Buffer	= GetMeaning(BCode);

	return Wrap(Buffer, Env or getfenv(0)), Buffer;
end;
end;
};
G2L_MODULES[G2L["415"]] = {
Closure = function()
    local script = G2L["415"];local R6Converter = {}
function R6Converter.load(Plr)
Plr = game.Players:WaitForChild(Plr)
local FalseChar = script:WaitForChild("DefaultCharacter"):Clone()
local PlayersCharacter = game.Players:GetCharacterAppearanceAsync(Plr.UserId):Clone()
local FaceID = (Plr.Character:WaitForChild("Head"):FindFirstChild("face") or {Texture = "http://www.roblox.com/asset/?id=144080495"}).Texture
local Accessories = {}
FalseChar:WaitForChild("Head"):WaitForChild("face").Texture = FaceID
FalseChar:SetPrimaryPartCFrame(Plr.Character:WaitForChild("HumanoidRootPart").CFrame)
for _,Prt in pairs(PlayersCharacter:GetDescendants()) do
if Prt:IsA("Accessory") or Prt:IsA("Hat") or Prt:IsA("BodyColors") or Prt:IsA("CharacterMesh")or Prt:IsA("Pants") or Prt:IsA("Shirt") or Prt:IsA("ShirtGraphic") or Prt:IsA("Tool") then
table.insert(Accessories,Prt:Clone())
end
end

for _,Prt in pairs(Plr.Character:GetChildren()) do
Prt:Destroy()
end
for _,Prt in pairs(FalseChar:GetChildren()) do
Prt.Parent = Plr.Character
end
for _,Prt in pairs(Accessories) do
Prt.Parent = Plr.Character
end


end

return R6Converter

end;
};
-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.Kill all.LocalScript
local function C_8()
local script = G2L["8"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_8);
-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.Shutdown.LocalScript
local function C_c()
local script = G2L["c"];
	local remote = script.Parent.ShutDown
	local btn = script.Parent
	
	-- make it so when you press btn it fires remote
	btn.MouseButton1Click:Connect(function()
	    remote:FireServer()
	end)
end;
task.spawn(C_c);
-- StarterGui.ScreenGui.cool.trollinggui.ScrollingFrame.Tg reborn.LocalScript
local function C_11()
local script = G2L["11"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_11);
-- StarterGui.ScreenGui.cool.trollinggui.Smooth GUI Dragging
local function C_16()
local script = G2L["16"];
	local UserInputService = game:GetService("UserInputService")
	local runService = (game:GetService("RunService"));
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	function Lerp(a, b, m)
		return a + (b - a) * m
	end;
	
	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (8); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;
	
		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	runService.Heartbeat:Connect(Update)
end;
task.spawn(C_16);
-- StarterGui.ScreenGui.cool.trollinggui.TextButton.LocalScript
local function C_18()
local script = G2L["18"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page1.Visible = true
		script.Parent.Parent.Parent.trollinggui.Visible = false
	end)
end;
task.spawn(C_18);
-- StarterGui.ScreenGui.cool.trollinggui.TextButton.LocalScript
local function C_1a()
local script = G2L["1a"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page2.Visible = true
		script.Parent.Parent.Parent.trollinggui.Visible = false
	end)
end;
task.spawn(C_1a);
-- StarterGui.ScreenGui.cool.trollinggui.TextButton.LocalScript
local function C_1c()
local script = G2L["1c"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Main.Visible = true
		script.Parent.Parent.Parent.trollinggui.Visible = false
	end)
end;
task.spawn(C_1c);
-- StarterGui.ScreenGui.cool.trollinggui.TextButton.LocalScript
local function C_20()
local script = G2L["20"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.page5.Visible = true
		script.Parent.Parent.Parent.trollinggui.Visible = false
	end)
end;
task.spawn(C_20);
-- StarterGui.ScreenGui.cool.trollinggui.TextButton.LocalScript
local function C_22()
local script = G2L["22"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page6.Visible = true
		script.Parent.Parent.Parent.trollinggui.Visible = false
	end)
end;
task.spawn(C_22);
-- StarterGui.ScreenGui.cool.trollinggui.TextButton.LocalScript
local function C_24()
local script = G2L["24"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page7.Visible = true
		script.Parent.Parent.Parent.trollinggui.Visible = false
	end)
end;
task.spawn(C_24);
-- StarterGui.ScreenGui.cool.trollinggui.TextButton.LocalScript
local function C_26()
local script = G2L["26"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page8.Visible = true
		script.Parent.Parent.Parent.trollinggui.Visible = false
	end)
end;
task.spawn(C_26);
-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_2c()
local script = G2L["2c"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_2c);
-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_30()
local script = G2L["30"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_30);
-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_34()
local script = G2L["34"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_34);
-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_38()
local script = G2L["38"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_38);
-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_3c()
local script = G2L["3c"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_3c);
-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_40()
local script = G2L["40"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_40);
-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_44()
local script = G2L["44"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_44);
-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_48()
local script = G2L["48"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_48);
-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel..LocalScript
local function C_68()
local script = G2L["68"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_68);
-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_6f()
local script = G2L["6f"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_6f);
-- StarterGui.ScreenGui.cool.page5.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_73()
local script = G2L["73"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_73);
-- StarterGui.ScreenGui.cool.page5.Smooth GUI Dragging
local function C_75()
local script = G2L["75"];
	local UserInputService = game:GetService("UserInputService")
	local runService = (game:GetService("RunService"));
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	function Lerp(a, b, m)
		return a + (b - a) * m
	end;
	
	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (8); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;
	
		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	runService.Heartbeat:Connect(Update)
end;
task.spawn(C_75);
-- StarterGui.ScreenGui.cool.page5.TextButton.LocalScript
local function C_77()
local script = G2L["77"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page1.Visible = true
		script.Parent.Parent.Parent.page5.Visible = false
	end)
end;
task.spawn(C_77);
-- StarterGui.ScreenGui.cool.page5.TextButton.LocalScript
local function C_79()
local script = G2L["79"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page2.Visible = true
		script.Parent.Parent.Parent.page5.Visible = false
	end)
end;
task.spawn(C_79);
-- StarterGui.ScreenGui.cool.page5.TextButton.LocalScript
local function C_7b()
local script = G2L["7b"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Main.Visible = true
		script.Parent.Parent.Parent.page5.Visible = false
	end)
end;
task.spawn(C_7b);
-- StarterGui.ScreenGui.cool.page5.TextButton.LocalScript
local function C_7d()
local script = G2L["7d"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.trollinggui.Visible = true
		script.Parent.Parent.Parent.page5.Visible = false
	end)
end;
task.spawn(C_7d);
-- StarterGui.ScreenGui.cool.page5.TextButton.LocalScript
local function C_7f()
local script = G2L["7f"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page6.Visible = true
		script.Parent.Parent.Parent.page5.Visible = false
	end)
end;
task.spawn(C_7f);
-- StarterGui.ScreenGui.cool.page5.TextButton.LocalScript
local function C_81()
local script = G2L["81"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page7.Visible = true
		script.Parent.Parent.Parent.page5.Visible = false
	end)
end;
task.spawn(C_81);
-- StarterGui.ScreenGui.cool.page5.TextButton.LocalScript
local function C_83()
local script = G2L["83"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page8.Visible = true
		script.Parent.Parent.Parent.page5.Visible = false
	end)
end;
task.spawn(C_83);
-- StarterGui.ScreenGui.cool.Page8.Smooth GUI Dragging
local function C_b9()
local script = G2L["b9"];
	local UserInputService = game:GetService("UserInputService")
	local runService = (game:GetService("RunService"));
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	function Lerp(a, b, m)
		return a + (b - a) * m
	end;
	
	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (8); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;
	
		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	runService.Heartbeat:Connect(Update)
end;
task.spawn(C_b9);
-- StarterGui.ScreenGui.cool.Page8.TextButton.LocalScript
local function C_bb()
local script = G2L["bb"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page1.Visible = true
		script.Parent.Parent.Parent.Page8.Visible = false
	end)
end;
task.spawn(C_bb);
-- StarterGui.ScreenGui.cool.Page8.TextButton.LocalScript
local function C_bd()
local script = G2L["bd"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page2.Visible = true
		script.Parent.Parent.Parent.Page8.Visible = false
	end)
end;
task.spawn(C_bd);
-- StarterGui.ScreenGui.cool.Page8.TextButton.LocalScript
local function C_bf()
local script = G2L["bf"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Main.Visible = true
		script.Parent.Parent.Parent.Page8.Visible = false
	end)
end;
task.spawn(C_bf);
-- StarterGui.ScreenGui.cool.Page8.TextButton.LocalScript
local function C_c1()
local script = G2L["c1"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.trollinggui.Visible = true
		script.Parent.Parent.Parent.Page8.Visible = false
	end)
end;
task.spawn(C_c1);
-- StarterGui.ScreenGui.cool.Page8.TextButton.LocalScript
local function C_c3()
local script = G2L["c3"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.page5.Visible = true
		script.Parent.Parent.Parent.Page8.Visible = false
	end)
end;
task.spawn(C_c3);
-- StarterGui.ScreenGui.cool.Page8.TextButton.LocalScript
local function C_c5()
local script = G2L["c5"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page6.Visible = true
		script.Parent.Parent.Parent.Page8.Visible = false
	end)
end;
task.spawn(C_c5);
-- StarterGui.ScreenGui.cool.Page8.TextButton.LocalScript
local function C_c7()
local script = G2L["c7"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page7.Visible = true
		script.Parent.Parent.Parent.Page8.Visible = false
	end)
end;
task.spawn(C_c7);
-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_ce()
local script = G2L["ce"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_ce);
-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_d2()
local script = G2L["d2"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_d2);
-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_df()
local script = G2L["df"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_df);
-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_e3()
local script = G2L["e3"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_e3);
-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_e9()
local script = G2L["e9"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_e9);
-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_ee()
local script = G2L["ee"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_ee);
-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_f6()
local script = G2L["f6"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_f6);
-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_fb()
local script = G2L["fb"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_fb);
-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_ff()
local script = G2L["ff"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_ff);
-- StarterGui.ScreenGui.cool.Page7.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_103()
local script = G2L["103"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_103);
-- StarterGui.ScreenGui.cool.Page7.Smooth GUI Dragging
local function C_137()
local script = G2L["137"];
	local UserInputService = game:GetService("UserInputService")
	local runService = (game:GetService("RunService"));
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	function Lerp(a, b, m)
		return a + (b - a) * m
	end;
	
	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (8); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;
	
		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	runService.Heartbeat:Connect(Update)
end;
task.spawn(C_137);
-- StarterGui.ScreenGui.cool.Page7.TextButton.LocalScript
local function C_139()
local script = G2L["139"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page1.Visible = true
		script.Parent.Parent.Parent.Page7.Visible = false
	end)
end;
task.spawn(C_139);
-- StarterGui.ScreenGui.cool.Page7.TextButton.LocalScript
local function C_13b()
local script = G2L["13b"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page2.Visible = true
		script.Parent.Parent.Parent.Page7.Visible = false
	end)
end;
task.spawn(C_13b);
-- StarterGui.ScreenGui.cool.Page7.TextButton.LocalScript
local function C_13d()
local script = G2L["13d"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Main.Visible = true
		script.Parent.Parent.Parent.Page7.Visible = false
	end)
end;
task.spawn(C_13d);
-- StarterGui.ScreenGui.cool.Page7.TextButton.LocalScript
local function C_13f()
local script = G2L["13f"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page4.Visible = true
		script.Parent.Parent.Parent.Page7.Visible = false
	end)
end;
task.spawn(C_13f);
-- StarterGui.ScreenGui.cool.Page7.TextButton.LocalScript
local function C_141()
local script = G2L["141"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page5.Visible = true
		script.Parent.Parent.Parent.Page7.Visible = false
	end)
end;
task.spawn(C_141);
-- StarterGui.ScreenGui.cool.Page7.TextButton.LocalScript
local function C_143()
local script = G2L["143"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page6.Visible = true
		script.Parent.Parent.Parent.Page7.Visible = false
	end)
end;
task.spawn(C_143);
-- StarterGui.ScreenGui.cool.Page7.TextButton.LocalScript
local function C_145()
local script = G2L["145"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page8.Visible = true
		script.Parent.Parent.Parent.Page7.Visible = false
	end)
end;
task.spawn(C_145);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_14b()
local script = G2L["14b"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_14b);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_14f()
local script = G2L["14f"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_14f);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_153()
local script = G2L["153"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_153);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_157()
local script = G2L["157"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_157);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_15b()
local script = G2L["15b"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_15b);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_15f()
local script = G2L["15f"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_15f);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_163()
local script = G2L["163"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_163);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_168()
local script = G2L["168"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_168);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_16d()
local script = G2L["16d"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_16d);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_171()
local script = G2L["171"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_171);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_175()
local script = G2L["175"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_175);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_179()
local script = G2L["179"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_179);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_17e()
local script = G2L["17e"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_17e);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_183()
local script = G2L["183"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_183);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_188()
local script = G2L["188"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_188);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_18d()
local script = G2L["18d"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_18d);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_192()
local script = G2L["192"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_192);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_197()
local script = G2L["197"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_197);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_19c()
local script = G2L["19c"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_19c);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_1a1()
local script = G2L["1a1"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_1a1);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_1a6()
local script = G2L["1a6"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_1a6);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_1ab()
local script = G2L["1ab"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_1ab);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_1b0()
local script = G2L["1b0"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_1b0);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_1b5()
local script = G2L["1b5"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_1b5);
-- StarterGui.ScreenGui.cool.Page6.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_1ba()
local script = G2L["1ba"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_1ba);
-- StarterGui.ScreenGui.cool.Page6.Smooth GUI Dragging
local function C_1bc()
local script = G2L["1bc"];
	local UserInputService = game:GetService("UserInputService")
	local runService = (game:GetService("RunService"));
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	function Lerp(a, b, m)
		return a + (b - a) * m
	end;
	
	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (8); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;
	
		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	runService.Heartbeat:Connect(Update)
end;
task.spawn(C_1bc);
-- StarterGui.ScreenGui.cool.Page6.TextButton.LocalScript
local function C_1be()
local script = G2L["1be"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page1.Visible = true
		script.Parent.Parent.Parent.Page6.Visible = false
	end)
end;
task.spawn(C_1be);
-- StarterGui.ScreenGui.cool.Page6.TextButton.LocalScript
local function C_1c0()
local script = G2L["1c0"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page2.Visible = true
		script.Parent.Parent.Parent.Page6.Visible = false
	end)
end;
task.spawn(C_1c0);
-- StarterGui.ScreenGui.cool.Page6.TextButton.LocalScript
local function C_1c2()
local script = G2L["1c2"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page2.Visible = true
		script.Parent.Parent.Parent.Page6.Visible = false
	end)
end;
task.spawn(C_1c2);
-- StarterGui.ScreenGui.cool.Page6.TextButton.LocalScript
local function C_1c4()
local script = G2L["1c4"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Main.Visible = true
		script.Parent.Parent.Parent.Page6.Visible = false
	end)
end;
task.spawn(C_1c4);
-- StarterGui.ScreenGui.cool.Page6.TextButton.LocalScript
local function C_1c6()
local script = G2L["1c6"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.trollinggui.Visible = true
		script.Parent.Parent.Parent.Page6.Visible = false
	end)
end;
task.spawn(C_1c6);
-- StarterGui.ScreenGui.cool.Page6.TextButton.LocalScript
local function C_1c8()
local script = G2L["1c8"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.page5.Visible = true
		script.Parent.Parent.Parent.Page6.Visible = false
	end)
end;
task.spawn(C_1c8);
-- StarterGui.ScreenGui.cool.Page6.TextButton.LocalScript
local function C_1ca()
local script = G2L["1ca"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page7.Visible = true
		script.Parent.Parent.Parent.Page6.Visible = false
	end)
end;
task.spawn(C_1ca);
-- StarterGui.ScreenGui.cool.Page6.TextButton.LocalScript
local function C_1cc()
local script = G2L["1cc"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page8.Visible = true
		script.Parent.Parent.Parent.Page6.Visible = false
	end)
end;
task.spawn(C_1cc);
-- StarterGui.ScreenGui.cool.Page2.Smooth GUI Dragging
local function C_1e0()
local script = G2L["1e0"];
	local UserInputService = game:GetService("UserInputService")
	local runService = (game:GetService("RunService"));
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	function Lerp(a, b, m)
		return a + (b - a) * m
	end;
	
	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (8); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;
	
		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	runService.Heartbeat:Connect(Update)
end;
task.spawn(C_1e0);
-- StarterGui.ScreenGui.cool.Page2.TextButton.LocalScript
local function C_1e2()
local script = G2L["1e2"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page1.Visible = true
		script.Parent.Parent.Parent.Page2.Visible = false
	end)
end;
task.spawn(C_1e2);
-- StarterGui.ScreenGui.cool.Page2.TextButton.LocalScript
local function C_1e4()
local script = G2L["1e4"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Main.Visible = true
		script.Parent.Parent.Parent.Page2.Visible = false
	end)
end;
task.spawn(C_1e4);
-- StarterGui.ScreenGui.cool.Page2.TextButton.LocalScript
local function C_1e6()
local script = G2L["1e6"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.trollinggui.Visible = true
		script.Parent.Parent.Parent.Page2.Visible = false
	end)
end;
task.spawn(C_1e6);
-- StarterGui.ScreenGui.cool.Page2.TextButton.LocalScript
local function C_1e8()
local script = G2L["1e8"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.page5.Visible = true
		script.Parent.Parent.Parent.Page2.Visible = false
	end)
end;
task.spawn(C_1e8);
-- StarterGui.ScreenGui.cool.Page2.TextButton.LocalScript
local function C_1ea()
local script = G2L["1ea"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page6.Visible = true
		script.Parent.Parent.Parent.Page2.Visible = false
	end)
end;
task.spawn(C_1ea);
-- StarterGui.ScreenGui.cool.Page2.TextButton.LocalScript
local function C_1ec()
local script = G2L["1ec"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page7.Visible = true
		script.Parent.Parent.Parent.Page2.Visible = false
	end)
end;
task.spawn(C_1ec);
-- StarterGui.ScreenGui.cool.Page2.TextButton.LocalScript
local function C_1ee()
local script = G2L["1ee"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page8.Visible = true
		script.Parent.Parent.Parent.Page2.Visible = false
	end)
end;
task.spawn(C_1ee);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_240()
local script = G2L["240"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_240);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_246()
local script = G2L["246"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_246);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_24d()
local script = G2L["24d"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_24d);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_251()
local script = G2L["251"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_251);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_255()
local script = G2L["255"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_255);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_259()
local script = G2L["259"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_259);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_25f()
local script = G2L["25f"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_25f);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_265()
local script = G2L["265"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_265);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_26a()
local script = G2L["26a"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_26a);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_26f()
local script = G2L["26f"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_26f);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_274()
local script = G2L["274"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_274);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_279()
local script = G2L["279"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_279);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_286()
local script = G2L["286"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_286);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_28a()
local script = G2L["28a"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_28a);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_28e()
local script = G2L["28e"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_28e);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_293()
local script = G2L["293"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_293);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_297()
local script = G2L["297"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_297);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_2a6()
local script = G2L["2a6"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_2a6);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_2ab()
local script = G2L["2ab"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_2ab);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_2af()
local script = G2L["2af"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_2af);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_2b3()
local script = G2L["2b3"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_2b3);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_2b7()
local script = G2L["2b7"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_2b7);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_2c5()
local script = G2L["2c5"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_2c5);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_2cb()
local script = G2L["2cb"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_2cb);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_2f7()
local script = G2L["2f7"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_2f7);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_300()
local script = G2L["300"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_300);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.rc7.LocalScript
local function C_304()
local script = G2L["304"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_304);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.rc7.LocalScript
local function C_308()
local script = G2L["308"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_308);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.rc7.LocalScript
local function C_30c()
local script = G2L["30c"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_30c);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Humanoid.Jump
local function C_346()
local script = G2L["346"];
	local Mouse = game.Players.LocalPlayer:GetMouse()
	Mouse.KeyDown:connect(function(Key)
	if Key == " " then
	local Active = true
	local Connection = Mouse.KeyUp:connect(function(Key)
	if Key == " " then
	Active = false
	end
	end)
	
	while Active do
	script.Parent.Jump = true
	wait()
	end
	Connection:Disconnect()
	end
	end)
end;
task.spawn(C_346);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.Script.Dummy.Animate
local function C_34b()
local script = G2L["34b"];
	local Figure = script.Parent
	local Torso = Figure:WaitForChild("Torso")
	local RightShoulder = Torso:WaitForChild("Right Shoulder")
	local LeftShoulder = Torso:WaitForChild("Left Shoulder")
	local RightHip = Torso:WaitForChild("Right Hip")
	local LeftHip = Torso:WaitForChild("Left Hip")
	local Neck = Torso:WaitForChild("Neck")
	local Humanoid = Figure:WaitForChild("Humanoid")
	local pose = "Standing"
	
	local currentAnim = ""
	local currentAnimInstance = nil
	local currentAnimTrack = nil
	local currentAnimKeyframeHandler = nil
	local currentAnimSpeed = 1.0
	local animTable = {}
	local animNames = { 
		idle = 	{	
					{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
					{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
				},
		walk = 	{ 	
					{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
				}, 
		run = 	{
					{ id = "run.xml", weight = 10 } 
				}, 
		jump = 	{
					{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
				}, 
		fall = 	{
					{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
				}, 
		climb = {
					{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
				}, 
		sit = 	{
					{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
				},	
		toolnone = {
					{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
				},
		toolslash = {
					{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
	--				{ id = "slash.xml", weight = 10 } 
				},
		toollunge = {
					{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
				},
		wave = {
					{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
				},
		point = {
					{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
				},
		dance1 = {
					{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
				},
		dance2 = {
					{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
				},
		dance3 = {
					{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
				},
		laugh = {
					{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
				},
		cheer = {
					{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
				},
	}
	local dances = {"dance1", "dance2", "dance3"}
	
	-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
	local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}
	
	function configureAnimationSet(name, fileList)
		if (animTable[name] ~= nil) then
			for _, connection in pairs(animTable[name].connections) do
				connection:disconnect()
			end
		end
		animTable[name] = {}
		animTable[name].count = 0
		animTable[name].totalWeight = 0	
		animTable[name].connections = {}
	
		-- check for config values
		local config = script:FindFirstChild(name)
		if (config ~= nil) then
	--		print("Loading anims " .. name)
			table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
			table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
			local idx = 1
			for _, childPart in pairs(config:GetChildren()) do
				if (childPart:IsA("Animation")) then
					table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
					animTable[name][idx] = {}
					animTable[name][idx].anim = childPart
					local weightObject = childPart:FindFirstChild("Weight")
					if (weightObject == nil) then
						animTable[name][idx].weight = 1
					else
						animTable[name][idx].weight = weightObject.Value
					end
					animTable[name].count = animTable[name].count + 1
					animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
		--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
					idx = idx + 1
				end
			end
		end
	
		-- fallback to defaults
		if (animTable[name].count <= 0) then
			for idx, anim in pairs(fileList) do
				animTable[name][idx] = {}
				animTable[name][idx].anim = Instance.new("Animation")
				animTable[name][idx].anim.Name = name
				animTable[name][idx].anim.AnimationId = anim.id
				animTable[name][idx].weight = anim.weight
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
	--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
			end
		end
	end
	
	-- Setup animation objects
	function scriptChildModified(child)
		local fileList = animNames[child.Name]
		if (fileList ~= nil) then
			configureAnimationSet(child.Name, fileList)
		end	
	end
	
	script.ChildAdded:connect(scriptChildModified)
	script.ChildRemoved:connect(scriptChildModified)
	
	
	for name, fileList in pairs(animNames) do 
		configureAnimationSet(name, fileList)
	end	
	
	-- ANIMATION
	
	-- declarations
	local toolAnim = "None"
	local toolAnimTime = 0
	
	local jumpAnimTime = 0
	local jumpAnimDuration = 0.3
	
	local toolTransitionTime = 0.1
	local fallTransitionTime = 0.3
	local jumpMaxLimbVelocity = 0.75
	
	-- functions
	
	function stopAllAnimations()
		local oldAnim = currentAnim
	
		-- return to idle if finishing an emote
		if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
			oldAnim = "idle"
		end
	
		currentAnim = ""
		currentAnimInstance = nil
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
	
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop()
			currentAnimTrack:Destroy()
			currentAnimTrack = nil
		end
		return oldAnim
	end
	
	function setAnimationSpeed(speed)
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
	
	function keyFrameReachedFunc(frameName)
		if (frameName == "End") then
	
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.0, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
	
	-- Preload animations
	function playAnimation(animName, transitionTime, humanoid) 
			
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
	--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim
	
		-- switch animation		
		if (anim ~= currentAnimInstance) then
			
			if (currentAnimTrack ~= nil) then
				currentAnimTrack:Stop(transitionTime)
				currentAnimTrack:Destroy()
			end
	
			currentAnimSpeed = 1.0
		
			-- load it to the humanoid; get AnimationTrack
			currentAnimTrack = humanoid:LoadAnimation(anim)
			currentAnimTrack.Priority = Enum.AnimationPriority.Core
			 
			-- play the animation
			currentAnimTrack:Play(transitionTime)
			currentAnim = animName
			currentAnimInstance = anim
	
			-- set up keyframe name triggers
			if (currentAnimKeyframeHandler ~= nil) then
				currentAnimKeyframeHandler:disconnect()
			end
			currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
			
		end
	
	end
	
	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------
	
	local toolAnimName = ""
	local toolAnimTrack = nil
	local toolAnimInstance = nil
	local currentToolAnimKeyframeHandler = nil
	
	function toolKeyFrameReachedFunc(frameName)
		if (frameName == "End") then
	--		print("Keyframe : ".. frameName)	
			playToolAnimation(toolAnimName, 0.0, Humanoid)
		end
	end
	
	
	function playToolAnimation(animName, transitionTime, humanoid, priority)	 
			
			local roll = math.random(1, animTable[animName].totalWeight) 
			local origRoll = roll
			local idx = 1
			while (roll > animTable[animName][idx].weight) do
				roll = roll - animTable[animName][idx].weight
				idx = idx + 1
			end
	--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
			local anim = animTable[animName][idx].anim
	
			if (toolAnimInstance ~= anim) then
				
				if (toolAnimTrack ~= nil) then
					toolAnimTrack:Stop()
					toolAnimTrack:Destroy()
					transitionTime = 0
				end
						
				-- load it to the humanoid; get AnimationTrack
				toolAnimTrack = humanoid:LoadAnimation(anim)
				if priority then
					toolAnimTrack.Priority = priority
				end
				 
				-- play the animation
				toolAnimTrack:Play(transitionTime)
				toolAnimName = animName
				toolAnimInstance = anim
	
				currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
			end
	end
	
	function stopToolAnimations()
		local oldAnim = toolAnimName
	
		if (currentToolAnimKeyframeHandler ~= nil) then
			currentToolAnimKeyframeHandler:disconnect()
		end
	
		toolAnimName = ""
		toolAnimInstance = nil
		if (toolAnimTrack ~= nil) then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			toolAnimTrack = nil
		end
	
	
		return oldAnim
	end
	
	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------
	
	
	function onRunning(speed)
		if speed > 0.01 then
			playAnimation("walk", 0.1, Humanoid)
			if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
				setAnimationSpeed(speed / 14.5)
			end
			pose = "Running"
		else
			if emoteNames[currentAnim] == nil then
				playAnimation("idle", 0.1, Humanoid)
				pose = "Standing"
			end
		end
	end
	
	function onDied()
		pose = "Dead"
	end
	
	function onJumping()
		playAnimation("jump", 0.1, Humanoid)
		jumpAnimTime = jumpAnimDuration
		pose = "Jumping"
	end
	
	function onClimbing(speed)
		playAnimation("climb", 0.1, Humanoid)
		setAnimationSpeed(speed / 12.0)
		pose = "Climbing"
	end
	
	function onGettingUp()
		pose = "GettingUp"
	end
	
	function onFreeFall()
		if (jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		end
		pose = "FreeFall"
	end
	
	function onFallingDown()
		pose = "FallingDown"
	end
	
	function onSeated()
		pose = "Seated"
	end
	
	function onPlatformStanding()
		pose = "PlatformStanding"
	end
	
	function onSwimming(speed)
		if speed > 0 then
			pose = "Running"
		else
			pose = "Standing"
		end
	end
	
	function getTool()	
		for _, kid in ipairs(Figure:GetChildren()) do
			if kid.className == "Tool" then return kid end
		end
		return nil
	end
	
	function getToolAnim(tool)
		for _, c in ipairs(tool:GetChildren()) do
			if c.Name == "toolanim" and c.className == "StringValue" then
				return c
			end
		end
		return nil
	end
	
	function animateTool()
		
		if (toolAnim == "None") then
			playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
			return
		end
	
		if (toolAnim == "Slash") then
			playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
			return
		end
	
		if (toolAnim == "Lunge") then
			playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
			return
		end
	end
	
	function moveSit()
		RightShoulder.MaxVelocity = 0.15
		LeftShoulder.MaxVelocity = 0.15
		RightShoulder:SetDesiredAngle(3.14 /2)
		LeftShoulder:SetDesiredAngle(-3.14 /2)
		RightHip:SetDesiredAngle(3.14 /2)
		LeftHip:SetDesiredAngle(-3.14 /2)
	end
	
	local lastTick = 0
	
	function move(time)
		local amplitude = 1
		local frequency = 1
	  	local deltaTime = time - lastTick
	  	lastTick = time
	
		local climbFudge = 0
		local setAngles = false
	
	  	if (jumpAnimTime > 0) then
	  		jumpAnimTime = jumpAnimTime - deltaTime
	  	end
	
		if (pose == "FreeFall" and jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		elseif (pose == "Seated") then
			playAnimation("sit", 0.5, Humanoid)
			return
		elseif (pose == "Running") then
			playAnimation("walk", 0.1, Humanoid)
		elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
	--		print("Wha " .. pose)
			stopAllAnimations()
			amplitude = 0.1
			frequency = 1
			setAngles = true
		end
	
		if (setAngles) then
			local desiredAngle = amplitude * math.sin(time * frequency)
	
			RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
			LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
			RightHip:SetDesiredAngle(-desiredAngle)
			LeftHip:SetDesiredAngle(-desiredAngle)
		end
	
		-- Tool Animation handling
		local tool = getTool()
		if tool and tool:FindFirstChild("Handle") then
		
			local animStringValueObject = getToolAnim(tool)
	
			if animStringValueObject then
				toolAnim = animStringValueObject.Value
				-- message recieved, delete StringValue
				animStringValueObject.Parent = nil
				toolAnimTime = time + .3
			end
	
			if time > toolAnimTime then
				toolAnimTime = 0
				toolAnim = "None"
			end
	
			animateTool()		
		else
			stopToolAnimations()
			toolAnim = "None"
			toolAnimInstance = nil
			toolAnimTime = 0
		end
	end
	
	-- connect events
	Humanoid.Died:connect(onDied)
	Humanoid.Running:connect(onRunning)
	Humanoid.Jumping:connect(onJumping)
	Humanoid.Climbing:connect(onClimbing)
	Humanoid.GettingUp:connect(onGettingUp)
	Humanoid.FreeFalling:connect(onFreeFall)
	Humanoid.FallingDown:connect(onFallingDown)
	Humanoid.Seated:connect(onSeated)
	Humanoid.PlatformStanding:connect(onPlatformStanding)
	Humanoid.Swimming:connect(onSwimming)
	
	-- setup emote chat hook
	game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
		local emote = ""
		if msg == "/e dance" then
			emote = dances[math.random(1, #dances)]
		elseif (string.sub(msg, 1, 3) == "/e ") then
			emote = string.sub(msg, 4)
		elseif (string.sub(msg, 1, 7) == "/emote ") then
			emote = string.sub(msg, 8)
		end
		
		if (pose == "Standing" and emoteNames[emote] ~= nil) then
			playAnimation(emote, 0.1, Humanoid)
		end
	
	end)
	
	
	-- main program
	
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
	
	while Figure.Parent ~= nil do
		local _, time = wait(0.1)
		move(time)
	end
	
	
	
end;
task.spawn(C_34b);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_377()
local script = G2L["377"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_377);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_37b()
local script = G2L["37b"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_37b);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_37f()
local script = G2L["37f"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_37f);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_383()
local script = G2L["383"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_383);
-- StarterGui.ScreenGui.cool.Page1.ScrollingFrame.TextLabel.TextButton.LocalScript
local function C_387()
local script = G2L["387"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_387);
-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
local function C_3c5()
local script = G2L["3c5"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
	
	
end;
task.spawn(C_3c5);
-- StarterGui.ScreenGui.cool.Page1.Smooth GUI Dragging
local function C_3c7()
local script = G2L["3c7"];
	local UserInputService = game:GetService("UserInputService")
	local runService = (game:GetService("RunService"));
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	function Lerp(a, b, m)
		return a + (b - a) * m
	end;
	
	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (8); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;
	
		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	runService.Heartbeat:Connect(Update)
end;
task.spawn(C_3c7);
-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
local function C_3cb()
local script = G2L["3cb"];
	
	script.Parent.MouseButton1Down:Connect(function()
		script.Parent.Script.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_3cb);
-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
local function C_3ce()
local script = G2L["3ce"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_3ce);
-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
local function C_3d2()
local script = G2L["3d2"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_3d2);
-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
local function C_3d6()
local script = G2L["3d6"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_3d6);
-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
local function C_3da()
local script = G2L["3da"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_3da);
-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
local function C_3e3()
local script = G2L["3e3"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_3e3);
-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
local function C_3ed()
local script = G2L["3ed"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page2.Visible = true
		script.Parent.Parent.Parent.Page1.Visible = false
	end)
end;
task.spawn(C_3ed);
-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
local function C_3ef()
local script = G2L["3ef"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Main.Visible = true
		script.Parent.Parent.Parent.Page1.Visible = false
	end)
end;
task.spawn(C_3ef);
-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
local function C_3f1()
local script = G2L["3f1"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.trollinggui.Visible = true
		script.Parent.Parent.Parent.Page1.Visible = false
	end)
end;
task.spawn(C_3f1);
-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
local function C_3f3()
local script = G2L["3f3"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.page5.Visible = true
		script.Parent.Parent.Parent.Page1.Visible = false
	end)
end;
task.spawn(C_3f3);
-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
local function C_3f5()
local script = G2L["3f5"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page6.Visible = true
		script.Parent.Parent.Parent.Page1.Visible = false
	end)
end;
task.spawn(C_3f5);
-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
local function C_3f7()
local script = G2L["3f7"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page7.Visible = true
		script.Parent.Parent.Parent.Page1.Visible = false
	end)
end;
task.spawn(C_3f7);
-- StarterGui.ScreenGui.cool.Page1.TextButton.LocalScript
local function C_3f9()
local script = G2L["3f9"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page8.Visible = true
		script.Parent.Parent.Parent.Page1.Visible = false
	end)
end;
task.spawn(C_3f9);
-- StarterGui.ScreenGui.cool.Main.BottomRow.Execute.LocalScript
local function C_40b()
local script = G2L["40b"];
	local execute = script.Parent.Parent.Execute
	local text = script.Parent.Parent.Parent.Middle.ExecuteBox
	local remote = script.Parent.nya
	
	execute.MouseButton1Click:Connect(function()
		remote:FireServer(text.Text)
	end)
end;
task.spawn(C_40b);
-- StarterGui.ScreenGui.cool.Main.BottomRow.Clear.LocalScript
local function C_40e()
local script = G2L["40e"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Middle.ExecuteBox.Text = ''
	end)
end;
task.spawn(C_40e);
-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.LocalScript
local function C_412()
local script = G2L["412"];
	script.Parent.MouseButton1Click:Connect(function()
	script.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_412);
-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Animate
local function C_417()
local script = G2L["417"];
	local Figure = script.Parent
	local Torso = Figure:WaitForChild("Torso")
	local RightShoulder = Torso:WaitForChild("Right Shoulder")
	local LeftShoulder = Torso:WaitForChild("Left Shoulder")
	local RightHip = Torso:WaitForChild("Right Hip")
	local LeftHip = Torso:WaitForChild("Left Hip")
	local Neck = Torso:WaitForChild("Neck")
	local Humanoid = Figure:WaitForChild("Humanoid")
	local pose = "Standing"
	
	local currentAnim = ""
	local currentAnimInstance = nil
	local currentAnimTrack = nil
	local currentAnimKeyframeHandler = nil
	local currentAnimSpeed = 1.0
	local animTable = {}
	local animNames = { 
		idle = 	{	
					{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
					{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
				},
		walk = 	{ 	
					{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
				}, 
		run = 	{
					{ id = "run.xml", weight = 10 } 
				}, 
		jump = 	{
					{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
				}, 
		fall = 	{
					{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
				}, 
		climb = {
					{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
				}, 
		sit = 	{
					{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
				},	
		toolnone = {
					{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
				},
		toolslash = {
					{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
	--				{ id = "slash.xml", weight = 10 } 
				},
		toollunge = {
					{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
				},
		wave = {
					{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
				},
		point = {
					{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
				},
		dance1 = {
					{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
				},
		dance2 = {
					{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
				},
		dance3 = {
					{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
				},
		laugh = {
					{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
				},
		cheer = {
					{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
				},
	}
	local dances = {"dance1", "dance2", "dance3"}
	
	-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
	local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}
	
	function configureAnimationSet(name, fileList)
		if (animTable[name] ~= nil) then
			for _, connection in pairs(animTable[name].connections) do
				connection:disconnect()
			end
		end
		animTable[name] = {}
		animTable[name].count = 0
		animTable[name].totalWeight = 0	
		animTable[name].connections = {}
	
		-- check for config values
		local config = script:FindFirstChild(name)
		if (config ~= nil) then
	--		print("Loading anims " .. name)
			table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
			table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
			local idx = 1
			for _, childPart in pairs(config:GetChildren()) do
				if (childPart:IsA("Animation")) then
					table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
					animTable[name][idx] = {}
					animTable[name][idx].anim = childPart
					local weightObject = childPart:FindFirstChild("Weight")
					if (weightObject == nil) then
						animTable[name][idx].weight = 1
					else
						animTable[name][idx].weight = weightObject.Value
					end
					animTable[name].count = animTable[name].count + 1
					animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
		--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
					idx = idx + 1
				end
			end
		end
	
		-- fallback to defaults
		if (animTable[name].count <= 0) then
			for idx, anim in pairs(fileList) do
				animTable[name][idx] = {}
				animTable[name][idx].anim = Instance.new("Animation")
				animTable[name][idx].anim.Name = name
				animTable[name][idx].anim.AnimationId = anim.id
				animTable[name][idx].weight = anim.weight
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
	--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
			end
		end
	end
	
	-- Setup animation objects
	function scriptChildModified(child)
		local fileList = animNames[child.Name]
		if (fileList ~= nil) then
			configureAnimationSet(child.Name, fileList)
		end	
	end
	
	script.ChildAdded:connect(scriptChildModified)
	script.ChildRemoved:connect(scriptChildModified)
	
	
	for name, fileList in pairs(animNames) do 
		configureAnimationSet(name, fileList)
	end	
	
	-- ANIMATION
	
	-- declarations
	local toolAnim = "None"
	local toolAnimTime = 0
	
	local jumpAnimTime = 0
	local jumpAnimDuration = 0.3
	
	local toolTransitionTime = 0.1
	local fallTransitionTime = 0.3
	local jumpMaxLimbVelocity = 0.75
	
	-- functions
	
	function stopAllAnimations()
		local oldAnim = currentAnim
	
		-- return to idle if finishing an emote
		if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
			oldAnim = "idle"
		end
	
		currentAnim = ""
		currentAnimInstance = nil
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
	
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop()
			currentAnimTrack:Destroy()
			currentAnimTrack = nil
		end
		return oldAnim
	end
	
	function setAnimationSpeed(speed)
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
	
	function keyFrameReachedFunc(frameName)
		if (frameName == "End") then
	
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.0, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
	
	-- Preload animations
	function playAnimation(animName, transitionTime, humanoid) 
			
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
	--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim
	
		-- switch animation		
		if (anim ~= currentAnimInstance) then
			
			if (currentAnimTrack ~= nil) then
				currentAnimTrack:Stop(transitionTime)
				currentAnimTrack:Destroy()
			end
	
			currentAnimSpeed = 1.0
		
			-- load it to the humanoid; get AnimationTrack
			currentAnimTrack = humanoid:LoadAnimation(anim)
			currentAnimTrack.Priority = Enum.AnimationPriority.Core
			 
			-- play the animation
			currentAnimTrack:Play(transitionTime)
			currentAnim = animName
			currentAnimInstance = anim
	
			-- set up keyframe name triggers
			if (currentAnimKeyframeHandler ~= nil) then
				currentAnimKeyframeHandler:disconnect()
			end
			currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
			
		end
	
	end
	
	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------
	
	local toolAnimName = ""
	local toolAnimTrack = nil
	local toolAnimInstance = nil
	local currentToolAnimKeyframeHandler = nil
	
	function toolKeyFrameReachedFunc(frameName)
		if (frameName == "End") then
	--		print("Keyframe : ".. frameName)	
			playToolAnimation(toolAnimName, 0.0, Humanoid)
		end
	end
	
	
	function playToolAnimation(animName, transitionTime, humanoid, priority)	 
			
			local roll = math.random(1, animTable[animName].totalWeight) 
			local origRoll = roll
			local idx = 1
			while (roll > animTable[animName][idx].weight) do
				roll = roll - animTable[animName][idx].weight
				idx = idx + 1
			end
	--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
			local anim = animTable[animName][idx].anim
	
			if (toolAnimInstance ~= anim) then
				
				if (toolAnimTrack ~= nil) then
					toolAnimTrack:Stop()
					toolAnimTrack:Destroy()
					transitionTime = 0
				end
						
				-- load it to the humanoid; get AnimationTrack
				toolAnimTrack = humanoid:LoadAnimation(anim)
				if priority then
					toolAnimTrack.Priority = priority
				end
				 
				-- play the animation
				toolAnimTrack:Play(transitionTime)
				toolAnimName = animName
				toolAnimInstance = anim
	
				currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
			end
	end
	
	function stopToolAnimations()
		local oldAnim = toolAnimName
	
		if (currentToolAnimKeyframeHandler ~= nil) then
			currentToolAnimKeyframeHandler:disconnect()
		end
	
		toolAnimName = ""
		toolAnimInstance = nil
		if (toolAnimTrack ~= nil) then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			toolAnimTrack = nil
		end
	
	
		return oldAnim
	end
	
	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------
	
	
	function onRunning(speed)
		if speed > 0.01 then
			playAnimation("walk", 0.1, Humanoid)
			if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
				setAnimationSpeed(speed / 14.5)
			end
			pose = "Running"
		else
			if emoteNames[currentAnim] == nil then
				playAnimation("idle", 0.1, Humanoid)
				pose = "Standing"
			end
		end
	end
	
	function onDied()
		pose = "Dead"
	end
	
	function onJumping()
		playAnimation("jump", 0.1, Humanoid)
		jumpAnimTime = jumpAnimDuration
		pose = "Jumping"
	end
	
	function onClimbing(speed)
		playAnimation("climb", 0.1, Humanoid)
		setAnimationSpeed(speed / 12.0)
		pose = "Climbing"
	end
	
	function onGettingUp()
		pose = "GettingUp"
	end
	
	function onFreeFall()
		if (jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		end
		pose = "FreeFall"
	end
	
	function onFallingDown()
		pose = "FallingDown"
	end
	
	function onSeated()
		pose = "Seated"
	end
	
	function onPlatformStanding()
		pose = "PlatformStanding"
	end
	
	function onSwimming(speed)
		if speed > 0 then
			pose = "Running"
		else
			pose = "Standing"
		end
	end
	
	function getTool()	
		for _, kid in ipairs(Figure:GetChildren()) do
			if kid.className == "Tool" then return kid end
		end
		return nil
	end
	
	function getToolAnim(tool)
		for _, c in ipairs(tool:GetChildren()) do
			if c.Name == "toolanim" and c.className == "StringValue" then
				return c
			end
		end
		return nil
	end
	
	function animateTool()
		
		if (toolAnim == "None") then
			playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
			return
		end
	
		if (toolAnim == "Slash") then
			playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
			return
		end
	
		if (toolAnim == "Lunge") then
			playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
			return
		end
	end
	
	function moveSit()
		RightShoulder.MaxVelocity = 0.15
		LeftShoulder.MaxVelocity = 0.15
		RightShoulder:SetDesiredAngle(3.14 /2)
		LeftShoulder:SetDesiredAngle(-3.14 /2)
		RightHip:SetDesiredAngle(3.14 /2)
		LeftHip:SetDesiredAngle(-3.14 /2)
	end
	
	local lastTick = 0
	
	function move(time)
		local amplitude = 1
		local frequency = 1
	  	local deltaTime = time - lastTick
	  	lastTick = time
	
		local climbFudge = 0
		local setAngles = false
	
	  	if (jumpAnimTime > 0) then
	  		jumpAnimTime = jumpAnimTime - deltaTime
	  	end
	
		if (pose == "FreeFall" and jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		elseif (pose == "Seated") then
			playAnimation("sit", 0.5, Humanoid)
			return
		elseif (pose == "Running") then
			playAnimation("walk", 0.1, Humanoid)
		elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
	--		print("Wha " .. pose)
			stopAllAnimations()
			amplitude = 0.1
			frequency = 1
			setAngles = true
		end
	
		if (setAngles) then
			local desiredAngle = amplitude * math.sin(time * frequency)
	
			RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
			LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
			RightHip:SetDesiredAngle(-desiredAngle)
			LeftHip:SetDesiredAngle(-desiredAngle)
		end
	
		-- Tool Animation handling
		local tool = getTool()
		if tool and tool:FindFirstChild("Handle") then
		
			local animStringValueObject = getToolAnim(tool)
	
			if animStringValueObject then
				toolAnim = animStringValueObject.Value
				-- message recieved, delete StringValue
				animStringValueObject.Parent = nil
				toolAnimTime = time + .3
			end
	
			if time > toolAnimTime then
				toolAnimTime = 0
				toolAnim = "None"
			end
	
			animateTool()		
		else
			stopToolAnimations()
			toolAnim = "None"
			toolAnimInstance = nil
			toolAnimTime = 0
		end
	end
	
	-- connect events
	Humanoid.Died:connect(onDied)
	Humanoid.Running:connect(onRunning)
	Humanoid.Jumping:connect(onJumping)
	Humanoid.Climbing:connect(onClimbing)
	Humanoid.GettingUp:connect(onGettingUp)
	Humanoid.FreeFalling:connect(onFreeFall)
	Humanoid.FallingDown:connect(onFallingDown)
	Humanoid.Seated:connect(onSeated)
	Humanoid.PlatformStanding:connect(onPlatformStanding)
	Humanoid.Swimming:connect(onSwimming)
	
	-- setup emote chat hook
	game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
		local emote = ""
		if msg == "/e dance" then
			emote = dances[math.random(1, #dances)]
		elseif (string.sub(msg, 1, 3) == "/e ") then
			emote = string.sub(msg, 4)
		elseif (string.sub(msg, 1, 7) == "/emote ") then
			emote = string.sub(msg, 8)
		end
		
		if (pose == "Standing" and emoteNames[emote] ~= nil) then
			playAnimation(emote, 0.1, Humanoid)
		end
	
	end)
	
	
	-- main program
	
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
	
	while Figure.Parent ~= nil do
		local _, time = wait(0.1)
		move(time)
	end
	
	
	
end;
task.spawn(C_417);
-- StarterGui.ScreenGui.cool.Main.BottomRow.R6.R6.DefaultCharacter.Humanoid.Jump
local function C_432()
local script = G2L["432"];
	local Mouse = game.Players.LocalPlayer:GetMouse()
	Mouse.KeyDown:connect(function(Key)
	if Key == " " then
	local Active = true
	local Connection = Mouse.KeyUp:connect(function(Key)
	if Key == " " then
	Active = false
	end
	end)
	
	while Active do
	script.Parent.Jump = true
	wait()
	end
	Connection:Disconnect()
	end
	end)
end;
task.spawn(C_432);
-- StarterGui.ScreenGui.cool.Main.BottomRow.TextHider.LocalScript
local function C_492()
local script = G2L["492"];
	script.Parent.MouseButton1Click:Connect(function()
		if script.Parent.Parent.Parent.Middle.ExecuteBox.TextTransparency == 0 then
			script.Parent.Parent.Parent.Middle.ExecuteBox.TextTransparency = 1
		elseif
			script.Parent.Parent.Parent.Middle.ExecuteBox.TextTransparency == 1 then
			script.Parent.Parent.Parent.Middle.ExecuteBox.TextTransparency = 0
		end
	end)
end;
task.spawn(C_492);
-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.PlayerGuiClean.LocalScript
local function C_49e()
local script = G2L["49e"];
	script.Parent.MouseButton1Click:Connect(function()
		for i,v in pairs(game.Players.LocalPlayer.PlayerGui:GetChildren()) do
			if v.Name == 'nse' or v.Name ==  'Freecam' or v.Name == 'Chat' or v.Name == 'BubbleChat' then
				print(v.Name..' Is apart of the roblox PlayerGui.')
			else
				print(v.Name..' Isnt apart of the roblox PlayerGuii')
				v:Destroy()
			end
		end
	end)
end;
task.spawn(C_49e);
-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.TH8_2.LocalScript
local function C_4a1()
local script = G2L["4a1"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_4a1);
-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.DexExplorer.LocalScript
local function C_4a5()
local script = G2L["4a5"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_4a5);
-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.GNv4.LocalScript
local function C_4a8()
local script = G2L["4a8"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_4a8);
-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.SBGR.LocalScript
local function C_4ad()
local script = G2L["4ad"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_4ad);
-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.BIble.LocalScript
local function C_4b0()
local script = G2L["4b0"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_4b0);
-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.Infyield.LocalScript
local function C_4b4()
local script = G2L["4b4"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_4b4);
-- StarterGui.ScreenGui.cool.Main.SideRow.SideRowScroll.Infyield.LocalScript
local function C_4b9()
local script = G2L["4b9"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_4b9);
-- StarterGui.ScreenGui.cool.Main.LocalScript
local function C_4bf()
local script = G2L["4bf"];
	script.Parent.Active = true
	script.Parent.Draggable = true
end;
task.spawn(C_4bf);
-- StarterGui.ScreenGui.cool.Main.Smooth GUI Dragging
local function C_4d3()
local script = G2L["4d3"];
	local UserInputService = game:GetService("UserInputService")
	local runService = (game:GetService("RunService"));
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	function Lerp(a, b, m)
		return a + (b - a) * m
	end;
	
	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (8); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;
	
		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	runService.Heartbeat:Connect(Update)
end;
task.spawn(C_4d3);
-- StarterGui.ScreenGui.cool.Main.TextButton.LocalScript
local function C_4d5()
local script = G2L["4d5"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page1.Visible = true
		script.Parent.Parent.Parent.Main.Visible = false
	end)
end;
task.spawn(C_4d5);
-- StarterGui.ScreenGui.cool.Main.TextButton.LocalScript
local function C_4d7()
local script = G2L["4d7"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page2.Visible = true
		script.Parent.Parent.Parent.Main.Visible = false
	end)
end;
task.spawn(C_4d7);
-- StarterGui.ScreenGui.cool.Main.TextButton.LocalScript
local function C_4d9()
local script = G2L["4d9"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.trollinggui.Visible = true
		script.Parent.Parent.Parent.Main.Visible = false
	end)
end;
task.spawn(C_4d9);
-- StarterGui.ScreenGui.cool.Main.TextButton.LocalScript
local function C_4db()
local script = G2L["4db"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.page5.Visible = true
		script.Parent.Parent.Parent.Main.Visible = false
	end)
end;
task.spawn(C_4db);
-- StarterGui.ScreenGui.cool.Main.TextButton.LocalScript
local function C_4dd()
local script = G2L["4dd"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page6.Visible = true
		script.Parent.Parent.Parent.Main.Visible = false
	end)
end;
task.spawn(C_4dd);
-- StarterGui.ScreenGui.cool.Main.TextButton.LocalScript
local function C_4df()
local script = G2L["4df"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page7.Visible = true
		script.Parent.Parent.Parent.Main.Visible = false
	end)
end;
task.spawn(C_4df);
-- StarterGui.ScreenGui.cool.Main.TextButton.LocalScript
local function C_4e1()
local script = G2L["4e1"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page8.Visible = true
		script.Parent.Parent.Parent.Main.Visible = false
	end)
end;
task.spawn(C_4e1);
-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.LocalScript
local function C_4e9()
local script = G2L["4e9"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_4e9);
-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.LocalScript
local function C_4ed()
local script = G2L["4ed"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_4ed);
-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.LocalScript
local function C_4f1()
local script = G2L["4f1"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_4f1);
-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.LocalScript
local function C_4f5()
local script = G2L["4f5"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_4f5);
-- StarterGui.ScreenGui.cool.Frame.TextLabel.TextButton.LocalScript
local function C_4f9()
local script = G2L["4f9"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.RemoteEvent:FireServer()
	end)
end;
task.spawn(C_4f9);
-- StarterGui.ScreenGui.cool.PasswordFrame.Smooth GUI Dragging
local function C_515()
local script = G2L["515"];
	local UserInputService = game:GetService("UserInputService")
	local runService = (game:GetService("RunService"));
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	function Lerp(a, b, m)
		return a + (b - a) * m
	end;
	
	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (8); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;
	
		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	runService.Heartbeat:Connect(Update)
end;
task.spawn(C_515);
-- StarterGui.ScreenGui.cool.Password Handler
local function C_516()
local script = G2L["516"];
	local Gui = script.Parent
	local Page1 = Gui:WaitForChild("Page1")
	local PasswordFrame = Gui:WaitForChild("PasswordFrame")
	local EnterBtn = PasswordFrame:WaitForChild("EnterButton")
	
	local Password = "Zelow"
	
	EnterBtn.MouseButton1Click:Connect(function()
		if PasswordFrame.TextBox.Text == Password then
		    Page1.Visible = true
			PasswordFrame.Visible = false
		end
	end)
end;
task.spawn(C_516);

return G2L["1"], require;
