\r\nv3 = Vector3.new\r\ncn = CFrame.new\r\nca2 = CFrame.Angles\r\nmf = math.floor\r\nmran = math.random\r\nmrad = math.rad\r\nmdeg = math.deg\r\nca = function(x,y,z) return ca2(mrad(x),mrad(y),mrad(z)) end \r\nmran2 = function(a,b) return mran(a*1000,b*1000)/1000 end \r\nud=UDim2.new\r\nbn = BrickColor.new\r\nc3 = Color3.new\r\n-----\r\n--Player='PerfectTrollz'\r\nPlayers=game:service'Players'\r\nPlayer=Players.LocalPlayer --[Player] \r\nPChar=Player.Character\r\n\r\nas,so={},{'metal','Block','Slash','Slash2','Hit','Kick'}\r\nas.corner='11294911'\r\nas.cone='1033714'\r\nas.ring=\"3270017\"\r\nas.Chakram='47260990'\r\nas.ring2='18430887'\r\nas.blast='20329976'\r\nas.missile='10207677'\r\nas.fire='2693346'\r\nas.boom='3264793'\r\nas.slash='10209645'\r\nas.abscond='2767090'\r\nas.firelaser='13775494'\r\nas.diamond='9756362'\r\nas.metal='rbxasset://sounds\\\\unsheath.wav'\r\nas.Block = 'rbxasset://sounds\\\\metal.ogg'\r\nas.Slash = '10209645'\r\nas.Slash2 = '46760716'\r\nas.Hit='10209583'\r\nas.Kick='46153268'\r\nas.cast='2101137'\r\nas.rockhead= '21629626'\r\nas.rockheadt='21629620'\r\n\r\n\r\nfor i,v in pairs(as) do \r\nif type(tonumber(v:sub(1,3)))==\"number\" then\r\nas[i]=\"http://www.roblox.com/asset/?id=\"..v\r\nend\r\nend\r\n\r\nLastMade=nil\r\niNew=function(tab)\r\nlocal v=Instance.new(tab[1])\r\nfor Ind,Val in pairs(tab) do\r\nif Ind~=1 and Ind~=2 then \r\nv[Ind] = Val\r\nend\r\nend\r\nv.Parent=tab[2]==0 and LastMade or tab[2]\r\nLastMade=v\r\nreturn v\r\nend\r\niPart=function(tab)\r\nlocal v=Instance.new(tab.type or 'Part')\r\nif tab.type~='CornerWedgePart' then v.formFactor='Custom' end\r\nv.TopSurface=0 v.BottomSurface=0\r\nif tab.sc then\r\nv.Size=v3(tab[2]*tab.sc,tab[3]*tab.sc,tab[4]*tab.sc)\r\nelse\r\nv.Size=v3(tab[2],tab[3],tab[4])\r\nend\r\nif tab.co then v.BrickColor=bn(tab.co) end\r\nif tab.tr then v.Transparency=tab.tr end\r\nif tab.rf then v.Reflectance=tab.rf end\r\nif tab.can then v.CanCollide=tab.can end\r\nif tab.cf then v.CFrame=tab.cf end\r\nif tab.an then v.Anchored=tab.an end\r\nif tab.na then v.Name=tab.na end\r\nif tab.ma then v.Material=tab.ma end\r\nv.Parent=tab[1]\r\nv:BreakJoints()\r\nLastMade=v\r\nreturn v\r\nend\r\nfunction getoutline(x,z,i)\r\nreturn math.sqrt(x^2+z^2)+(i or 0.05),mdeg(math.atan2(x,z))\r\nend\r\nfunction v32(cf)\r\nlocal x,y,z=cf:toEulerAnglesXYZ()\r\nreturn v3(mdeg(x),mdeg(y),mdeg(z))\r\nend\r\nWeldLib={}\r\nfunction GetWeld(weld,CO) \r\nif not WeldLib[weld] then \r\nlocal x0,y0,z0=weld.C0:toEulerAnglesXYZ()\r\nlocal x1,y1,z1=weld.C1:toEulerAnglesXYZ()\r\nWeldLib[weld]={[0]=v3(mdeg(x0),mdeg(y0),mdeg(z0)),[1]=v3(mdeg(x1),mdeg(y1),mdeg(z1))}\r\nend \r\nreturn weld['C'..CO].p,WeldLib[weld][CO]\r\nend \r\nfunction ClearWeld(weld)\r\nif WeldLib[weld] then WeldLib[weld]=nil end \r\nend\r\nfunction TweenNum(i,loops,i1,i2,smooth)\r\nsmooth = smooth or 1 \r\nlocal perc \r\nif smooth == 1 then perc = math.sin((math.pi/2)/loops*i) else perc = i/loops end \r\nlocal ton\r\nif i1 > i2 then \r\nton = -math.abs(i1 - i2) *perc \r\nelse \r\nton = math.abs(i1 - i2) *perc \r\nend \r\nreturn i1+ton\r\nend\r\nfunction TweenV3(i,loops,v1,v2,smooth)\r\nsmooth = smooth or 1 \r\nlocal perc \r\nif smooth == 1 then perc = math.sin((math.pi/2)/loops*i) else perc = i/loops end \r\nlocal tox2,toy2,toz2 = 0,0,0 \r\nif v1.x > v2.x then \r\ntox2 = -math.abs(v1.x - v2.x) *perc \r\nelse \r\ntox2 = math.abs(v1.x - v2.x) *perc \r\nend \r\nif v1.y > v2.y then \r\ntoy2 = -math.abs(v1.y - v2.y) *perc \r\nelse \r\ntoy2 = math.abs(v1.y - v2.y) *perc \r\nend \r\nif v1.z > v2.z then \r\ntoz2 = -math.abs(v1.z - v2.z) *perc \r\nelse \r\ntoz2 = math.abs(v1.z - v2.z) *perc \r\nend\r\nreturn v3(v1.x + tox2,v1.y + toy2,v1.z + toz2)\r\nend\r\nfunction TweenCF(i,loops,origpos,origangle,nextpos,nextangle,smooth) \r\nsmooth = smooth or 1 \r\nlocal perc \r\nif smooth == 1 then perc = math.sin((math.pi/2)/loops*i) else perc = i/loops end \r\nlocal tox,toy,toz = 0,0,0 \r\nif origangle.x > nextangle.x then tox = -math.abs(origangle.x - nextangle.x) *perc \r\nelse tox = math.abs(origangle.x - nextangle.x) *perc end \r\nif origangle.y > nextangle.y then toy = -math.abs(origangle.y - nextangle.y) *perc \r\nelse toy = math.abs(origangle.y - nextangle.y) *perc end \r\nif origangle.z > nextangle.z then toz = -math.abs(origangle.z - nextangle.z) *perc \r\nelse toz = math.abs(origangle.z - nextangle.z) *perc end \r\nlocal tox2,toy2,toz2 = 0,0,0 \r\nif origpos.x > nextpos.x then \r\ntox2 = -math.abs(origpos.x - nextpos.x) *perc \r\nelse tox2 = math.abs(origpos.x - nextpos.x) *perc end \r\nif origpos.y > nextpos.y then \r\ntoy2 = -math.abs(origpos.y - nextpos.y) *perc \r\nelse toy2 = math.abs(origpos.y - nextpos.y) *perc end \r\nif origpos.z > nextpos.z then \r\ntoz2 = -math.abs(origpos.z - nextpos.z) *perc \r\nelse toz2 = math.abs(origpos.z - nextpos.z) *perc end\r\nreturn cn(origpos.x + tox2,origpos.y + toy2,origpos.z + toz2)*ca(origangle.x + tox,origangle.y + toy,origangle.z + toz) \r\nend \r\nfunction SetWeld(weld,CO,i, loops, origpos,origangle, nextpos,nextangle,smooth) \r\nloops=math.floor(loops)\r\nsmooth = smooth or 1 \r\nif not WeldLib[weld] then \r\nlocal x0,y0,z0=weld.C0:toEulerAnglesXYZ()\r\nlocal x1,y1,z1=weld.C1:toEulerAnglesXYZ()\r\nWeldLib[weld]={[0]=v3(mdeg(x0),mdeg(y0),mdeg(z0)),[1]=v3(mdeg(x1),mdeg(y1),mdeg(z1))}\r\nend \r\nlocal perc =smooth==1 and math.sin((math.pi/2)/loops*i) or i/loops \r\n--print(weld.Part1)\r\nlocal tox,toy,toz = 0,0,0 \r\ntox = origangle.x > nextangle.x and -math.abs(origangle.x - nextangle.x) *perc or math.abs(origangle.x - nextangle.x) *perc \r\ntoy = origangle.y > nextangle.y and -math.abs(origangle.y - nextangle.y) *perc or math.abs(origangle.y - nextangle.y) *perc \r\ntoz = origangle.z > nextangle.z and -math.abs(origangle.z - nextangle.z) *perc or math.abs(origangle.z - nextangle.z) *perc \r\nlocal tox2,toy2,toz2 = 0,0,0 \r\ntox2= origpos.x > nextpos.x and -math.abs(origpos.x - nextpos.x) *perc or math.abs(origpos.x - nextpos.x) *perc \r\ntoy2= origpos.y > nextpos.y and -math.abs(origpos.y - nextpos.y) *perc or math.abs(origpos.y - nextpos.y) *perc\r\ntoz2= origpos.z > nextpos.z and -math.abs(origpos.z - nextpos.z) *perc or math.abs(origpos.z - nextpos.z) *perc \r\nWeldLib[weld][CO] = v3(origangle.x + tox,origangle.y + toy,origangle.z + toz)\r\nweld['C'..CO] = cn(origpos.x + tox2,origpos.y + toy2,origpos.z + toz2)*ca(origangle.x + tox,origangle.y + toy,origangle.z + toz) \r\nend \r\nfunction se(Key,Text) \r\nlocal Values = {} \r\nfor value in (Text..Key):gmatch(\"(.-)\"..Key) do \r\ntable.insert(Values,value)\r\nend \r\nlocal Values2={}\r\nfor i,v in pairs(Values) do Values2[i]=Values[i]:lower() end\r\nreturn Values,Values2\r\nend\r\nfindplayer=function(nn)\r\nif not nn then return nil end \r\nlocal found \r\nfor i,v in pairs(Players:GetPlayers()) do \r\nif string.find(v.Name:lower(),nn:lower()) and not found then found=v end \r\nend\r\nreturn found\r\nend\r\nLoopFunctions={}\r\niLoopFunctions=-9000\r\nfunction DoLoop(times,func)\r\niLoopFunctions=iLoopFunctions+1\r\nLoopFunctions[tonumber(iLoopFunctions)]={times,0,func}\r\nend\r\nfunction MeshEffect(times,cf1,cf2,scale1,scale2,tr1,tr2,col,type)\r\nlocal cf2=cf2 or cf1\r\nlocal v=iPart{Char,0.2,0.2,0.2,co=col,cf=cf1,na='Mesh',an=true,ca=false,tr=tr1} \r\nlocal mesh=iNew{'SpecialMesh',v,Scale=scale1}\r\nif type=='Brick' or type=='Sphere' then \r\nmesh.MeshType=type\r\nelse\r\nmesh.MeshId=type\r\nend\r\nlocal x1,y1,z1 = cf1:toEulerAnglesXYZ()\r\nlocal x2,y2,z2 = cf2:toEulerAnglesXYZ()\r\nlocal count=0\r\nDoLoop(times,function(i) count=count+1 \r\nmesh.Scale=TweenV3(count,times,scale1,scale2,1)*((type=='Brick' or type=='Sphere') and 5 or 1)\r\nv.Transparency=TweenNum(count,times,tr1,tr2,1) \r\nv.CFrame=TweenCF(count,times,cf1.p,v3(mdeg(x1),mdeg(y1),mdeg(z1)),cf2.p,v3(mdeg(x2),mdeg(y2),mdeg(z2)),1) \r\nif i==1 then v:Remove() end end)\r\nend\r\nDmgv={8,16}\r\nHitDebounce={}\r\nDamage=function(Hum,Mult,Sound) \r\nif not Hum or Hum.Parent==Char then return end \r\nif not Hum.Parent:findFirstChild'Torso' then return end \r\nlocal HName=Hum.Parent.Name\r\nif HitDebounce[HName] and HitDebounce[HName]>tick() then return end \r\nHitDebounce[HName]=tick()+0.2\r\nlocal Mult=Mult or 1\r\nlocal Dealt=mran(Dmgv[1],Dmgv[2])*Mult\r\nlocal col=''\r\nif Hum.Parent:findFirstChild'Block' and Hum.Parent.Block.Value>0 then \r\nHum.Parent.Block.Value=Hum.Parent.Block.Value-1\r\ncol='Bright blue'\r\nelse\r\nHum.Health=Hum.Health-Dealt\r\ncol='Bright red'\r\nend\r\nif Sound then so[col=='Bright blue' and 'Block' or 'Hit']:Play() end\r\nlocal DoH=iNew{'Model',Char,Name=col=='Bright blue' and 'Block' or Dealt}\r\niNew{'Humanoid',DoH,MaxHealth=1/0,Health=1/0,Name=''}\r\nlocal Doh=iPart{DoH,0.6,0.2,0.6,co=col,an=true} Doh.Name='Head' iNew{'CylinderMesh',Doh}\r\nlocal dofs=Hum.Parent.Torso.CFrame*cn(mran2(-1.5,1.5),2.5,mran2(-1,1)) Doh.CFrame=dofs\r\nDoLoop(40,function(i) Doh.CFrame=dofs*cn(0,i*2,0) Doh.Transparency=i-0.5 if i==1 then DoH:Remove() end end)\r\nend\r\nAOEFind = function(pos,ra,f,f2) -- range get \r\nlocal p0,p1=pos-v3(ra/2,ra/2,ra/2),pos+v3(ra/2,ra/2,ra/2)\r\npcall(function()\r\nfor i,v in pairs(workspace:FindPartsInRegion3(Region3.new(p0,p1),nil,100)) do \r\nlocal Hum=v.Parent:findFirstChild'Humanoid' \r\nif v.Name=='Torso' and Hum and Hum.Health>0 and v.Parent~=Char then\r\npcall(function() f(Hum,v) end) \r\nelseif f2 and not Hum then \r\npcall(function() f2(v) end) \r\nend \r\nend\r\nend) \r\nend \r\nfunction FindSurface(part, position) \r\nlocal obj = part.CFrame:pointToObjectSpace(position) \r\nlocal siz = part.Size/2 \r\nfor i,v in pairs(Enum.NormalId:GetEnumItems()) do \r\nlocal vec = Vector3.FromNormalId(v) \r\nlocal wvec = part.CFrame:vectorToWorldSpace(vec) \r\nlocal vz = (obj)/(siz*vec) \r\nif (math.abs(vz.X-1) < 0.01 or math.abs(vz.Y-1) < 0.01 or math.abs(vz.Z-1) < 0.01) then\r\nreturn wvec,vec \r\nend \r\nend \r\nif part.className == \"WedgePart\" then \r\nreturn part.CFrame:vectorToWorldSpace(Vector3.new(0,0.707,-0.707)), Vector3.new(0,0.707,-0.707) \r\nend \r\nend\r\nfunction FaceBG(pos)\r\nBG.maxTorque=v3(1,1,1)/0\r\nBG.cframe=cn(Torso.Position,v3(pos.x,Torso.Position.y,pos.z))*cn(0,0,-1)\r\nend\r\nray = function(Pos, Dir,tab,length) -- ray cast\r\nreturn workspace:FindPartOnRay(Ray.new(Pos, Dir.unit *(length or 999)),tab) \r\nend \r\nfunction Projectile(ofs,speed,part,adj,fhit,fnohit)\r\npart.CFrame=ofs*adj\r\nlocal stop=false\r\nDoLoop(50,function(x) \r\nlocal i=x\r\nif not stop then \r\nlocal hit,pos=ray(ofs.p,ofs.p-ofs*cn(0,0,-1).p,Char,speed+1)\r\nif hit then \r\n--Hit\r\nif fhit then i=1 stop=true\r\n----\r\nlocal cof=FindSurface(hit,pos)\r\n--iPart{workspace,2,2,0.2,cf=cn(pos,pos+cof),an=true,co='Black'}\r\n----\r\nlocal x,y,z=ofs:toEulerAnglesXYZ()\r\nofs=cn(pos)*ca(mdeg(x),mdeg(y),mdeg(z))*cn(0,0,-part.Size.y/2)\r\npart.CFrame=ofs*adj\r\nfhit(hit,pos) end \r\nelse\r\nofs=ofs*cn(0,0,speed)\r\npart.CFrame=ofs*adj\r\nend\r\nif i==1 then \r\nif fnohit then fnohit(ofs.p) else part:Remove() end\r\nend \r\nend\r\nend)\r\nend\r\n\r\nCC={'','Bright yellow','Flame reddish orange'}\r\nScale=5\r\nMat='Marble'\r\n\r\nSpawnPoint=PChar.Torso.CFrame*cn(0,1+Scale*3,-20-Scale*1.5)\r\nname='Brock'\r\npcall(function() _G.OldMod00:Remove() end)\r\n\r\n---------------\r\nUNDYING=function()\r\npcall(function() fUNDYING:disconnect() end)\r\npcall(function() local hum=Grabbing.Part1.Parent.Humanoid Grabbing:Remove() Grabbing=nil hum.PlatformStand=false end)\r\nTorso.Anchored=true Torso.Transparency=1 Torso.CanCollide=false\r\nStand:Remove() Head:Remove()\r\nlocal RespawnPos=cn(Torso.CFrame.p+v3(0,Scale*5,0))*ca(0,mran(-360,360),0)\r\nwait(4)\r\nAnim='Reviving'\r\nlocal oldChar=Char\r\nlocal oldRootLimbs=RootLimbs\r\nfor i,v in pairs(oldRootLimbs) do v.Anchored=true end\r\nfMarble(Char,function(v) v.Anchored=true end) \r\nMakeAI(RespawnPos) Anim='Reviving' \r\nfMarble(Char,function(v) v.Transparency=1 end) \r\nfor i,v in pairs(RootLimbs) do v.Transparency=1 end \r\nwait(0.1) Torso.Anchored=true\r\nlocal Reconstruct={} \r\nfMarble(oldChar,function(v) \r\nlocal x1,y1,z1=v.CFrame:toEulerAnglesXYZ() \r\nlocal x2,y2,z2=Char[v.Parent.Name][v.Name].CFrame:toEulerAnglesXYZ()\r\nReconstruct[#Reconstruct+1]={v,Char[v.Parent.Name][v.Name],v.Position,v3(mdeg(x1),mdeg(y1),mdeg(z1)),v3(mdeg(x2),mdeg(y2),mdeg(z2))} end) \r\nfor i,v in pairs(oldRootLimbs) do \r\nlocal x1,y1,z1=v.CFrame:toEulerAnglesXYZ() \r\nlocal x2,y2,z2=Char[v.Name].CFrame:toEulerAnglesXYZ()\r\nReconstruct[#Reconstruct+1]={v,Char[v.Name],v.Position,v3(mdeg(x1),mdeg(y1),mdeg(z1)),v3(mdeg(x2),mdeg(y2),mdeg(z2))} end\r\nlocal tweens=100\r\nfor tween=1,tweens do \r\nfor i,v in pairs(Reconstruct) do v[1].CFrame=TweenCF(tween,tweens,v[3],v[4],v[2].Position,v[5],1)*ca(360*(tween/tweens),720*(tween/tweens),0) end\r\nwait()\r\nend\r\noldChar:Remove()\r\nfMarble(Char,function(v) v.Transparency=0 end)\r\nfor i,v in pairs(RootLimbs) do v.Transparency=0 end\r\nTorso.Anchored=false wait()\r\nBG.maxTorque=v3(1,1,1)/0 BG.cframe=Torso.CFrame\r\nReturnAnim()\r\nwait(2)\r\nBG.maxTorque=nov3\r\nAnim,ArmAnim,LegAnim='None','None','None'\r\nend\r\n------\r\n\r\nfunction MakeAI(SpawnPoint2)\r\nChar=iNew{'Model',workspace,Name=name,archivable=false} _G.OldMod00=Char\r\nTorso=iPart{Char,2,2,1,sc=Scale,co=CC[1],cf=SpawnPoint2,na='Torso'} \r\npTorso=iPart{Char,2,2,1,sc=Scale,co=CC[1],cf=SpawnPoint2,na='pTorso'} \r\nHead=iPart{Char,1,1,1,sc=Scale,co=CC[1],na='Head'} \r\npHead=iPart{Char,1,1,1,sc=Scale,co=CC[1],na='pHead'} iNew{'SpecialMesh',pHead,Scale=v3(1,1,1)*Scale/1.4,VertexColor=v3(1,1,1)/1.65,MeshId=as.rockhead,TextureId=as.rockheadt}\r\nStand=iPart{Char,1.5,2.9,1.1,sc=Scale,co=CC[1],na='Stand'}\r\n\r\nfor i,n in pairs(so) do \r\nlocal v=iNew{'Sound',Torso,Volume=1,Pitch=1,Looped=false,Name=v,SoundId=as[n]}\r\nso[n]=v\r\nend\r\n\r\n\r\nLSho=iPart{Char,1,1.5,1,sc=Scale,co=CC[1],na='LSho'} \r\nLArm=iPart{Char,1,1.5,1,sc=Scale,co=CC[1],na='LArm'} \r\n\r\nRSho=iPart{Char,1,1.5,1,sc=Scale,co=CC[1],na='RSho'} \r\nRArm=iPart{Char,1,1.5,1,sc=Scale,co=CC[1],na='RArm'} \r\n\r\nLThi=iPart{Char,1,1.5,1,sc=Scale,co=CC[1],na='LThi'} \r\nLLeg=iPart{Char,1,1.5,1,sc=Scale,co=CC[1],na='LLeg'} \r\n\r\nRThi=iPart{Char,1,1.5,1,sc=Scale,co=CC[1],na='RThi'} \r\nRLeg=iPart{Char,1,1.5,1,sc=Scale,co=CC[1],na='RLeg'} \r\n\r\n\r\n\r\nnov3=v3(0,0,0)\r\nMarble={}\r\nMarbleSpeed=0.2\r\nMarbleMax=12\r\nfor i,v in pairs({pTorso,LSho,RSho,LArm,RArm,LThi,RThi,LLeg,RLeg}) do \r\nv.Material=Mat \r\nlocal VS=v.Size\r\nlocal va=1.2\r\n--v.Size=v.Size/1.5\r\nlocal vv=v:Clone()\r\nfor x=-1,1,2 do \r\nfor y=-1,1,2 do \r\nfor z=-1,1,2 do\r\nlocal marb=vv:Clone() marb.Size=VS/mran2(1.8,2.2) marb.Parent=v marb.Name=x..y..z\r\nlocal wmarb=iNew{'Weld',marb,Part0=v,Part1=marb,C0=cn(VS.x/4*x/va,VS.y/4*y,VS.z/4*z/va)*ca(mran(-MarbleMax,MarbleMax),mran(-MarbleMax,MarbleMax),mran(-MarbleMax,MarbleMax))}\r\nMarble[#Marble+1]={wmarb,mran(-1,1),mran(-1,1),mran(-1,1)}\r\nend end end \r\niNew{'BlockMesh',v,Scale=v3(1,1,1)/1.5}\r\nv.Transparency=0 --.995\r\nend \r\n\r\nfor i,v in pairs(Char:children()) do if v:IsA'BasePart' and v.Name~='Torso' then v.CFrame=Torso.CFrame end end\r\n\r\nHead.Transparency=0.99\r\nHead.CanCollide=false\r\nNeck=iNew{'Weld',Torso,Part0=Torso,Part1=Head,C0=cn(0,0,0)}\r\npNeck=iNew{'Weld',Torso,Part0=pTorso,Part1=pHead,C0=cn(0,1.5*Scale,0)}\r\nHum=iNew{'Humanoid',Char} \r\n\r\n\r\nTorso.Transparency=1\r\nwTorso=iNew{'Weld',Torso,Part0=Torso,Part1=pTorso,C0=cn(0,-2.5*Scale,0)*ca(0,0,0)}\r\noTorso=cn(0,0,0)\r\n\r\nStand.Transparency=1\r\nwStand=iNew{'Weld',Torso,Part0=Torso,Part1=Stand,C0=cn(0,-2.5*Scale,0)}\r\n\r\nwLSho=iNew{'Weld',LSho,Part0=pTorso,Part1=LSho,C0=cn(-1.5*Scale,0.75*Scale,0),C1=cn(0,0.25*Scale,0)}\r\nwLArm=iNew{'Weld',LArm,Part0=LSho,Part1=LArm,C0=cn(0,-0.75*Scale,0),C1=cn(0,0.75*Scale,0)}\r\n\r\nwRSho=iNew{'Weld',RSho,Part0=pTorso,Part1=RSho,C0=cn(1.5*Scale,0.75*Scale,0),C1=cn(0,0.25*Scale,0)}\r\nwRArm=iNew{'Weld',RArm,Part0=RSho,Part1=RArm,C0=cn(0,-0.75*Scale,0),C1=cn(0,0.75*Scale,0)}\r\n\r\nwLThi=iNew{'Weld',LThi,Part0=pTorso,Part1=LThi,C0=cn(-0.5*Scale,-1*Scale,0),C1=cn(0,0.75*Scale,0)}\r\nwLLeg=iNew{'Weld',LLeg,Part0=LThi,Part1=LLeg,C0=cn(1,-0.75*Scale,0),C1=cn(0,0.75*Scale,0)}\r\n\r\nwRThi=iNew{'Weld',RThi,Part0=pTorso,Part1=RThi,C0=cn(0.5*Scale,-1*Scale,0),C1=cn(0,0.75*Scale,0)}\r\nwRLeg=iNew{'Weld',RLeg,Part0=RThi,Part1=RLeg,C0=cn(0,-0.75*Scale,0),C1=cn(0,0.75*Scale,0)}\r\n\r\nwLSho.C0=cn(-1.5*Scale,0.75*Scale,0)*ca(0,0,-135) --a,b\r\nwLArm.C0=cn(0,-0.75*Scale,0)*ca(0,0,0) --c,d\r\nwRSho.C0=cn(1.5*Scale,0.75*Scale,0)*ca(0,0,135) --e,f\r\nwRArm.C0=cn(0,-0.75*Scale,0)*ca(0,0,0) --g,h\r\n----\r\nwLThi.C0=cn(-0.5*Scale,-1*Scale,0)*ca(0,0,-45) --i,j\r\nwLLeg.C0=cn(0,-0.75*Scale,0)*ca(0,0,0) --k,l\r\nwRThi.C0=cn(0.5*Scale,-1*Scale,0)*ca(0,0,45) --m,n\r\nwRLeg.C0=cn(0,-0.75*Scale,0)*ca(0,0,0) --o,p\r\n\r\nBG=iNew{'BodyGyro',Torso,maxTorque=nov3}\r\nBP=iNew{'BodyPosition',Torso,maxForce=nov3}\r\nfUNDYING=Hum.Died:connect(UNDYING)\r\nLimbNames={'LSho','RSho','LArm','RArm','RThi','LThi','RLeg','LLeg'}\r\nfor i=1,8 do local v=LimbNames[i] LimbNames[v]=getfenv()[\"w\"..v] end \r\nRootLimbs={pHead,pTorso,LSho,RSho,LArm,RArm,RThi,LThi,RLeg,LLeg}\r\nAnim,LegAnim,ArmAnim='Sit','Sit','Sit'\r\nlocal a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p=GetPose() \r\nSetWeld(wLSho,0,1,1,a,b,v3(-1.5*Scale,0.5*Scale,0),v3(0,0,-10),1) \r\nSetWeld(wLArm,0,1,1,c,d,v3(0,-0.75*Scale,0),v3(10,0,10),1)\r\nSetWeld(wRSho,0,1,1,e,f,v3(1.5*Scale,0.5*Scale,0),v3(0,0,10),1)\r\nSetWeld(wRArm,0,1,1,g,h,v3(0,-0.75*Scale,0),v3(10,0,-10),1) \r\nSetWeld(wLThi,0,1,1,i,j,v3(-0.5*Scale,-1*Scale,0),v3(15,0,-5),1) \r\nSetWeld(wLLeg,0,1,1,k,l,v3(0,-0.75*Scale,0),v3(-15,0,5),1)\r\nSetWeld(wRThi,0,1,1,m,n,v3(0.5*Scale,-1*Scale,0),v3(15,0,5),1) \r\nSetWeld(wRLeg,0,1,1,o,p,v3(0,-0.75*Scale,0),v3(-15,0,-5),1)\r\nOa,Ob,Oc,Od,Oe,Of,Og,Oh,Oi,Oj,Ok,Ol,Om,On,Oo,Op=GetPose() \r\nSetWeld(wLSho,0,1,1,nov3,nov3,a,b,1) \r\nSetWeld(wLArm,0,1,1,nov3,nov3,c,d,1)\r\nSetWeld(wRSho,0,1,1,nov3,nov3,e,f,1)\r\nSetWeld(wRArm,0,1,1,nov3,nov3,g,h,1) \r\nSetWeld(wLThi,0,1,1,nov3,nov3,i,j,1) \r\nSetWeld(wLLeg,0,1,1,nov3,nov3,k,l,1)\r\nSetWeld(wRThi,0,1,1,nov3,nov3,m,n,1) \r\nSetWeld(wRLeg,0,1,1,nov3,nov3,o,p,1)\r\nend\r\n\r\nfunction GetPose() \r\nlocal a,b=GetWeld(wLSho,0) \r\nlocal c,d=GetWeld(wLArm,0)\r\nlocal e,f=GetWeld(wRSho,0)\r\nlocal g,h=GetWeld(wRArm,0) \r\nlocal i,j=GetWeld(wLThi,0)\r\nlocal k,l=GetWeld(wLLeg,0)\r\nlocal m,n=GetWeld(wRThi,0)\r\nlocal o,p=GetWeld(wRLeg,0)\r\nlocal q,r=GetWeld(wTorso,0)\r\nreturn a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r\r\nend\r\n\r\nMakeAI(SpawnPoint)\r\n\r\nASpeed=28\r\ncoroutine.resume(coroutine.create(function()\r\nSetWeld(wLSho,0,1,1,nov3,nov3,wLSho.C0.p,v3(45,0,-10),1) \r\nSetWeld(wLArm,0,1,1,nov3,nov3,wLArm.C0.p,v3(45,0,10),1)\r\nSetWeld(wRSho,0,1,1,nov3,nov3,wRSho.C0.p,v3(45,0,10),1) \r\nSetWeld(wRArm,0,1,1,nov3,nov3,wRArm.C0.p,v3(45,0,-10),1) \r\nSetWeld(wLThi,0,1,1,nov3,nov3,v3(-0.5*Scale,-0.6*Scale,-0.5*Scale),v3(125,0,-12),1) \r\nSetWeld(wLLeg,0,1,1,nov3,nov3,wLLeg.C0.p,v3(-70,0,12),1) \r\nSetWeld(wRThi,0,1,1,nov3,nov3,v3( 0.5*Scale,-0.6*Scale,-0.5*Scale),v3(125,0,12),1) \r\nSetWeld(wRLeg,0,1,1,nov3,nov3,wRLeg.C0.p,v3(-70,0,-12),1) \r\nSetWeld(wTorso,0,1,1,oTorso,nov3,v3(0,-3*Scale,0),nov3,1)\r\nwait(1)\r\nAnim='Standing'\r\nlocal a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p=GetPose() \r\nfor x=1,ASpeed do \r\nSetWeld(wTorso,0,x,ASpeed,wTorso.C0.p,nov3,oTorso,nov3,1) \r\nSetWeld(wLSho,0,x,ASpeed,a,b,v3(-1.5*Scale,0.5*Scale,0),v3(0,0,-10),1) \r\nSetWeld(wLArm,0,x,ASpeed,c,d,v3(0,-0.75*Scale,0),v3(10,0,10),1)\r\nSetWeld(wRSho,0,x,ASpeed,e,f,v3(1.5*Scale,0.5*Scale,0),v3(0,0,10),1)\r\nSetWeld(wRArm,0,x,ASpeed,g,h,v3(0,-0.75*Scale,0),v3(10,0,-10),1) \r\nSetWeld(wLThi,0,x,ASpeed,i,j,v3(-0.5*Scale,-1*Scale,0),v3(15,0,-5),1) \r\nSetWeld(wLLeg,0,x,ASpeed,k,l,v3(0,-0.75*Scale,0),v3(-15,0,5),1)\r\nSetWeld(wRThi,0,x,ASpeed,m,n,v3(0.5*Scale,-1*Scale,0),v3(15,0,5),1) \r\nSetWeld(wRLeg,0,x,ASpeed,o,p,v3(0,-0.75*Scale,0),v3(-15,0,-5),1)\r\nwait() \r\nend \r\nArmAnim='None'\r\nLegAnim='None'\r\nAnim='None'\r\nend))\r\n--Target=PChar\r\nfunction Stay(bool,cff)\r\nBG.maxTorque=bool and v3(1,1,1)/0 or nov3 BG.cframe=cff or Torso.CFrame\r\nBP.maxForce=BG.maxTorque BP.position=Torso.Position\r\nend\r\nfunction fMarble(Ch,func)\r\nfor i,v in pairs(Ch:children()) do \r\nfor x=-1,1,2 do \r\nfor y=-1,1,2 do \r\nfor z=-1,1,2 do \r\nif v:findFirstChild(x..y..z) then func(v[x..y..z]) end\r\nend end end \r\nend\r\nend\r\nfunction ReturnAnim()\r\nlocal ne1,ne2=GetWeld(pNeck,0)\r\nlocal wt1,wt2=GetWeld(wTorso,0)\r\nlocal a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p=GetPose() \r\nfor x=1,ASpeed do \r\nSetWeld(wLSho,0,x,ASpeed,a,b,Oa,Ob,1) \r\nSetWeld(wLArm,0,x,ASpeed,c,d,Oc,Od,1)\r\nSetWeld(wRSho,0,x,ASpeed,e,f,Oe,Of,1) \r\nSetWeld(wRArm,0,x,ASpeed,g,h,Og,Oh,1) \r\nSetWeld(wLThi,0,x,ASpeed,i,j,Oi,Oj,1) \r\nSetWeld(wLLeg,0,x,ASpeed,k,l,Ok,Ol,1) \r\nSetWeld(wRThi,0,x,ASpeed,m,n,Om,On,1) \r\nSetWeld(wRLeg,0,x,ASpeed,o,p,Oo,Op,1) \r\nSetWeld(wTorso,0,x,ASpeed,wt1,wt2,oTorso,nov3,1) \r\nSetWeld(pNeck,0,x,ASpeed,ne1,ne2,v3(0,1.5,0)*Scale,nov3,1)\r\nwait()\r\nend\r\nend\r\n\r\nChatConnection=Player.Chatted:connect(function(msg)\r\ncoroutin[...string is too long...]
